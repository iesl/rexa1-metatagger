<?xml version="1.0" encoding="ISO-8859-1"?>
<document>
<page n="1">
<line><tbox llx="165" lly="714" urx="461" ury="735" f="1"><![CDATA[Improved Single-Round Protocols for ]]></tbox></line>
<line><tbox llx="197" lly="694" urx="429" ury="715" f="1"><![CDATA[Remote File Synchronization ]]></tbox></line>
<line><tbox llx="186" lly="664" urx="259" ury="679" f="2"><![CDATA[Utku Irmak ]]></tbox><tbox llx="262" lly="664" urx="356" ury="679" f="2"><![CDATA[Svilen Mihaylov ]]></tbox><tbox llx="359" lly="664" urx="436" ury="679" f="2"><![CDATA[Torsten Suel ]]></tbox></line>
<line><tbox llx="268" lly="642" urx="353" ury="655" f="3"><![CDATA[CIS Department ]]></tbox></line>
<line><tbox llx="254" lly="629" urx="367" ury="642" f="3"><![CDATA[Polytechnic University ]]></tbox></line>
<line><tbox llx="257" lly="616" urx="364" ury="629" f="3"><![CDATA[Brooklyn, NY 11201 ]]></tbox></line>
<line><tbox llx="145" lly="604" urx="473" ury="614" f="4"><![CDATA[uirmak@cis.poly.edu, smihay01@utopia.poly.edu, suel@poly.edu ]]></tbox></line>
<line><tbox llx="58" lly="568" urx="107" ury="579" f="5"><![CDATA[Abstract--- ]]></tbox><tbox llx="99" lly="568" urx="308" ury="579" f="6"><![CDATA[Given two versions of a file, a current version ]]></tbox></line>
<line><tbox llx="48" lly="558" urx="308" ury="569" f="6"><![CDATA[located on one machine and an outdated version known only to ]]></tbox></line>
<line><tbox llx="48" lly="548" urx="309" ury="559" f="6"><![CDATA[another machine, the remote file synchronization problem is how ]]></tbox></line>
<line><tbox llx="48" lly="538" urx="309" ury="549" f="6"><![CDATA[to update the outdated version over a network with a minimal ]]></tbox></line>
<line><tbox llx="48" lly="528" urx="308" ury="540" f="6"><![CDATA[amount of communication. In particular, when the versions are ]]></tbox></line>
<line><tbox llx="48" lly="518" urx="308" ury="530" f="6"><![CDATA[very similar, the total data transmitted should be significantly ]]></tbox></line>
<line><tbox llx="48" lly="508" urx="308" ury="520" f="6"><![CDATA[smaller than the file size. File synchronization problems arise ]]></tbox></line>
<line><tbox llx="48" lly="498" urx="309" ury="510" f="6"><![CDATA[in many application scenarios such as web site mirroring, file ]]></tbox></line>
<line><tbox llx="48" lly="488" urx="308" ury="500" f="6"><![CDATA[system backup and replication, and web access over slow links. ]]></tbox></line>
<line><tbox llx="48" lly="478" urx="225" ury="490" f="6"><![CDATA[An open source tool for this problem, called ]]></tbox><tbox llx="217" lly="478" urx="247" ury="490" f="5"><![CDATA[rsync ]]></tbox><tbox llx="240" lly="478" urx="308" ury="490" f="6"><![CDATA[and included in ]]></tbox></line>
<line><tbox llx="48" lly="468" urx="286" ury="480" f="6"><![CDATA[many Linux distributions, is widely used in such scenarios. ]]></tbox><tbox llx="279" lly="468" urx="308" ury="480" f="5"><![CDATA[rsync ]]></tbox></line>
<line><tbox llx="48" lly="458" urx="308" ury="470" f="6"><![CDATA[uses a single round of messages between the two machines. While ]]></tbox></line>
<line><tbox llx="48" lly="448" urx="308" ury="460" f="6"><![CDATA[recent research has shown that significant additional savings in ]]></tbox></line>
<line><tbox llx="48" lly="439" urx="308" ury="450" f="6"><![CDATA[bandwidth consumption are possible through the use of optimized ]]></tbox></line>
<line><tbox llx="48" lly="429" urx="308" ury="440" f="6"><![CDATA[multi-round protocols, there are many scenarios where multiple ]]></tbox></line>
<line><tbox llx="48" lly="419" urx="150" ury="430" f="6"><![CDATA[rounds are undesirable. ]]></tbox></line>
<line><tbox llx="58" lly="407" urx="309" ury="418" f="6"><![CDATA[In this paper, we study single-round protocols for file syn- ]]></tbox></line>
<line><tbox llx="48" lly="397" urx="265" ury="408" f="6"><![CDATA[chronization that offer significant improvements over ]]></tbox><tbox llx="258" lly="397" urx="311" ury="408" f="5"><![CDATA[rsync.Our ]]></tbox></line>
<line><tbox llx="48" lly="387" urx="309" ury="398" f="6"><![CDATA[main contribution is a new approach to file synchronization based ]]></tbox></line>
<line><tbox llx="48" lly="377" urx="308" ury="388" f="6"><![CDATA[on the use of erasure codes. Using this approach, we design ]]></tbox></line>
<line><tbox llx="48" lly="367" urx="308" ury="379" f="6"><![CDATA[a single-round protocol that is provably efficient with respect ]]></tbox></line>
<line><tbox llx="48" lly="357" urx="308" ury="369" f="6"><![CDATA[to common measures of file distance, and another optimized ]]></tbox></line>
<line><tbox llx="48" lly="347" urx="286" ury="359" f="6"><![CDATA[practical protocol that shows promising improvements over ]]></tbox><tbox llx="279" lly="347" urx="308" ury="358" f="5"><![CDATA[rsync ]]></tbox></line>
<line><tbox llx="48" lly="337" urx="309" ury="349" f="6"><![CDATA[on our data sets. In addition, we show how to obtain moderate ]]></tbox></line>
<line><tbox llx="48" lly="327" urx="188" ury="339" f="6"><![CDATA[improvements by engineering the ]]></tbox><tbox llx="182" lly="327" urx="211" ury="339" f="5"><![CDATA[rsync ]]></tbox><tbox llx="205" lly="327" urx="253" ury="339" f="6"><![CDATA[approach. ]]></tbox></line>
<line><tbox llx="134" lly="302" urx="223" ury="314" f="7"><![CDATA[I. INTRODUCTION ]]></tbox></line>
<line><tbox llx="58" lly="282" urx="309" ury="295" f="9"><![CDATA[Consider the problem of maintaining replicated collections ]]></tbox></line>
<line><tbox llx="48" lly="270" urx="309" ury="283" f="9"><![CDATA[of files, such as user files, web pages, or documents, over ]]></tbox></line>
<line><tbox llx="48" lly="259" urx="309" ury="271" f="9"><![CDATA[a slow network. In particular, assume that we have two ]]></tbox></line>
<line><tbox llx="48" lly="247" urx="99" ury="259" f="9"><![CDATA[machines, ]]></tbox><tbox llx="93" lly="246" urx="111" ury="257" f="10"><![CDATA[A ]]></tbox><tbox llx="104" lly="247" urx="129" ury="259" f="9"><![CDATA[and ]]></tbox><tbox llx="124" lly="246" urx="144" ury="257" f="10"><![CDATA[B, ]]></tbox><tbox llx="137" lly="247" urx="309" ury="259" f="9"><![CDATA[that each hold a copy of the files, and ]]></tbox></line>
<line><tbox llx="48" lly="235" urx="309" ury="247" f="9"><![CDATA[that files may have been updated at one of the machines. Pe- ]]></tbox></line>
<line><tbox llx="48" lly="223" urx="309" ury="235" f="9"><![CDATA[riodically, a machine may initiate a synchronization operation ]]></tbox></line>
<line><tbox llx="48" lly="211" urx="309" ury="223" f="9"><![CDATA[that updates all its replicas to the latest version. This operation ]]></tbox></line>
<line><tbox llx="48" lly="199" urx="309" ury="211" f="9"><![CDATA[involves identifying all files that have changed, deciding which ]]></tbox></line>
<line><tbox llx="48" lly="187" urx="309" ury="199" f="9"><![CDATA[version of the file is the latest one (if files can be changed at ]]></tbox></line>
<line><tbox llx="48" lly="175" urx="309" ury="187" f="9"><![CDATA[either location), and finally updating any outdated files. Or ]]></tbox></line>
<line><tbox llx="48" lly="163" urx="309" ury="175" f="9"><![CDATA[alternatively, when a particular file is accessed, a machine ]]></tbox></line>
<line><tbox llx="48" lly="151" urx="309" ury="163" f="9"><![CDATA[may have to update its local version of the file. If the file ]]></tbox></line>
<line><tbox llx="48" lly="139" urx="309" ury="151" f="9"><![CDATA[or file collection is large or the network fairly slow, then it ]]></tbox></line>
<line><tbox llx="48" lly="127" urx="309" ury="139" f="9"><![CDATA[is desirable to perform this synchronization with a minimum ]]></tbox></line>
<line><tbox llx="48" lly="115" urx="241" ury="127" f="9"><![CDATA[amount of communication over the network. ]]></tbox></line>
<line><tbox llx="58" lly="102" urx="309" ury="114" f="9"><![CDATA[The above scenario arises in a number of applications, such ]]></tbox></line>
<line><tbox llx="48" lly="90" urx="309" ury="102" f="9"><![CDATA[as synchronization of user files between different machines, ]]></tbox></line>
<line><tbox llx="48" lly="78" urx="309" ury="90" f="9"><![CDATA[distributed file systems, remote backups, mirroring of large ]]></tbox></line>
<line><tbox llx="48" lly="66" urx="309" ury="78" f="9"><![CDATA[web and ftp sites, content distribution networks, or web access, ]]></tbox></line>
<line><tbox llx="311" lly="568" urx="573" ury="580" f="9"><![CDATA[to name just a few. In many cases, updated files differ only ]]></tbox></line>
<line><tbox llx="311" lly="556" urx="572" ury="568" f="9"><![CDATA[slightly from their previous version; for example, updated web ]]></tbox></line>
<line><tbox llx="311" lly="544" urx="572" ury="556" f="9"><![CDATA[pages usually change only in a few places. In this case, instead ]]></tbox></line>
<line><tbox llx="311" lly="532" urx="572" ury="544" f="9"><![CDATA[of sending the entire updated version over the network, it ]]></tbox></line>
<line><tbox llx="311" lly="520" urx="573" ury="532" f="9"><![CDATA[would be desirable to perform the update by sending only an ]]></tbox></line>
<line><tbox llx="311" lly="508" urx="572" ury="520" f="9"><![CDATA[amount of data proportional to the degree of change between ]]></tbox></line>
<line><tbox llx="311" lly="496" urx="391" ury="508" f="9"><![CDATA[the two versions. ]]></tbox></line>
<line><tbox llx="321" lly="483" urx="572" ury="495" f="9"><![CDATA[In this paper, we focus on this problem of updating files in a ]]></tbox></line>
<line><tbox llx="311" lly="471" urx="527" ury="483" f="9"><![CDATA[bandwidth efficient manner; we refer to this as the ]]></tbox><tbox llx="519" lly="471" urx="572" ury="483" f="11"><![CDATA[remote file ]]></tbox></line>
<line><tbox llx="311" lly="459" urx="423" ury="471" f="11"><![CDATA[synchronization problem. ]]></tbox><tbox llx="416" lly="459" urx="572" ury="471" f="9"><![CDATA[We note that there is a very widely ]]></tbox></line>
<line><tbox llx="311" lly="447" urx="473" ury="459" f="9"><![CDATA[used open source software tool called ]]></tbox><tbox llx="465" lly="447" urx="500" ury="459" f="11"><![CDATA[rsync, ]]></tbox><tbox llx="492" lly="447" urx="572" ury="459" f="9"><![CDATA[included in many ]]></tbox></line>
<line><tbox llx="311" lly="435" urx="572" ury="447" f="9"><![CDATA[Linux distributions, that addresses this problem and that is ]]></tbox></line>
<line><tbox llx="311" lly="423" urx="374" ury="435" f="9"><![CDATA[based on the ]]></tbox><tbox llx="367" lly="423" urx="399" ury="435" f="11"><![CDATA[rsync ]]></tbox><tbox llx="392" lly="423" urx="573" ury="435" f="9"><![CDATA[algorithm and protocol described in [39], ]]></tbox></line>
<line><tbox llx="311" lly="411" urx="461" ury="423" f="9"><![CDATA[[41]. Another popular tool called ]]></tbox><tbox llx="455" lly="411" urx="492" ury="423" f="11"><![CDATA[unison ]]></tbox><tbox llx="486" lly="411" urx="572" ury="423" f="9"><![CDATA[[28] also uses the ]]></tbox></line>
<line><tbox llx="311" lly="399" urx="572" ury="411" f="9"><![CDATA[same basic algorithm. Our goal is to derive new algorithms ]]></tbox></line>
<line><tbox llx="311" lly="387" urx="481" ury="399" f="9"><![CDATA[that achieve significant savings over the ]]></tbox><tbox llx="473" lly="387" urx="506" ury="399" f="11"><![CDATA[rsync ]]></tbox><tbox llx="498" lly="387" urx="572" ury="399" f="9"><![CDATA[algorithm in the ]]></tbox></line>
<line><tbox llx="311" lly="375" urx="572" ury="387" f="9"><![CDATA[case of slow networks. We focus on approaches that exchange ]]></tbox></line>
<line><tbox llx="311" lly="363" urx="572" ury="375" f="9"><![CDATA[only a single round of messages between the machines holding ]]></tbox></line>
<line><tbox llx="311" lly="351" urx="573" ury="363" f="9"><![CDATA[the outdated and current version of a file; such approaches are ]]></tbox></line>
<line><tbox llx="311" lly="339" urx="544" ury="351" f="9"><![CDATA[preferable in a number of scenarios as discussed later. ]]></tbox></line>
<line><tbox llx="321" lly="326" urx="572" ury="338" f="9"><![CDATA[Before continuing, we point out a few assumptions. We ]]></tbox></line>
<line><tbox llx="311" lly="314" urx="572" ury="326" f="9"><![CDATA[assume that collections consist of unstructured files that may ]]></tbox></line>
<line><tbox llx="311" lly="302" urx="572" ury="314" f="9"><![CDATA[be modified in arbitrary ways, including insertion and deletion ]]></tbox></line>
<line><tbox llx="311" lly="290" urx="572" ury="302" f="9"><![CDATA[operations that change line and page alignments between ]]></tbox></line>
<line><tbox llx="311" lly="278" urx="572" ury="290" f="9"><![CDATA[different versions. Thus, approaches that identify changed disk ]]></tbox></line>
<line><tbox llx="311" lly="266" urx="572" ury="278" f="9"><![CDATA[pages or bit positions or that assume fixed record boundaries ]]></tbox></line>
<line><tbox llx="311" lly="254" urx="572" ury="266" f="9"><![CDATA[do not work -- though some of them are potentially useful ]]></tbox></line>
<line><tbox llx="311" lly="242" urx="572" ury="254" f="9"><![CDATA[for identifying those files that have been changed and need ]]></tbox></line>
<line><tbox llx="311" lly="230" urx="572" ury="242" f="9"><![CDATA[to be synchronized. We note that the problem would also ]]></tbox></line>
<line><tbox llx="311" lly="218" urx="573" ury="230" f="9"><![CDATA[be easier if all update operations to the files are saved in ]]></tbox></line>
<line><tbox llx="311" lly="206" urx="572" ury="218" f="9"><![CDATA[an update log that can be transmitted to the other machine, ]]></tbox></line>
<line><tbox llx="311" lly="194" urx="572" ury="206" f="9"><![CDATA[or if the machine holding the current version has a copy of ]]></tbox></line>
<line><tbox llx="311" lly="182" urx="572" ury="194" f="9"><![CDATA[the outdated version. However, in many scenarios this is not ]]></tbox></line>
<line><tbox llx="311" lly="170" urx="572" ury="182" f="9"><![CDATA[the case. We are not concerned with issues of consistency in ]]></tbox></line>
<line><tbox llx="311" lly="158" urx="572" ury="170" f="9"><![CDATA[between synchronization steps, and with the question of how ]]></tbox></line>
<line><tbox llx="311" lly="146" urx="573" ury="158" f="9"><![CDATA[to resolve conflicts if changes are simultaneously performed at ]]></tbox></line>
<line><tbox llx="311" lly="134" urx="573" ury="146" f="9"><![CDATA[several locations (see [3], [29] for a discussion). We assume a ]]></tbox></line>
<line><tbox llx="311" lly="122" urx="572" ury="134" f="9"><![CDATA[simple two-party scenario where it is known which files need ]]></tbox></line>
<line><tbox llx="311" lly="110" urx="551" ury="122" f="9"><![CDATA[to be updated and which is the current version of a file. ]]></tbox></line>
<pbox llx="48.00" lly="66.00" urx="573.00" ury="735.00"/></page>
<page n="2">
<line><tbox llx="48" lly="723" urx="122" ury="735" f="1"><![CDATA[A. Applications ]]></tbox></line>
<line><tbox llx="58" lly="707" urx="309" ury="719" f="2"><![CDATA[We now discuss the most common application scenarios for ]]></tbox></line>
<line><tbox llx="48" lly="695" urx="187" ury="707" f="2"><![CDATA[file synchronization techniques. ]]></tbox></line>
<line><tbox llx="59" lly="676" urx="71" ury="689" f="3"><![CDATA[. ]]></tbox><tbox llx="68" lly="680" urx="207" ury="693" f="4"><![CDATA[Synchronization of user files: ]]></tbox><tbox llx="200" lly="680" urx="246" ury="692" f="2"><![CDATA[Both the ]]></tbox><tbox llx="239" lly="680" urx="271" ury="692" f="1"><![CDATA[rsync ]]></tbox><tbox llx="265" lly="680" urx="290" ury="692" f="2"><![CDATA[and ]]></tbox><tbox llx="283" lly="680" urx="310" ury="692" f="1"><![CDATA[uni- ]]></tbox></line>
<line><tbox llx="68" lly="668" urx="92" ury="680" f="1"><![CDATA[son ]]></tbox><tbox llx="86" lly="668" urx="309" ury="680" f="2"><![CDATA[tools are widely used to synchronize personal files ]]></tbox></line>
<line><tbox llx="68" lly="656" urx="309" ury="668" f="2"><![CDATA[between different machines, say between a machine at ]]></tbox></line>
<line><tbox llx="68" lly="644" urx="309" ury="656" f="2"><![CDATA[home and one at work, that may only be connected over ]]></tbox></line>
<line><tbox llx="68" lly="632" urx="218" ury="644" f="2"><![CDATA[a slow network such as a modem. ]]></tbox></line>
<line><tbox llx="59" lly="616" urx="71" ury="629" f="3"><![CDATA[. ]]></tbox><tbox llx="68" lly="620" urx="206" ury="633" f="4"><![CDATA[Web and ftp site mirroring: ]]></tbox><tbox llx="200" lly="620" urx="232" ury="632" f="1"><![CDATA[rsync ]]></tbox><tbox llx="226" lly="620" urx="309" ury="632" f="2"><![CDATA[is widely used to ]]></tbox></line>
<line><tbox llx="68" lly="608" urx="309" ury="620" f="2"><![CDATA[mirror busy web and ftp sites, including sites distributing ]]></tbox></line>
<line><tbox llx="68" lly="596" urx="309" ury="609" f="2"><![CDATA[new versions of software. In this case, there may be ]]></tbox></line>
<line><tbox llx="68" lly="584" urx="309" ury="597" f="2"><![CDATA[significant similarities between successive versions of a ]]></tbox></line>
<line><tbox llx="68" lly="573" urx="309" ury="585" f="2"><![CDATA[software package that allow a mirror to efficiently update ]]></tbox></line>
<line><tbox llx="68" lly="561" urx="166" ury="573" f="2"><![CDATA[to the newest release. ]]></tbox></line>
<line><tbox llx="59" lly="544" urx="71" ury="557" f="3"><![CDATA[. ]]></tbox><tbox llx="68" lly="549" urx="216" ury="561" f="4"><![CDATA[Content distribution networks: ]]></tbox><tbox llx="210" lly="549" urx="309" ury="561" f="2"><![CDATA[Several companies in ]]></tbox></line>
<line><tbox llx="68" lly="537" urx="309" ury="549" f="2"><![CDATA[the CDN space have studied and deployed file syn- ]]></tbox></line>
<line><tbox llx="68" lly="525" urx="224" ury="537" f="2"><![CDATA[chronization techniques similar to ]]></tbox><tbox llx="219" lly="525" urx="254" ury="537" f="1"><![CDATA[rsync. ]]></tbox><tbox llx="249" lly="525" urx="309" ury="537" f="2"><![CDATA[We are not ]]></tbox></line>
<line><tbox llx="68" lly="513" urx="309" ury="525" f="2"><![CDATA[aware of any published work in this direction, but file ]]></tbox></line>
<line><tbox llx="68" lly="501" urx="309" ury="513" f="2"><![CDATA[synchronization techniques are a natural approach for ]]></tbox></line>
<line><tbox llx="68" lly="489" urx="309" ury="501" f="2"><![CDATA[updating content replicated at the network edge or at ]]></tbox></line>
<line><tbox llx="68" lly="477" urx="238" ury="489" f="2"><![CDATA[several location of a company intranet. ]]></tbox></line>
<line><tbox llx="59" lly="460" urx="71" ury="474" f="3"><![CDATA[. ]]></tbox><tbox llx="68" lly="465" urx="205" ury="477" f="4"><![CDATA[Web access over slow links: ]]></tbox><tbox llx="199" lly="465" urx="309" ury="477" f="2"><![CDATA[A user revisiting a web ]]></tbox></line>
<line><tbox llx="68" lly="453" urx="309" ury="465" f="2"><![CDATA[page may already have a previous version of the page ]]></tbox></line>
<line><tbox llx="68" lly="441" urx="309" ury="453" f="2"><![CDATA[in the browser cache, and it would be desirable to avoid ]]></tbox></line>
<line><tbox llx="68" lly="429" urx="309" ury="441" f="2"><![CDATA[transmission of the entire updated version. This idea is, ]]></tbox></line>
<line><tbox llx="68" lly="417" urx="178" ury="429" f="2"><![CDATA[e.g., implemented in the ]]></tbox><tbox llx="171" lly="417" urx="207" ury="429" f="1"><![CDATA[rproxy ]]></tbox><tbox llx="200" lly="417" urx="309" ury="429" f="2"><![CDATA[system [40], which uses ]]></tbox></line>
<line><tbox llx="68" lly="405" urx="91" ury="417" f="2"><![CDATA[the ]]></tbox><tbox llx="84" lly="405" urx="116" ury="417" f="1"><![CDATA[rsync ]]></tbox><tbox llx="110" lly="405" urx="309" ury="417" f="2"><![CDATA[algorithm to efficiently update pages that are ]]></tbox></line>
<line><tbox llx="68" lly="393" urx="141" ury="405" f="2"><![CDATA[being revisited. ]]></tbox></line>
<line><tbox llx="48" lly="379" urx="309" ury="391" f="2"><![CDATA[In addition, there are several other scenarios where the tech- ]]></tbox></line>
<line><tbox llx="48" lly="367" urx="309" ury="379" f="2"><![CDATA[niques could be employed, such as replication of content in a ]]></tbox></line>
<line><tbox llx="48" lly="355" urx="309" ury="367" f="2"><![CDATA[P2P or grid environment, sharing of large web page archives ]]></tbox></line>
<line><tbox llx="48" lly="343" urx="309" ury="355" f="2"><![CDATA[for mining and web search, distributed backup, or wide-area ]]></tbox></line>
<line><tbox llx="48" lly="331" urx="155" ury="343" f="2"><![CDATA[distributed file systems. ]]></tbox></line>
<line><tbox llx="48" lly="313" urx="165" ury="325" f="1"><![CDATA[B. Problem Formalization ]]></tbox></line>
<line><tbox llx="58" lly="296" urx="309" ury="308" f="2"><![CDATA[The setup for the file synchronization problem is as follows. ]]></tbox></line>
<line><tbox llx="48" lly="284" urx="179" ury="296" f="2"><![CDATA[We have two files (strings) ]]></tbox><tbox llx="176" lly="284" urx="190" ury="295" f="5"><![CDATA[f ]]></tbox><tbox llx="181" lly="283" urx="202" ury="291" f="6"><![CDATA[new ]]></tbox><tbox llx="196" lly="284" urx="216" ury="295" f="5"><![CDATA[,f ]]></tbox><tbox llx="205" lly="283" urx="223" ury="291" f="6"><![CDATA[old ]]></tbox><tbox llx="224" lly="277" urx="241" ury="295" f="7"><![CDATA[# ]]></tbox><tbox llx="236" lly="284" urx="254" ury="297" f="8"><![CDATA[# ]]></tbox><tbox llx="245" lly="283" urx="253" ury="296" f="3"><![CDATA[# ]]></tbox><tbox llx="254" lly="284" urx="309" ury="296" f="2"><![CDATA[over some ]]></tbox></line>
<line><tbox llx="48" lly="272" urx="92" ury="284" f="2"><![CDATA[alphabet ]]></tbox><tbox llx="85" lly="272" urx="104" ury="285" f="8"><![CDATA[# ]]></tbox><tbox llx="98" lly="272" urx="309" ury="284" f="2"><![CDATA[(most methods are character/byte oriented), and ]]></tbox></line>
<line><tbox llx="48" lly="260" urx="114" ury="272" f="2"><![CDATA[two machines ]]></tbox><tbox llx="109" lly="260" urx="126" ury="271" f="5"><![CDATA[C ]]></tbox><tbox llx="119" lly="260" urx="192" ury="272" f="2"><![CDATA[(the client) and ]]></tbox><tbox llx="186" lly="260" urx="202" ury="271" f="5"><![CDATA[S ]]></tbox><tbox llx="195" lly="260" urx="309" ury="272" f="2"><![CDATA[(the server) connected by ]]></tbox></line>
<line><tbox llx="48" lly="248" urx="222" ury="260" f="2"><![CDATA[a communication link. We also refer to ]]></tbox><tbox llx="217" lly="248" urx="232" ury="259" f="5"><![CDATA[f ]]></tbox><tbox llx="222" lly="247" urx="240" ury="255" f="6"><![CDATA[old ]]></tbox><tbox llx="236" lly="248" urx="271" ury="260" f="2"><![CDATA[as the ]]></tbox><tbox llx="264" lly="248" urx="310" ury="260" f="1"><![CDATA[outdated ]]></tbox></line>
<line><tbox llx="48" lly="236" urx="71" ury="248" f="1"><![CDATA[file ]]></tbox><tbox llx="64" lly="236" urx="101" ury="248" f="2"><![CDATA[and to ]]></tbox><tbox llx="96" lly="236" urx="111" ury="247" f="5"><![CDATA[f ]]></tbox><tbox llx="101" lly="235" urx="123" ury="243" f="6"><![CDATA[new ]]></tbox><tbox llx="119" lly="236" urx="154" ury="248" f="2"><![CDATA[as the ]]></tbox><tbox llx="147" lly="236" urx="206" ury="248" f="1"><![CDATA[current file. ]]></tbox><tbox llx="199" lly="236" urx="276" ury="248" f="2"><![CDATA[We assume that ]]></tbox><tbox llx="271" lly="236" urx="287" ury="247" f="5"><![CDATA[C ]]></tbox><tbox llx="281" lly="236" urx="309" ury="248" f="2"><![CDATA[only ]]></tbox></line>
<line><tbox llx="48" lly="224" urx="112" ury="236" f="2"><![CDATA[has a copy of ]]></tbox><tbox llx="106" lly="224" urx="121" ury="235" f="5"><![CDATA[f ]]></tbox><tbox llx="111" lly="223" urx="129" ury="231" f="6"><![CDATA[old ]]></tbox><tbox llx="124" lly="224" urx="149" ury="236" f="2"><![CDATA[and ]]></tbox><tbox llx="142" lly="224" urx="158" ury="235" f="5"><![CDATA[S ]]></tbox><tbox llx="151" lly="224" urx="236" ury="236" f="2"><![CDATA[only has a copy of ]]></tbox><tbox llx="230" lly="224" urx="244" ury="235" f="5"><![CDATA[f ]]></tbox><tbox llx="235" lly="223" urx="256" ury="231" f="6"><![CDATA[new ]]></tbox><tbox llx="248" lly="224" urx="309" ury="236" f="2"><![CDATA[. Our goal is ]]></tbox></line>
<line><tbox llx="48" lly="212" urx="298" ury="224" f="2"><![CDATA[to design a protocol between the two parties that results in ]]></tbox><tbox llx="292" lly="212" urx="309" ury="223" f="5"><![CDATA[C ]]></tbox></line>
<line><tbox llx="48" lly="200" urx="130" ury="212" f="2"><![CDATA[holding a copy of ]]></tbox><tbox llx="124" lly="200" urx="138" ury="211" f="5"><![CDATA[f ]]></tbox><tbox llx="129" lly="199" urx="150" ury="207" f="6"><![CDATA[new ]]></tbox><tbox llx="142" lly="200" urx="309" ury="212" f="2"><![CDATA[, while minimizing the communication ]]></tbox></line>
<line><tbox llx="48" lly="188" urx="309" ury="200" f="2"><![CDATA[cost. We limit ourselves to a single round of messages between ]]></tbox></line>
<line><tbox llx="48" lly="176" urx="309" ury="189" f="2"><![CDATA[client and server, and measure communication cost in terms ]]></tbox></line>
<line><tbox llx="48" lly="164" urx="309" ury="177" f="2"><![CDATA[of the total number of bits exchanged between the two parties. ]]></tbox></line>
<line><tbox llx="58" lly="151" urx="108" ury="163" f="2"><![CDATA[For a file ]]></tbox><tbox llx="103" lly="151" urx="165" ury="162" f="5"><![CDATA[f,weusef ]]></tbox><tbox llx="154" lly="151" urx="174" ury="164" f="8"><![CDATA[[i] ]]></tbox><tbox llx="168" lly="151" urx="234" ury="163" f="2"><![CDATA[to denote the ]]></tbox><tbox llx="229" lly="151" urx="250" ury="162" f="5"><![CDATA[ith ]]></tbox><tbox llx="244" lly="151" urx="297" ury="163" f="2"><![CDATA[symbol of ]]></tbox><tbox llx="292" lly="151" urx="306" ury="162" f="5"><![CDATA[f ]]></tbox><tbox llx="296" lly="151" urx="309" ury="163" f="2"><![CDATA[, ]]></tbox></line>
<line><tbox llx="47" lly="139" urx="63" ury="152" f="8"><![CDATA[0 ]]></tbox><tbox llx="57" lly="132" urx="75" ury="150" f="7"><![CDATA[# ]]></tbox><tbox llx="67" lly="139" urx="102" ury="150" f="5"><![CDATA[i<|f ]]></tbox><tbox llx="93" lly="132" urx="109" ury="150" f="7"><![CDATA[|, ]]></tbox><tbox llx="100" lly="139" urx="125" ury="151" f="2"><![CDATA[and ]]></tbox><tbox llx="119" lly="139" urx="133" ury="150" f="5"><![CDATA[f ]]></tbox><tbox llx="122" lly="139" urx="143" ury="152" f="8"><![CDATA[[i, ]]></tbox><tbox llx="135" lly="139" urx="152" ury="150" f="5"><![CDATA[j] ]]></tbox><tbox llx="144" lly="139" urx="303" ury="151" f="2"><![CDATA[to denote the block of symbols from ]]></tbox><tbox llx="297" lly="139" urx="310" ury="150" f="5"><![CDATA[i ]]></tbox></line>
<line><tbox llx="48" lly="127" urx="144" ury="139" f="2"><![CDATA[up to (and including) ]]></tbox><tbox llx="138" lly="127" urx="155" ury="138" f="5"><![CDATA[j. ]]></tbox><tbox llx="147" lly="127" urx="309" ury="139" f="2"><![CDATA[We assume that each symbol consists ]]></tbox></line>
<line><tbox llx="48" lly="115" urx="298" ury="127" f="2"><![CDATA[of a constant number of bits. All logarithms are with base ]]></tbox><tbox llx="291" lly="115" urx="310" ury="128" f="8"><![CDATA[2, ]]></tbox></line>
<line><tbox llx="48" lly="103" urx="105" ury="115" f="2"><![CDATA[and we use ]]></tbox><tbox llx="99" lly="96" urx="123" ury="114" f="7"><![CDATA[#p# ]]></tbox><tbox llx="113" lly="101" urx="124" ury="109" f="9"><![CDATA[2 ]]></tbox><tbox llx="120" lly="103" urx="145" ury="115" f="2"><![CDATA[and ]]></tbox><tbox llx="139" lly="96" urx="163" ury="114" f="7"><![CDATA[#p# ]]></tbox><tbox llx="153" lly="101" urx="164" ury="109" f="9"><![CDATA[2 ]]></tbox><tbox llx="160" lly="103" urx="309" ury="115" f="2"><![CDATA[to denote the next larger and next ]]></tbox></line>
<line><tbox llx="48" lly="91" urx="128" ury="103" f="2"><![CDATA[smaller power of ]]></tbox><tbox llx="120" lly="91" urx="136" ury="104" f="8"><![CDATA[2 ]]></tbox><tbox llx="129" lly="91" urx="190" ury="103" f="2"><![CDATA[of a number ]]></tbox><tbox llx="184" lly="91" urx="201" ury="102" f="5"><![CDATA[p. ]]></tbox></line>
<line><tbox llx="58" lly="78" urx="309" ury="90" f="2"><![CDATA[The communication cost incurred by the protocol should ]]></tbox></line>
<line><tbox llx="48" lly="66" urx="309" ury="78" f="2"><![CDATA[depend on the degree of similarity between the two files. ]]></tbox></line>
<line><tbox llx="311" lly="723" urx="573" ury="735" f="2"><![CDATA[Similarity is usually defined in terms of one of a number of ]]></tbox></line>
<line><tbox llx="311" lly="711" urx="572" ury="723" f="2"><![CDATA[edit distance measures that have been proposed. Some of the ]]></tbox></line>
<line><tbox llx="311" lly="699" urx="419" ury="712" f="2"><![CDATA[most common ones are: ]]></tbox></line>
<line><tbox llx="322" lly="679" urx="334" ury="692" f="3"><![CDATA[. ]]></tbox><tbox llx="331" lly="684" urx="357" ury="696" f="2"><![CDATA[The ]]></tbox><tbox llx="350" lly="684" urx="437" ury="696" f="1"><![CDATA[Hamming distance ]]></tbox><tbox llx="430" lly="684" urx="513" ury="696" f="2"><![CDATA[between two files ]]></tbox><tbox llx="507" lly="684" urx="532" ury="694" f="5"><![CDATA[f,f ]]></tbox><tbox llx="523" lly="683" urx="533" ury="696" f="3"><![CDATA[# ]]></tbox><tbox llx="528" lly="684" urx="572" ury="696" f="2"><![CDATA[of equal ]]></tbox></line>
<line><tbox llx="331" lly="672" urx="539" ury="684" f="2"><![CDATA[length is defined as the number of positions ]]></tbox><tbox llx="536" lly="672" urx="549" ury="682" f="5"><![CDATA[i ]]></tbox><tbox llx="544" lly="672" urx="573" ury="684" f="2"><![CDATA[with ]]></tbox></line>
<line><tbox llx="332" lly="660" urx="347" ury="671" f="5"><![CDATA[f ]]></tbox><tbox llx="336" lly="660" urx="356" ury="673" f="8"><![CDATA[[i] ]]></tbox><tbox llx="350" lly="653" urx="368" ury="671" f="7"><![CDATA[#= ]]></tbox><tbox llx="361" lly="660" urx="376" ury="671" f="5"><![CDATA[f ]]></tbox><tbox llx="367" lly="659" urx="377" ury="672" f="3"><![CDATA[# ]]></tbox><tbox llx="368" lly="660" urx="391" ury="673" f="8"><![CDATA[[i]. ]]></tbox><tbox llx="384" lly="660" urx="572" ury="672" f="2"><![CDATA[Hamming distance is not a good model for ]]></tbox></line>
<line><tbox llx="331" lly="648" urx="572" ury="660" f="2"><![CDATA[unstructured files (as opposed to record-based data) since ]]></tbox></line>
<line><tbox llx="331" lly="636" urx="572" ury="648" f="2"><![CDATA[inserting a symbol at the beginning and deleting one at the ]]></tbox></line>
<line><tbox llx="331" lly="624" urx="572" ury="636" f="2"><![CDATA[end would result in a very large distance due to alignment ]]></tbox></line>
<line><tbox llx="331" lly="612" urx="368" ury="624" f="2"><![CDATA[issues. ]]></tbox></line>
<line><tbox llx="322" lly="596" urx="334" ury="609" f="3"><![CDATA[. ]]></tbox><tbox llx="331" lly="600" urx="357" ury="612" f="2"><![CDATA[The ]]></tbox><tbox llx="351" lly="600" urx="415" ury="612" f="1"><![CDATA[edit distance ]]></tbox><tbox llx="409" lly="600" urx="572" ury="612" f="2"><![CDATA[(also called Levenshtein distance) is ]]></tbox></line>
<line><tbox llx="331" lly="588" urx="572" ury="600" f="2"><![CDATA[the smallest number of insertions, deletions, and changes ]]></tbox></line>
<line><tbox llx="331" lly="576" urx="573" ury="588" f="2"><![CDATA[of single symbols needed to transform one file into the ]]></tbox></line>
<line><tbox llx="331" lly="564" urx="364" ury="576" f="2"><![CDATA[other. ]]></tbox></line>
<line><tbox llx="322" lly="548" urx="334" ury="561" f="3"><![CDATA[. ]]></tbox><tbox llx="331" lly="552" urx="357" ury="564" f="2"><![CDATA[The ]]></tbox><tbox llx="349" lly="552" urx="481" ury="564" f="1"><![CDATA[edit distance with block moves ]]></tbox><tbox llx="473" lly="552" urx="572" ury="564" f="2"><![CDATA[is the smallest number ]]></tbox></line>
<line><tbox llx="331" lly="540" urx="572" ury="552" f="2"><![CDATA[of insertions, deletions, and changes of single symbols or ]]></tbox></line>
<line><tbox llx="331" lly="528" urx="572" ury="541" f="2"><![CDATA[moves of blocks of symbols needed to transform one file ]]></tbox></line>
<line><tbox llx="331" lly="516" urx="572" ury="529" f="2"><![CDATA[into the other. For technical reasons, we assume that each ]]></tbox></line>
<line><tbox llx="331" lly="504" urx="451" ury="517" f="2"><![CDATA[block move operation adds ]]></tbox><tbox llx="443" lly="504" urx="459" ury="517" f="8"><![CDATA[3 ]]></tbox><tbox llx="452" lly="504" urx="572" ury="517" f="2"><![CDATA[to the distance, while other ]]></tbox></line>
<line><tbox llx="331" lly="493" urx="401" ury="505" f="2"><![CDATA[operations add ]]></tbox><tbox llx="393" lly="492" urx="412" ury="505" f="8"><![CDATA[1. ]]></tbox></line>
<line><tbox llx="311" lly="477" urx="572" ury="489" f="2"><![CDATA[There are a number of other distance measures that have been ]]></tbox></line>
<line><tbox llx="311" lly="465" urx="572" ury="477" f="2"><![CDATA[proposed; see [8], [7], [10] for example. We focus mainly on ]]></tbox></line>
<line><tbox llx="311" lly="453" urx="572" ury="465" f="2"><![CDATA[the edit distance with block moves, which seems powerful ]]></tbox></line>
<line><tbox llx="311" lly="441" urx="572" ury="453" f="2"><![CDATA[enough to be used as a reasonable model of file similarity, ]]></tbox></line>
<line><tbox llx="311" lly="429" urx="572" ury="441" f="2"><![CDATA[but still simple enough to work with. We note that even more ]]></tbox></line>
<line><tbox llx="311" lly="417" urx="572" ury="429" f="2"><![CDATA[powerful models, such as models allowing block copies and ]]></tbox></line>
<line><tbox llx="311" lly="405" urx="572" ury="417" f="2"><![CDATA[deletions of blocks, are much harder to analyze and known ]]></tbox></line>
<line><tbox llx="311" lly="393" urx="572" ury="405" f="2"><![CDATA[upper bounds for these cases are often significantly worse [8], ]]></tbox></line>
<line><tbox llx="311" lly="381" urx="358" ury="393" f="2"><![CDATA[[7], [10]. ]]></tbox></line>
<line><tbox llx="321" lly="368" urx="573" ury="380" f="2"><![CDATA[We call a file synchronization protocol feasible if it can ]]></tbox></line>
<line><tbox llx="311" lly="356" urx="572" ury="368" f="2"><![CDATA[be implemented with a polynomial amount of computation ]]></tbox></line>
<line><tbox llx="311" lly="344" urx="572" ury="356" f="2"><![CDATA[(including the cost of decoding the current file at the receiver). ]]></tbox></line>
<line><tbox llx="311" lly="332" urx="572" ury="344" f="2"><![CDATA[A protocol is communication-efficient if it communicates at ]]></tbox></line>
<line><tbox llx="311" lly="320" urx="341" ury="332" f="2"><![CDATA[most ]]></tbox><tbox llx="336" lly="320" urx="363" ury="331" f="5"><![CDATA[O(k ]]></tbox><tbox llx="353" lly="320" urx="372" ury="333" f="8"><![CDATA[lg ]]></tbox><tbox llx="363" lly="325" urx="374" ury="333" f="6"><![CDATA[c ]]></tbox><tbox llx="365" lly="320" urx="394" ury="333" f="8"><![CDATA[(n)) ]]></tbox><tbox llx="388" lly="320" urx="495" ury="332" f="2"><![CDATA[bits, for some constant ]]></tbox><tbox llx="490" lly="320" urx="506" ury="331" f="5"><![CDATA[c, ]]></tbox><tbox llx="500" lly="320" urx="535" ury="332" f="2"><![CDATA[where ]]></tbox><tbox llx="530" lly="320" urx="545" ury="331" f="5"><![CDATA[k ]]></tbox><tbox llx="539" lly="320" urx="572" ury="332" f="2"><![CDATA[is the ]]></tbox></line>
<line><tbox llx="311" lly="308" urx="572" ury="320" f="2"><![CDATA[distance between the two files according to some distance ]]></tbox></line>
<line><tbox llx="311" lly="296" urx="374" ury="308" f="2"><![CDATA[measure and ]]></tbox><tbox llx="369" lly="296" urx="385" ury="307" f="5"><![CDATA[n ]]></tbox><tbox llx="378" lly="296" urx="572" ury="308" f="2"><![CDATA[is the length of the current file. (An upper ]]></tbox></line>
<line><tbox llx="311" lly="284" urx="363" ury="296" f="2"><![CDATA[bound for ]]></tbox><tbox llx="358" lly="284" urx="373" ury="295" f="5"><![CDATA[k ]]></tbox><tbox llx="367" lly="284" urx="572" ury="296" f="2"><![CDATA[may or may not be known at the start of the ]]></tbox></line>
<line><tbox llx="311" lly="272" urx="486" ury="284" f="2"><![CDATA[protocol.) We note that a lower bound of ]]></tbox><tbox llx="478" lly="272" urx="515" ury="285" f="8"><![CDATA[#(k lg ]]></tbox><tbox llx="508" lly="272" urx="531" ury="283" f="5"><![CDATA[n)) ]]></tbox><tbox llx="523" lly="272" urx="572" ury="284" f="2"><![CDATA[bits holds ]]></tbox></line>
<line><tbox llx="311" lly="260" urx="572" ury="272" f="2"><![CDATA[for all of the above distance measures. We assume that both ]]></tbox></line>
<line><tbox llx="311" lly="248" urx="572" ury="260" f="2"><![CDATA[machines have access to a random hash function, and we ]]></tbox></line>
<line><tbox llx="311" lly="236" urx="572" ury="248" f="2"><![CDATA[are interested in protocols that succeed with some fairly high ]]></tbox></line>
<line><tbox llx="311" lly="224" urx="365" ury="236" f="2"><![CDATA[probability ]]></tbox><tbox llx="359" lly="224" urx="377" ury="235" f="5"><![CDATA[p. ]]></tbox></line>
<line><tbox llx="311" lly="204" urx="399" ury="216" f="1"><![CDATA[C. State of the Art ]]></tbox></line>
<line><tbox llx="321" lly="187" urx="572" ury="199" f="2"><![CDATA[We now briefly summarize the current state of the art in ]]></tbox></line>
<line><tbox llx="311" lly="175" urx="572" ury="187" f="2"><![CDATA[file synchronization techniques; some additional discussion of ]]></tbox></line>
<line><tbox llx="311" lly="163" urx="482" ury="175" f="2"><![CDATA[related work is provided in Section IV. ]]></tbox></line>
<line><tbox llx="321" lly="149" urx="572" ury="161" f="2"><![CDATA[There are several very strong theoretical results on the ]]></tbox></line>
<line><tbox llx="311" lly="137" urx="572" ury="150" f="2"><![CDATA[communication complexity of the file synchronization problem ]]></tbox></line>
<line><tbox llx="311" lly="125" urx="431" ury="138" f="2"><![CDATA[(sometimes also called the ]]></tbox><tbox llx="425" lly="125" urx="515" ury="137" f="1"><![CDATA[document exchange ]]></tbox><tbox llx="508" lly="125" urx="527" ury="138" f="2"><![CDATA[or ]]></tbox><tbox llx="521" lly="125" urx="573" ury="137" f="1"><![CDATA[correlated ]]></tbox></line>
<line><tbox llx="311" lly="114" urx="338" ury="125" f="1"><![CDATA[files ]]></tbox><tbox llx="330" lly="113" urx="572" ury="126" f="2"><![CDATA[problem), which establish the existence of asymptotically ]]></tbox></line>
<line><tbox llx="311" lly="102" urx="573" ury="114" f="2"><![CDATA[optimal protocols consisting of one or two rounds [24], [25], ]]></tbox></line>
<line><tbox llx="311" lly="90" urx="573" ury="102" f="2"><![CDATA[[8], [7]. Some of the results model file similarity using a ]]></tbox></line>
<line><tbox llx="311" lly="78" urx="572" ury="90" f="2"><![CDATA[very general framework based on bipartite graphs [24], while ]]></tbox></line>
<line><tbox llx="311" lly="66" urx="572" ury="78" f="2"><![CDATA[others assume various edit distance measures. However, the ]]></tbox></line>
<pbox llx="47.00" lly="66.00" urx="573.00" ury="735.00"/></page>
<page n="3">
<line><tbox llx="48" lly="723" urx="309" ury="735" f="1"><![CDATA[proposed algorithms are not implementable in practice, as they ]]></tbox></line>
<line><tbox llx="48" lly="711" urx="309" ury="723" f="1"><![CDATA[assume that the receiver can invert a hash function over a large ]]></tbox></line>
<line><tbox llx="48" lly="699" urx="309" ury="712" f="1"><![CDATA[domain in order to decode the current version of the file; ]]></tbox></line>
<line><tbox llx="48" lly="687" urx="309" ury="700" f="1"><![CDATA[this assumption appears to be fundamental to the approach. ]]></tbox></line>
<line><tbox llx="48" lly="675" urx="309" ury="688" f="1"><![CDATA[Within this framework, Orlitsky and Viswanathan [26] also ]]></tbox></line>
<line><tbox llx="48" lly="664" urx="309" ury="676" f="1"><![CDATA[showed a relationship between Error Correcting Codes for ]]></tbox></line>
<line><tbox llx="48" lly="652" urx="309" ury="664" f="1"><![CDATA[noisy channels and file synchronization that may be on some ]]></tbox></line>
<line><tbox llx="48" lly="640" urx="237" ury="652" f="1"><![CDATA[level related to our erasure-based approach. ]]></tbox></line>
<line><tbox llx="58" lly="626" urx="162" ury="638" f="1"><![CDATA[The already mentioned ]]></tbox><tbox llx="154" lly="626" urx="186" ury="638" f="2"><![CDATA[rsync ]]></tbox><tbox llx="179" lly="626" urx="309" ury="638" f="1"><![CDATA[algorithm uses a single round ]]></tbox></line>
<line><tbox llx="48" lly="614" urx="309" ury="626" f="1"><![CDATA[of communication, consisting of a request by the machine ]]></tbox></line>
<line><tbox llx="48" lly="602" urx="309" ury="614" f="1"><![CDATA[holding the outdated copy, and the encoded reply from the ]]></tbox></line>
<line><tbox llx="48" lly="590" urx="309" ury="602" f="1"><![CDATA[machine holding the current copy. A more detailed description ]]></tbox></line>
<line><tbox llx="48" lly="578" urx="161" ury="590" f="1"><![CDATA[is given in Section II. As ]]></tbox><tbox llx="154" lly="578" urx="186" ury="590" f="2"><![CDATA[rsync ]]></tbox><tbox llx="179" lly="578" urx="309" ury="590" f="1"><![CDATA[is widely used, it clearly pro- ]]></tbox></line>
<line><tbox llx="48" lly="566" urx="309" ury="578" f="1"><![CDATA[vides a useful improvement over the alternative of transmitting ]]></tbox></line>
<line><tbox llx="48" lly="554" urx="157" ury="566" f="1"><![CDATA[the entire file. However, ]]></tbox><tbox llx="150" lly="554" urx="183" ury="566" f="2"><![CDATA[rsync ]]></tbox><tbox llx="175" lly="554" urx="309" ury="566" f="1"><![CDATA[does not guarantee any strong ]]></tbox></line>
<line><tbox llx="48" lly="542" urx="309" ury="555" f="1"><![CDATA[performance bounds with respect to common file distance ]]></tbox></line>
<line><tbox llx="48" lly="530" urx="98" ury="543" f="1"><![CDATA[measures. ]]></tbox></line>
<line><tbox llx="58" lly="517" urx="309" ury="529" f="1"><![CDATA[A number of authors have proposed multi-round algo- ]]></tbox></line>
<line><tbox llx="48" lly="505" urx="309" ury="517" f="1"><![CDATA[rithms for file synchronization based on divide-and-conquer ]]></tbox></line>
<line><tbox llx="48" lly="493" urx="309" ury="505" f="1"><![CDATA[approaches. The earliest such result in [33] in fact predates ]]></tbox></line>
<line><tbox llx="48" lly="481" urx="82" ury="493" f="2"><![CDATA[rsync, ]]></tbox><tbox llx="77" lly="481" urx="309" ury="493" f="1"><![CDATA[and subsequently a number of such algorithms have ]]></tbox></line>
<line><tbox llx="48" lly="469" urx="309" ury="481" f="1"><![CDATA[been proposed and analyzed [8], [7], [10], [25], [15], [37], ]]></tbox></line>
<line><tbox llx="48" lly="457" urx="309" ury="469" f="1"><![CDATA[[22]. The algorithms can be efficiently implemented (i.e., ]]></tbox></line>
<line><tbox llx="48" lly="445" urx="309" ury="457" f="1"><![CDATA[do not require inverting a hash function), and most can be ]]></tbox></line>
<line><tbox llx="48" lly="433" urx="309" ury="445" f="1"><![CDATA[shown to be communication-efficient with respect to one of ]]></tbox></line>
<line><tbox llx="48" lly="421" urx="309" ury="433" f="1"><![CDATA[the common file distance measures. A simple example of ]]></tbox></line>
<line><tbox llx="48" lly="409" urx="309" ury="421" f="1"><![CDATA[such an algorithm and its analysis is given in Section III. ]]></tbox></line>
<line><tbox llx="48" lly="397" urx="309" ury="409" f="1"><![CDATA[A recent study of an optimized implementation of multi- ]]></tbox></line>
<line><tbox llx="48" lly="385" urx="309" ury="398" f="1"><![CDATA[round synchronization in [37] shows that such approaches can ]]></tbox></line>
<line><tbox llx="48" lly="373" urx="283" ury="386" f="1"><![CDATA[achieve significant improvements in bandwidth use over ]]></tbox><tbox llx="275" lly="373" urx="310" ury="385" f="2"><![CDATA[rsync, ]]></tbox></line>
<line><tbox llx="48" lly="362" urx="137" ury="374" f="1"><![CDATA[often by a factor of ]]></tbox><tbox llx="128" lly="361" urx="145" ury="374" f="3"><![CDATA[2 ]]></tbox><tbox llx="137" lly="362" urx="155" ury="374" f="1"><![CDATA[to ]]></tbox><tbox llx="147" lly="361" urx="166" ury="374" f="3"><![CDATA[3. ]]></tbox><tbox llx="158" lly="362" urx="309" ury="374" f="1"><![CDATA[However, none of these algorithms ]]></tbox></line>
<line><tbox llx="48" lly="350" urx="309" ury="362" f="1"><![CDATA[appear to be currently implemented in any widely used tools. ]]></tbox></line>
<line><tbox llx="58" lly="336" urx="309" ury="348" f="1"><![CDATA[Very recent and independent work by Chauhan and Tracht- ]]></tbox></line>
<line><tbox llx="48" lly="324" urx="309" ury="336" f="1"><![CDATA[enberg [6] has proposed an approach for file synchronization ]]></tbox></line>
<line><tbox llx="48" lly="312" urx="309" ury="324" f="1"><![CDATA[based on a reduction to the set reconciliation problem. The ]]></tbox></line>
<line><tbox llx="48" lly="300" urx="309" ury="312" f="1"><![CDATA[algorithm works in two rounds and achieves provable bounds ]]></tbox></line>
<line><tbox llx="48" lly="288" urx="309" ury="300" f="1"><![CDATA[with respect to certain graph-based measures, but it is not ]]></tbox></line>
<line><tbox llx="48" lly="276" urx="309" ury="288" f="1"><![CDATA[communication-efficient according to the above definition in ]]></tbox></line>
<line><tbox llx="48" lly="264" urx="119" ury="276" f="1"><![CDATA[the worst case. ]]></tbox></line>
<line><tbox llx="58" lly="251" urx="108" ury="263" f="1"><![CDATA[Thus, the ]]></tbox><tbox llx="102" lly="251" urx="134" ury="263" f="2"><![CDATA[rsync ]]></tbox><tbox llx="128" lly="251" urx="309" ury="263" f="1"><![CDATA[algorithm appears to be the best single- ]]></tbox></line>
<line><tbox llx="48" lly="239" urx="309" ury="251" f="1"><![CDATA[round algorithm currently known, but there is significant room ]]></tbox></line>
<line><tbox llx="48" lly="227" urx="309" ury="239" f="1"><![CDATA[for improvements in its bandwidth use. Multi-round protocols ]]></tbox></line>
<line><tbox llx="48" lly="215" urx="309" ury="227" f="1"><![CDATA[are suitable when dealing with large files, or with large ]]></tbox></line>
<line><tbox llx="48" lly="203" urx="309" ury="215" f="1"><![CDATA[collections of files since the multiple communication rounds ]]></tbox></line>
<line><tbox llx="48" lly="191" urx="309" ury="203" f="1"><![CDATA[are not incurred on a per-file basis but can be overlapped for ]]></tbox></line>
<line><tbox llx="48" lly="179" urx="309" ury="191" f="1"><![CDATA[different files. However, single-round protocols are preferable ]]></tbox></line>
<line><tbox llx="48" lly="167" urx="309" ury="179" f="1"><![CDATA[in many scenarios involving small files or large latencies, for ]]></tbox></line>
<line><tbox llx="48" lly="155" urx="309" ury="167" f="1"><![CDATA[example the web access application where a single HTML ]]></tbox></line>
<line><tbox llx="48" lly="143" urx="309" ury="155" f="1"><![CDATA[page is retrieved over a high-latency modem connection. In ]]></tbox></line>
<line><tbox llx="48" lly="131" urx="309" ury="143" f="1"><![CDATA[addition, single-round protocols can be more easily integrated ]]></tbox></line>
<line><tbox llx="48" lly="119" urx="214" ury="131" f="1"><![CDATA[into existing tools currently relying on ]]></tbox><tbox llx="207" lly="119" urx="241" ury="131" f="2"><![CDATA[rsync, ]]></tbox><tbox llx="234" lly="119" urx="309" ury="131" f="1"><![CDATA[and multi-round ]]></tbox></line>
<line><tbox llx="48" lly="107" urx="309" ury="119" f="1"><![CDATA[protocols can introduce other complications due to state that ]]></tbox></line>
<line><tbox llx="48" lly="95" urx="309" ury="107" f="1"><![CDATA[may have to be kept at the server for best performance [22]. ]]></tbox></line>
<line><tbox llx="48" lly="83" urx="309" ury="96" f="1"><![CDATA[Finally, multi-round protocols tend to have higher overhead at ]]></tbox></line>
<line><tbox llx="48" lly="71" urx="309" ury="84" f="1"><![CDATA[the endpoints as they may take multiple passes over the input. ]]></tbox></line>
<line><tbox llx="311" lly="723" urx="447" ury="735" f="2"><![CDATA[D. Contributions of this Paper ]]></tbox></line>
<line><tbox llx="321" lly="702" urx="572" ury="714" f="1"><![CDATA[In this paper, we study single-round protocols for file syn- ]]></tbox></line>
<line><tbox llx="311" lly="690" urx="572" ury="702" f="1"><![CDATA[chronization. Our goal is to achieve significant improvements ]]></tbox></line>
<line><tbox llx="311" lly="678" urx="385" ury="690" f="1"><![CDATA[in practice over ]]></tbox><tbox llx="377" lly="678" urx="412" ury="690" f="2"><![CDATA[rsync, ]]></tbox><tbox llx="405" lly="678" urx="573" ury="690" f="1"><![CDATA[which is currently still the best single- ]]></tbox></line>
<line><tbox llx="311" lly="666" urx="477" ury="678" f="1"><![CDATA[round protocol. Our contributions are: ]]></tbox></line>
<line><tbox llx="317" lly="648" urx="572" ury="660" f="1"><![CDATA[(1) We explore several techniques for optimizing and tuning ]]></tbox></line>
<line><tbox llx="335" lly="636" urx="358" ury="648" f="1"><![CDATA[the ]]></tbox><tbox llx="353" lly="636" urx="385" ury="648" f="2"><![CDATA[rsync ]]></tbox><tbox llx="380" lly="636" urx="572" ury="648" f="1"><![CDATA[approach, in particular use of delta com- ]]></tbox></line>
<line><tbox llx="335" lly="624" urx="572" ury="636" f="1"><![CDATA[pression, tuning of the hash value bit strength, use ]]></tbox></line>
<line><tbox llx="335" lly="612" urx="573" ury="624" f="1"><![CDATA[of content-dependent block boundaries, and multiple ]]></tbox></line>
<line><tbox llx="335" lly="600" urx="572" ury="613" f="1"><![CDATA[alignments of block boundaries. Our study shows that ]]></tbox></line>
<line><tbox llx="335" lly="588" urx="463" ury="601" f="1"><![CDATA[some gains over the current ]]></tbox><tbox llx="457" lly="588" urx="489" ury="600" f="2"><![CDATA[rsync ]]></tbox><tbox llx="483" lly="588" urx="572" ury="601" f="1"><![CDATA[implementation are ]]></tbox></line>
<line><tbox llx="335" lly="577" urx="381" ury="589" f="1"><![CDATA[possible. ]]></tbox></line>
<line><tbox llx="317" lly="565" urx="572" ury="577" f="1"><![CDATA[(2) We describe a new approach to single-round file syn- ]]></tbox></line>
<line><tbox llx="335" lly="553" urx="573" ury="565" f="1"><![CDATA[chronization based on the use of erasure codes. Using ]]></tbox></line>
<line><tbox llx="335" lly="541" urx="573" ury="553" f="1"><![CDATA[this approach, we derive a protocol that communicates at ]]></tbox></line>
<line><tbox llx="335" lly="529" urx="365" ury="541" f="1"><![CDATA[most ]]></tbox><tbox llx="359" lly="528" urx="386" ury="539" f="4"><![CDATA[O(k ]]></tbox><tbox llx="376" lly="528" urx="447" ury="542" f="3"><![CDATA[lg(n)lg(n/k)) ]]></tbox><tbox llx="439" lly="529" urx="572" ury="541" f="1"><![CDATA[bits on files with edit distance ]]></tbox></line>
<line><tbox llx="335" lly="517" urx="460" ury="529" f="1"><![CDATA[with block moves of at most ]]></tbox><tbox llx="453" lly="516" urx="471" ury="527" f="4"><![CDATA[k. ]]></tbox><tbox llx="463" lly="517" urx="572" ury="529" f="1"><![CDATA[To our knowledge this is ]]></tbox></line>
<line><tbox llx="335" lly="505" urx="572" ury="517" f="1"><![CDATA[the first single-round protocol that is both feasible and ]]></tbox></line>
<line><tbox llx="335" lly="493" urx="446" ury="505" f="1"><![CDATA[communication-efficient. ]]></tbox></line>
<line><tbox llx="317" lly="481" urx="572" ury="493" f="1"><![CDATA[(3) Using the same approach, we derive another algorithm ]]></tbox></line>
<line><tbox llx="335" lly="469" urx="572" ury="481" f="1"><![CDATA[and an optimized implementation that achieves very ]]></tbox></line>
<line><tbox llx="335" lly="457" urx="468" ury="469" f="1"><![CDATA[promising improvements over ]]></tbox><tbox llx="462" lly="457" urx="494" ury="469" f="2"><![CDATA[rsync ]]></tbox><tbox llx="487" lly="457" urx="573" ury="469" f="1"><![CDATA[on a range of test ]]></tbox></line>
<line><tbox llx="335" lly="445" urx="572" ury="457" f="1"><![CDATA[data. The results are still preliminary and we expect ]]></tbox></line>
<line><tbox llx="335" lly="433" urx="572" ury="445" f="1"><![CDATA[additional improvements in the final version of this ]]></tbox></line>
<line><tbox llx="335" lly="421" urx="370" ury="433" f="1"><![CDATA[paper. ]]></tbox></line>
<line><tbox llx="311" lly="403" urx="573" ury="416" f="1"><![CDATA[Throughout this paper, we focus on optimizing bandwidth con- ]]></tbox></line>
<line><tbox llx="311" lly="391" urx="572" ury="404" f="1"><![CDATA[sumption. Communication latency is not an issue in our case ]]></tbox></line>
<line><tbox llx="311" lly="380" urx="572" ury="392" f="1"><![CDATA[since all algorithms operate in a single round. However, there ]]></tbox></line>
<line><tbox llx="311" lly="368" urx="572" ury="380" f="1"><![CDATA[are two other types of overhead that may also be significant in ]]></tbox></line>
<line><tbox llx="311" lly="356" urx="572" ury="368" f="1"><![CDATA[certain cases: (a) CPU cost due to hash computation and data ]]></tbox></line>
<line><tbox llx="311" lly="344" urx="572" ury="356" f="1"><![CDATA[structure insertions and lookups, and (b) the cost of scanning ]]></tbox></line>
<line><tbox llx="311" lly="332" urx="572" ury="344" f="1"><![CDATA[the file system and retrieving files. The latter cost, which can ]]></tbox></line>
<line><tbox llx="311" lly="320" urx="572" ury="332" f="1"><![CDATA[be very significant when synchronizing large directory trees ]]></tbox></line>
<line><tbox llx="311" lly="308" urx="572" ury="320" f="1"><![CDATA[with few changes, is the same for all discussed methods. (A ]]></tbox></line>
<line><tbox llx="311" lly="296" urx="572" ury="308" f="1"><![CDATA[significant reduction in this cost might be possible through ]]></tbox></line>
<line><tbox llx="311" lly="284" urx="572" ury="296" f="1"><![CDATA[maintenance of check sum hashes for files and directories to ]]></tbox></line>
<line><tbox llx="311" lly="272" urx="572" ury="284" f="1"><![CDATA[allow efficient identification of updated files, and is outside ]]></tbox></line>
<line><tbox llx="311" lly="260" urx="572" ury="272" f="1"><![CDATA[the scope of this paper.) The CPU cost is moderate for all ]]></tbox></line>
<line><tbox llx="311" lly="248" urx="572" ury="260" f="1"><![CDATA[our methods, but a detailed comparison using optimized data ]]></tbox></line>
<line><tbox llx="311" lly="236" urx="541" ury="248" f="1"><![CDATA[structures and hash computations remains to be done. ]]></tbox></line>
<line><tbox llx="321" lly="223" urx="484" ury="235" f="1"><![CDATA[In the next section, we describe the ]]></tbox><tbox llx="478" lly="223" urx="510" ury="234" f="2"><![CDATA[rsync ]]></tbox><tbox llx="504" lly="223" urx="572" ury="235" f="1"><![CDATA[algorithm and ]]></tbox></line>
<line><tbox llx="311" lly="211" urx="572" ury="223" f="1"><![CDATA[evaluate some possible optimizations. Section III proposes and ]]></tbox></line>
<line><tbox llx="311" lly="199" urx="572" ury="211" f="1"><![CDATA[evaluates our new approach to file synchronization based on ]]></tbox></line>
<line><tbox llx="311" lly="187" urx="572" ury="199" f="1"><![CDATA[erasure codes. Finally, Section IV discusses related work, and ]]></tbox></line>
<line><tbox llx="311" lly="175" urx="485" ury="187" f="1"><![CDATA[Section V contains concluding remarks. ]]></tbox></line>
<line><tbox llx="356" lly="140" urx="435" ury="152" f="1"><![CDATA[II. OPTIMIZING ]]></tbox><tbox llx="427" lly="140" urx="452" ury="150" f="5"><![CDATA[THE ]]></tbox><tbox llx="446" lly="140" urx="528" ury="152" f="6"><![CDATA[rsync APPROACH ]]></tbox></line>
<line><tbox llx="321" lly="114" urx="463" ury="126" f="8"><![CDATA[In this section, we describe the ]]></tbox><tbox llx="457" lly="114" urx="489" ury="125" f="2"><![CDATA[rsync ]]></tbox><tbox llx="483" lly="114" urx="572" ury="126" f="8"><![CDATA[algorithm and then ]]></tbox></line>
<line><tbox llx="311" lly="102" urx="572" ury="114" f="8"><![CDATA[discuss and evaluate a few ideas for tuning the performance of ]]></tbox></line>
<line><tbox llx="311" lly="90" urx="572" ury="102" f="8"><![CDATA[the approach. Our conclusion is that while moderate improve- ]]></tbox></line>
<line><tbox llx="311" lly="78" urx="573" ury="90" f="8"><![CDATA[ments are possible, more significant ones probably require a ]]></tbox></line>
<line><tbox llx="311" lly="66" urx="398" ury="78" f="8"><![CDATA[different approach. ]]></tbox></line>
<pbox llx="48.00" lly="66.00" urx="573.00" ury="735.00"/></page>
<page n="4">
<line><tbox llx="48" lly="723" urx="87" ury="735" f="1"><![CDATA[A. The ]]></tbox><tbox llx="80" lly="723" urx="112" ury="735" f="2"><![CDATA[rsync ]]></tbox><tbox llx="105" lly="723" urx="156" ury="735" f="1"><![CDATA[Algorithm ]]></tbox></line>
<line><tbox llx="58" lly="705" urx="164" ury="717" f="2"><![CDATA[The basic approach in ]]></tbox><tbox llx="158" lly="705" urx="193" ury="717" f="1"><![CDATA[rsync, ]]></tbox><tbox llx="187" lly="705" urx="309" ury="717" f="2"><![CDATA[as well as most other file ]]></tbox></line>
<line><tbox llx="48" lly="693" urx="309" ury="705" f="2"><![CDATA[synchronization algorithms, is to split a file into blocks and ]]></tbox></line>
<line><tbox llx="48" lly="681" urx="309" ury="693" f="2"><![CDATA[use hash functions to compute hashes or "fingerprints" of the ]]></tbox></line>
<line><tbox llx="48" lly="669" urx="309" ury="682" f="2"><![CDATA[blocks. These hashes are then sent to the other machine, where ]]></tbox></line>
<line><tbox llx="48" lly="657" urx="309" ury="670" f="2"><![CDATA[the recipient attempts to find matching blocks in its own file. ]]></tbox></line>
<line><tbox llx="48" lly="645" urx="309" ury="658" f="2"><![CDATA[One issue is the lack of alignment between matching blocks in ]]></tbox></line>
<line><tbox llx="48" lly="634" urx="309" ury="646" f="2"><![CDATA[the two files; this is addressed by comparing received hashes ]]></tbox></line>
<line><tbox llx="48" lly="622" urx="309" ury="634" f="2"><![CDATA[not just with the corresponding block in the other file, but ]]></tbox></line>
<line><tbox llx="48" lly="610" urx="309" ury="622" f="2"><![CDATA[with all substrings of the same size. For efficiency, hashes ]]></tbox></line>
<line><tbox llx="48" lly="598" urx="309" ury="610" f="2"><![CDATA[are composed from two different hash functions, a fast but ]]></tbox></line>
<line><tbox llx="48" lly="586" urx="309" ury="598" f="2"><![CDATA[unreliable one, and a very reliable one that is more expensive ]]></tbox></line>
<line><tbox llx="48" lly="574" urx="160" ury="586" f="2"><![CDATA[to compute. The steps in ]]></tbox><tbox llx="153" lly="574" urx="185" ury="586" f="1"><![CDATA[rsync ]]></tbox><tbox llx="178" lly="574" urx="248" ury="586" f="2"><![CDATA[are as follows: ]]></tbox></line>
<line><tbox llx="48" lly="381" urx="139" ury="391" f="3"><![CDATA[Figure II.1.Thersync ]]></tbox><tbox llx="134" lly="381" urx="308" ury="391" f="4"><![CDATA[algorithm on a small example. The client sends a ]]></tbox></line>
<line><tbox llx="48" lly="372" urx="307" ury="382" f="4"><![CDATA[set of hashes while the server replies with a stream of literals and indices ]]></tbox></line>
<line><tbox llx="48" lly="363" urx="117" ury="373" f="4"><![CDATA[identifying hashes. ]]></tbox></line>
<line><tbox llx="48" lly="338" urx="127" ury="350" f="6"><![CDATA[1. At the client: ]]></tbox></line>
<line><tbox llx="55" lly="321" urx="117" ury="334" f="7"><![CDATA[(a) Partition ]]></tbox><tbox llx="111" lly="321" urx="126" ury="332" f="8"><![CDATA[f ]]></tbox><tbox llx="116" lly="320" urx="134" ury="328" f="9"><![CDATA[old ]]></tbox><tbox llx="129" lly="321" urx="185" ury="334" f="7"><![CDATA[into blocks ]]></tbox><tbox llx="180" lly="321" urx="197" ury="332" f="8"><![CDATA[B ]]></tbox><tbox llx="188" lly="320" urx="197" ury="328" f="9"><![CDATA[i ]]></tbox><tbox llx="191" lly="321" urx="211" ury="334" f="10"><![CDATA[= ]]></tbox><tbox llx="204" lly="321" urx="219" ury="332" f="8"><![CDATA[f ]]></tbox><tbox llx="210" lly="320" urx="227" ury="328" f="9"><![CDATA[old ]]></tbox><tbox llx="218" lly="321" urx="277" ury="334" f="10"><![CDATA[[ib, (i +1)b ]]></tbox><tbox llx="270" lly="314" urx="289" ury="332" f="11"><![CDATA[- ]]></tbox><tbox llx="278" lly="321" urx="298" ury="334" f="10"><![CDATA[1] ]]></tbox><tbox llx="291" lly="321" urx="309" ury="334" f="7"><![CDATA[of ]]></tbox></line>
<line><tbox llx="72" lly="310" urx="148" ury="322" f="7"><![CDATA[some block size ]]></tbox><tbox llx="143" lly="309" urx="159" ury="320" f="8"><![CDATA[b. ]]></tbox></line>
<line><tbox llx="54" lly="297" urx="145" ury="309" f="7"><![CDATA[(b) For each block ]]></tbox><tbox llx="139" lly="297" urx="157" ury="307" f="8"><![CDATA[B ]]></tbox><tbox llx="147" lly="296" urx="157" ury="304" f="9"><![CDATA[i ]]></tbox><tbox llx="149" lly="297" urx="252" ury="309" f="7"><![CDATA[, compute two hashes, ]]></tbox><tbox llx="247" lly="297" urx="262" ury="307" f="8"><![CDATA[u ]]></tbox><tbox llx="253" lly="296" urx="263" ury="304" f="9"><![CDATA[i ]]></tbox><tbox llx="257" lly="297" urx="276" ury="310" f="10"><![CDATA[= ]]></tbox><tbox llx="271" lly="297" urx="286" ury="307" f="8"><![CDATA[h ]]></tbox><tbox llx="277" lly="296" urx="289" ury="304" f="9"><![CDATA[u ]]></tbox><tbox llx="279" lly="297" urx="302" ury="310" f="10"><![CDATA[(B ]]></tbox><tbox llx="293" lly="296" urx="303" ury="304" f="9"><![CDATA[i ]]></tbox><tbox llx="294" lly="297" urx="310" ury="310" f="10"><![CDATA[) ]]></tbox></line>
<line><tbox llx="72" lly="285" urx="97" ury="297" f="7"><![CDATA[and ]]></tbox><tbox llx="91" lly="285" urx="106" ury="296" f="8"><![CDATA[r ]]></tbox><tbox llx="96" lly="284" urx="106" ury="292" f="9"><![CDATA[i ]]></tbox><tbox llx="100" lly="285" urx="119" ury="298" f="10"><![CDATA[= ]]></tbox><tbox llx="113" lly="285" urx="129" ury="296" f="8"><![CDATA[h ]]></tbox><tbox llx="119" lly="284" urx="130" ury="292" f="9"><![CDATA[r ]]></tbox><tbox llx="121" lly="285" urx="144" ury="298" f="10"><![CDATA[(B ]]></tbox><tbox llx="135" lly="284" urx="145" ury="292" f="9"><![CDATA[i ]]></tbox><tbox llx="136" lly="285" urx="154" ury="298" f="10"><![CDATA[), ]]></tbox><tbox llx="147" lly="285" urx="309" ury="297" f="7"><![CDATA[and communicate them to the server. ]]></tbox></line>
<line><tbox llx="72" lly="273" urx="104" ury="285" f="7"><![CDATA[Here, ]]></tbox><tbox llx="99" lly="273" urx="114" ury="284" f="8"><![CDATA[h ]]></tbox><tbox llx="105" lly="272" urx="116" ury="280" f="9"><![CDATA[u ]]></tbox><tbox llx="111" lly="273" urx="286" ury="285" f="7"><![CDATA[is a heuristic but fast hash function, and ]]></tbox><tbox llx="280" lly="273" urx="296" ury="284" f="8"><![CDATA[h ]]></tbox><tbox llx="286" lly="272" urx="297" ury="280" f="9"><![CDATA[r ]]></tbox><tbox llx="292" lly="273" urx="309" ury="285" f="7"><![CDATA[is ]]></tbox></line>
<line><tbox llx="72" lly="261" urx="203" ury="273" f="7"><![CDATA[a reliable but expensive hash. ]]></tbox></line>
<line><tbox llx="48" lly="245" urx="131" ury="257" f="6"><![CDATA[2. At the server: ]]></tbox></line>
<line><tbox llx="55" lly="229" urx="214" ury="241" f="7"><![CDATA[(a) For each pair of received hashes ]]></tbox><tbox llx="205" lly="228" urx="226" ury="242" f="10"><![CDATA[(u ]]></tbox><tbox llx="217" lly="228" urx="227" ury="236" f="9"><![CDATA[i ]]></tbox><tbox llx="220" lly="228" urx="241" ury="239" f="8"><![CDATA[,r ]]></tbox><tbox llx="230" lly="228" urx="240" ury="236" f="9"><![CDATA[i ]]></tbox><tbox llx="230" lly="228" urx="248" ury="242" f="10"><![CDATA[), ]]></tbox><tbox llx="241" lly="229" urx="309" ury="241" f="7"><![CDATA[insert an entry ]]></tbox></line>
<line><tbox llx="71" lly="216" urx="92" ury="230" f="10"><![CDATA[(u ]]></tbox><tbox llx="83" lly="216" urx="93" ury="224" f="9"><![CDATA[i ]]></tbox><tbox llx="86" lly="216" urx="107" ury="227" f="8"><![CDATA[,r ]]></tbox><tbox llx="95" lly="216" urx="105" ury="224" f="9"><![CDATA[i ]]></tbox><tbox llx="99" lly="216" urx="120" ury="227" f="8"><![CDATA[,i) ]]></tbox><tbox llx="112" lly="217" urx="217" ury="229" f="7"><![CDATA[into a dictionary, using ]]></tbox><tbox llx="211" lly="216" urx="227" ury="227" f="8"><![CDATA[u ]]></tbox><tbox llx="217" lly="216" urx="227" ury="224" f="9"><![CDATA[i ]]></tbox><tbox llx="223" lly="217" urx="261" ury="229" f="7"><![CDATA[as key. ]]></tbox></line>
<line><tbox llx="54" lly="204" urx="177" ury="216" f="7"><![CDATA[(b) Perform a pass through ]]></tbox><tbox llx="171" lly="204" urx="185" ury="215" f="8"><![CDATA[f ]]></tbox><tbox llx="176" lly="203" urx="198" ury="211" f="9"><![CDATA[new ]]></tbox><tbox llx="190" lly="204" urx="281" ury="216" f="7"><![CDATA[, starting at position ]]></tbox><tbox llx="275" lly="204" urx="289" ury="215" f="8"><![CDATA[j ]]></tbox><tbox llx="280" lly="204" urx="310" ury="217" f="10"><![CDATA[=0, ]]></tbox></line>
<line><tbox llx="72" lly="192" urx="222" ury="204" f="7"><![CDATA[and involving the following steps: ]]></tbox></line>
<line><tbox llx="78" lly="178" urx="220" ury="190" f="7"><![CDATA[(i) Compute the unreliable hash ]]></tbox><tbox llx="214" lly="177" urx="229" ury="188" f="8"><![CDATA[h ]]></tbox><tbox llx="220" lly="177" urx="231" ury="184" f="9"><![CDATA[u ]]></tbox><tbox llx="222" lly="177" urx="243" ury="190" f="10"><![CDATA[(f ]]></tbox><tbox llx="234" lly="177" urx="255" ury="184" f="9"><![CDATA[new ]]></tbox><tbox llx="246" lly="177" urx="267" ury="190" f="10"><![CDATA[[j, ]]></tbox><tbox llx="260" lly="177" urx="274" ury="188" f="8"><![CDATA[j ]]></tbox><tbox llx="263" lly="177" urx="310" ury="190" f="10"><![CDATA[+b-1]) ]]></tbox></line>
<line><tbox llx="94" lly="166" urx="200" ury="178" f="7"><![CDATA[on the block starting at ]]></tbox><tbox llx="194" lly="165" urx="211" ury="176" f="8"><![CDATA[j. ]]></tbox></line>
<line><tbox llx="76" lly="153" urx="309" ury="165" f="7"><![CDATA[(ii) Check the dictionary for any block with matching ]]></tbox></line>
<line><tbox llx="94" lly="141" urx="168" ury="153" f="7"><![CDATA[unreliable hash. ]]></tbox></line>
<line><tbox llx="73" lly="128" urx="309" ury="140" f="7"><![CDATA[(iii) If found, and if the reliable hashes match, transmit ]]></tbox></line>
<line><tbox llx="94" lly="116" urx="143" ury="128" f="7"><![CDATA[the index ]]></tbox><tbox llx="138" lly="116" urx="151" ury="127" f="8"><![CDATA[i ]]></tbox><tbox llx="145" lly="116" urx="260" ury="128" f="7"><![CDATA[of the matching block in ]]></tbox><tbox llx="255" lly="116" urx="270" ury="127" f="8"><![CDATA[f ]]></tbox><tbox llx="261" lly="115" urx="278" ury="123" f="9"><![CDATA[old ]]></tbox><tbox llx="275" lly="116" urx="309" ury="128" f="7"><![CDATA[to the ]]></tbox></line>
<line><tbox llx="94" lly="104" urx="165" ury="117" f="7"><![CDATA[client, advance ]]></tbox><tbox llx="159" lly="104" urx="173" ury="115" f="8"><![CDATA[j ]]></tbox><tbox llx="166" lly="104" urx="187" ury="117" f="7"><![CDATA[by ]]></tbox><tbox llx="181" lly="104" urx="195" ury="115" f="8"><![CDATA[b ]]></tbox><tbox llx="187" lly="104" urx="294" ury="117" f="7"><![CDATA[positions, and continue. ]]></tbox></line>
<line><tbox llx="74" lly="92" urx="309" ury="104" f="7"><![CDATA[(iv) If none found, or if the reliable hash did not match, ]]></tbox></line>
<line><tbox llx="94" lly="80" urx="169" ury="92" f="7"><![CDATA[transmit symbol ]]></tbox><tbox llx="162" lly="79" urx="177" ury="90" f="8"><![CDATA[f ]]></tbox><tbox llx="168" lly="79" urx="189" ury="87" f="9"><![CDATA[new ]]></tbox><tbox llx="180" lly="79" urx="202" ury="93" f="10"><![CDATA[[j] ]]></tbox><tbox llx="194" lly="80" urx="289" ury="92" f="7"><![CDATA[to the client, advance ]]></tbox><tbox llx="283" lly="79" urx="297" ury="90" f="8"><![CDATA[j ]]></tbox><tbox llx="289" lly="80" urx="309" ury="92" f="7"><![CDATA[by ]]></tbox></line>
<line><tbox llx="94" lly="68" urx="215" ury="80" f="7"><![CDATA[one position, and continue. ]]></tbox></line>
<line><tbox llx="311" lly="723" urx="390" ury="736" f="6"><![CDATA[3. At the client: ]]></tbox></line>
<line><tbox llx="318" lly="707" urx="572" ury="719" f="7"><![CDATA[(a) Use the incoming stream of symbols and indices of ]]></tbox></line>
<line><tbox llx="335" lly="695" urx="383" ury="707" f="7"><![CDATA[hashes in ]]></tbox><tbox llx="378" lly="694" urx="392" ury="705" f="8"><![CDATA[f ]]></tbox><tbox llx="383" lly="694" urx="401" ury="702" f="9"><![CDATA[old ]]></tbox><tbox llx="396" lly="695" urx="462" ury="707" f="7"><![CDATA[to reconstruct ]]></tbox><tbox llx="456" lly="694" urx="471" ury="705" f="8"><![CDATA[f ]]></tbox><tbox llx="461" lly="694" urx="483" ury="702" f="9"><![CDATA[new ]]></tbox><tbox llx="475" lly="695" urx="488" ury="707" f="7"><![CDATA[. ]]></tbox></line>
<line><tbox llx="321" lly="678" urx="572" ury="690" f="7"><![CDATA[The process is illustrated in Figure II.1. All symbols and ]]></tbox></line>
<line><tbox llx="311" lly="666" urx="572" ury="678" f="7"><![CDATA[indices sent from server to client in steps (iii) and (iv) are also ]]></tbox></line>
<line><tbox llx="311" lly="654" urx="486" ury="666" f="7"><![CDATA[compressed using an algorithm similar to ]]></tbox><tbox llx="478" lly="654" urx="508" ury="666" f="12"><![CDATA[gzip. ]]></tbox><tbox llx="500" lly="654" urx="572" ury="666" f="7"><![CDATA[A checksum on ]]></tbox></line>
<line><tbox llx="311" lly="642" urx="573" ury="654" f="7"><![CDATA[the entire file is used to detect the (fairly unlikely) failure of ]]></tbox></line>
<line><tbox llx="311" lly="630" urx="572" ury="642" f="7"><![CDATA[both checksums, in which case the algorithm could be repeated ]]></tbox></line>
<line><tbox llx="311" lly="618" urx="572" ury="630" f="7"><![CDATA[with different hashes, or we simply transfer the entire file in ]]></tbox></line>
<line><tbox llx="311" lly="606" urx="572" ury="618" f="7"><![CDATA[compressed form. The reliable checksum is implemented using ]]></tbox></line>
<line><tbox llx="311" lly="594" urx="572" ury="606" f="7"><![CDATA[MD4 (128 bits), but only two bytes of the MD4 hash are ]]></tbox></line>
<line><tbox llx="311" lly="582" urx="573" ury="594" f="7"><![CDATA[used since this provides sufficient power for most file sizes. ]]></tbox></line>
<line><tbox llx="311" lly="570" urx="510" ury="583" f="7"><![CDATA[The unreliable checksum is implemented as a ]]></tbox><tbox llx="503" lly="570" urx="538" ury="583" f="10"><![CDATA[32-bit ]]></tbox><tbox llx="531" lly="570" urx="572" ury="583" f="7"><![CDATA["rolling ]]></tbox></line>
<line><tbox llx="311" lly="558" urx="572" ury="571" f="7"><![CDATA[checksum" that allows efficient sliding of the block boundaries ]]></tbox></line>
<line><tbox llx="311" lly="547" urx="482" ury="559" f="7"><![CDATA[by one character, i.e., the checksum for ]]></tbox><tbox llx="476" lly="546" urx="491" ury="557" f="8"><![CDATA[f ]]></tbox><tbox llx="480" lly="546" urx="534" ury="559" f="10"><![CDATA[[j +1,j+ ]]></tbox><tbox llx="526" lly="546" urx="543" ury="557" f="8"><![CDATA[b] ]]></tbox><tbox llx="535" lly="547" urx="572" ury="559" f="7"><![CDATA[can be ]]></tbox></line>
<line><tbox llx="311" lly="535" urx="452" ury="547" f="7"><![CDATA[computed in constant time from ]]></tbox><tbox llx="446" lly="534" urx="460" ury="545" f="8"><![CDATA[f ]]></tbox><tbox llx="450" lly="534" urx="471" ury="547" f="10"><![CDATA[[j, ]]></tbox><tbox llx="463" lly="534" urx="477" ury="545" f="8"><![CDATA[j ]]></tbox><tbox llx="467" lly="534" urx="487" ury="547" f="10"><![CDATA[+ ]]></tbox><tbox llx="479" lly="534" urx="493" ury="545" f="8"><![CDATA[b ]]></tbox><tbox llx="485" lly="527" urx="503" ury="545" f="11"><![CDATA[- ]]></tbox><tbox llx="493" lly="534" urx="514" ury="547" f="10"><![CDATA[1]. ]]></tbox><tbox llx="507" lly="535" urx="540" ury="547" f="7"><![CDATA[Thus, ]]></tbox><tbox llx="532" lly="534" urx="548" ury="547" f="10"><![CDATA[6 ]]></tbox><tbox llx="541" lly="535" urx="572" ury="547" f="7"><![CDATA[bytes ]]></tbox></line>
<line><tbox llx="311" lly="523" urx="513" ury="535" f="7"><![CDATA[per block are transmitted from client to server. ]]></tbox></line>
<line><tbox llx="311" lly="495" urx="390" ury="507" f="12"><![CDATA[B. Discussion of ]]></tbox><tbox llx="383" lly="495" urx="415" ury="507" f="7"><![CDATA[rsync ]]></tbox><tbox llx="408" lly="495" urx="470" ury="507" f="12"><![CDATA[Performance ]]></tbox></line>
<line><tbox llx="321" lly="475" urx="572" ury="487" f="7"><![CDATA[Clearly, the choice of block size is critical to the per- ]]></tbox></line>
<line><tbox llx="311" lly="463" urx="572" ury="475" f="7"><![CDATA[formance of the algorithm, but the best choice depends on ]]></tbox></line>
<line><tbox llx="311" lly="451" urx="572" ury="463" f="7"><![CDATA[the degree of similarity between the two files. Moreover, the ]]></tbox></line>
<line><tbox llx="311" lly="439" urx="573" ury="452" f="7"><![CDATA[location of changes in the file is also important. If a single ]]></tbox></line>
<line><tbox llx="311" lly="427" urx="483" ury="440" f="7"><![CDATA[character is changed in each block of ]]></tbox><tbox llx="479" lly="427" urx="493" ury="438" f="8"><![CDATA[f ]]></tbox><tbox llx="484" lly="426" urx="502" ury="434" f="9"><![CDATA[old ]]></tbox><tbox llx="493" lly="427" urx="572" ury="440" f="7"><![CDATA[, then no match ]]></tbox></line>
<line><tbox llx="311" lly="416" urx="461" ury="428" f="7"><![CDATA[will be found by the server and ]]></tbox><tbox llx="456" lly="416" urx="488" ury="427" f="12"><![CDATA[rsync ]]></tbox><tbox llx="482" lly="416" urx="572" ury="428" f="7"><![CDATA[will be completely ]]></tbox></line>
<line><tbox llx="311" lly="404" urx="572" ury="416" f="7"><![CDATA[ineffective; on the other hand, if all changes are clustered in ]]></tbox></line>
<line><tbox llx="311" lly="392" urx="416" ury="404" f="7"><![CDATA[a few areas of the file, ]]></tbox><tbox llx="410" lly="392" urx="442" ury="404" f="12"><![CDATA[rsync ]]></tbox><tbox llx="435" lly="392" urx="572" ury="404" f="7"><![CDATA[will do well even with a large ]]></tbox></line>
<line><tbox llx="311" lly="380" urx="572" ury="392" f="7"><![CDATA[block size. Given these observations, some basic performance ]]></tbox></line>
<line><tbox llx="311" lly="368" urx="572" ury="380" f="7"><![CDATA[bounds based on block size and number and size of file ]]></tbox></line>
<line><tbox llx="311" lly="356" urx="483" ury="368" f="7"><![CDATA[modifications can be shown. However, ]]></tbox><tbox llx="477" lly="356" urx="509" ury="368" f="12"><![CDATA[rsync ]]></tbox><tbox llx="503" lly="356" urx="572" ury="368" f="7"><![CDATA[does not have ]]></tbox></line>
<line><tbox llx="311" lly="344" urx="572" ury="356" f="7"><![CDATA[any good performance bounds with respect to common file ]]></tbox></line>
<line><tbox llx="311" lly="332" urx="397" ury="344" f="7"><![CDATA[distance measures. ]]></tbox></line>
<line><tbox llx="321" lly="318" urx="378" ury="330" f="7"><![CDATA[In practice, ]]></tbox><tbox llx="372" lly="318" urx="405" ury="330" f="12"><![CDATA[rsync ]]></tbox><tbox llx="398" lly="318" urx="527" ury="330" f="7"><![CDATA[uses a default block size of ]]></tbox><tbox llx="520" lly="318" urx="547" ury="331" f="10"><![CDATA[700 ]]></tbox><tbox llx="541" lly="318" urx="572" ury="330" f="7"><![CDATA[bytes ]]></tbox></line>
<line><tbox llx="311" lly="306" urx="520" ury="318" f="7"><![CDATA[except for very large files where a block size of ]]></tbox><tbox llx="514" lly="306" urx="533" ury="324" f="11"><![CDATA[# ]]></tbox><tbox llx="523" lly="306" urx="538" ury="317" f="8"><![CDATA[n ]]></tbox><tbox llx="531" lly="306" urx="572" ury="318" f="7"><![CDATA[is used. ]]></tbox></line>
<line><tbox llx="311" lly="294" urx="439" ury="307" f="7"><![CDATA[Decreasing the block size to ]]></tbox><tbox llx="431" lly="294" urx="458" ury="307" f="10"><![CDATA[100 ]]></tbox><tbox llx="451" lly="294" urx="572" ury="307" f="7"><![CDATA[bytes or less is usually not ]]></tbox></line>
<line><tbox llx="311" lly="282" urx="572" ury="295" f="7"><![CDATA[practical: if one out of three hashes finds a match, this means ]]></tbox></line>
<line><tbox llx="311" lly="270" urx="336" ury="283" f="7"><![CDATA[that ]]></tbox><tbox llx="329" lly="270" urx="351" ury="283" f="10"><![CDATA[18 ]]></tbox><tbox llx="345" lly="270" urx="572" ury="283" f="7"><![CDATA[bytes of hashes are transmitted for each discovered ]]></tbox></line>
<line><tbox llx="311" lly="259" urx="445" ury="271" f="7"><![CDATA[match, while simply applying ]]></tbox><tbox llx="439" lly="259" urx="466" ury="270" f="12"><![CDATA[gzip ]]></tbox><tbox llx="460" lly="259" urx="572" ury="271" f="7"><![CDATA[to the unmatched blocks ]]></tbox></line>
<line><tbox llx="311" lly="247" urx="468" ury="259" f="7"><![CDATA[might result in a reduction to about ]]></tbox><tbox llx="460" lly="246" urx="481" ury="259" f="10"><![CDATA[25 ]]></tbox><tbox llx="474" lly="247" urx="572" ury="259" f="7"><![CDATA[bytes on average. We ]]></tbox></line>
<line><tbox llx="311" lly="235" urx="572" ury="247" f="7"><![CDATA[note that it is not difficult to find settings for the block size ]]></tbox></line>
<line><tbox llx="311" lly="223" urx="485" ury="235" f="7"><![CDATA[that perform significantly better than the ]]></tbox><tbox llx="478" lly="223" urx="510" ury="235" f="12"><![CDATA[rsync ]]></tbox><tbox llx="503" lly="223" urx="572" ury="235" f="7"><![CDATA[default size on ]]></tbox></line>
<line><tbox llx="311" lly="211" urx="573" ury="223" f="7"><![CDATA[particular data sets, but this by itself cannot be claimed as an ]]></tbox></line>
<line><tbox llx="311" lly="199" urx="394" ury="211" f="7"><![CDATA[improvement over ]]></tbox><tbox llx="387" lly="199" urx="419" ury="211" f="12"><![CDATA[rsync ]]></tbox><tbox llx="411" lly="199" urx="572" ury="211" f="7"><![CDATA[unless we get gains over a significant ]]></tbox></line>
<line><tbox llx="311" lly="187" urx="346" ury="199" f="7"><![CDATA[range. ]]></tbox></line>
<line><tbox llx="321" lly="173" urx="572" ury="185" f="7"><![CDATA[Another way to improve performance without adding extra ]]></tbox></line>
<line><tbox llx="311" lly="161" urx="572" ury="173" f="7"><![CDATA[round-trips is to use fewer bits per hash. However, a version of ]]></tbox></line>
<line><tbox llx="311" lly="149" urx="572" ury="161" f="7"><![CDATA[the birthday paradox provides a limit to this approach: Given ]]></tbox></line>
<line><tbox llx="311" lly="137" urx="399" ury="150" f="7"><![CDATA[two files of length ]]></tbox><tbox llx="394" lly="137" urx="412" ury="148" f="8"><![CDATA[n, ]]></tbox><tbox llx="406" lly="137" urx="441" ury="150" f="7"><![CDATA[where ]]></tbox><tbox llx="436" lly="137" urx="461" ury="148" f="8"><![CDATA[n/b ]]></tbox><tbox llx="454" lly="137" urx="572" ury="150" f="7"><![CDATA[hash values are compared ]]></tbox></line>
<line><tbox llx="311" lly="125" urx="403" ury="138" f="7"><![CDATA[to the hashes of all ]]></tbox><tbox llx="398" lly="125" urx="414" ury="136" f="8"><![CDATA[n ]]></tbox><tbox llx="407" lly="118" urx="425" ury="136" f="11"><![CDATA[- ]]></tbox><tbox llx="417" lly="125" urx="431" ury="136" f="8"><![CDATA[b ]]></tbox><tbox llx="422" lly="125" urx="452" ury="138" f="10"><![CDATA[+1 ]]></tbox><tbox llx="442" lly="125" urx="511" ury="138" f="7"><![CDATA[blocks of size ]]></tbox><tbox llx="506" lly="125" urx="520" ury="136" f="8"><![CDATA[b ]]></tbox><tbox llx="513" lly="125" urx="572" ury="138" f="7"><![CDATA[in the other ]]></tbox></line>
<line><tbox llx="311" lly="113" urx="403" ury="126" f="7"><![CDATA[file, we need about ]]></tbox><tbox llx="397" lly="113" urx="475" ury="126" f="10"><![CDATA[lg(n)+lg(n/b) ]]></tbox><tbox llx="469" lly="113" urx="572" ury="126" f="7"><![CDATA[bits per hash in order ]]></tbox></line>
<line><tbox llx="311" lly="102" urx="573" ury="114" f="7"><![CDATA[to have an even chance of not having any false match, while ]]></tbox></line>
<line><tbox llx="311" lly="90" urx="379" ury="102" f="7"><![CDATA[approximately ]]></tbox><tbox llx="372" lly="89" urx="468" ury="102" f="10"><![CDATA[lg(n)+lg(n/b)+d ]]></tbox><tbox llx="461" lly="90" urx="573" ury="102" f="7"><![CDATA[bits are needed to get a ]]></tbox></line>
<line><tbox llx="311" lly="78" urx="404" ury="90" f="7"><![CDATA[probability less than ]]></tbox><tbox llx="396" lly="77" urx="422" ury="90" f="10"><![CDATA[1/2 ]]></tbox><tbox llx="413" lly="82" urx="425" ury="90" f="9"><![CDATA[d ]]></tbox><tbox llx="420" lly="78" urx="572" ury="90" f="7"><![CDATA[of having any false match between ]]></tbox></line>
<line><tbox llx="311" lly="66" urx="568" ury="78" f="7"><![CDATA[the files. (We state approximate bounds here for simplicity.) ]]></tbox></line>
<pbox llx="48.00" lly="66.00" urx="573.00" ury="736.00"/></page>
<page n="5">
<line><tbox llx="48" lly="723" urx="275" ury="735" f="1"><![CDATA[C. Some Basic Optimizations and their Performance ]]></tbox></line>
<line><tbox llx="58" lly="706" urx="284" ury="718" f="2"><![CDATA[We now explore a few possible optimizations of the ]]></tbox><tbox llx="277" lly="706" urx="310" ury="718" f="1"><![CDATA[rsync ]]></tbox></line>
<line><tbox llx="48" lly="694" urx="309" ury="706" f="2"><![CDATA[approach. We start with two fairly obvious ones: (1) use of a ]]></tbox></line>
<line><tbox llx="48" lly="682" urx="309" ury="694" f="2"><![CDATA[better compressor for literals, and (2) a better choice of the ]]></tbox></line>
<line><tbox llx="48" lly="670" urx="159" ury="682" f="2"><![CDATA[number of bits per hash. ]]></tbox></line>
<line><tbox llx="58" lly="656" urx="243" ury="668" f="2"><![CDATA[In the first optimization, we replace the ]]></tbox><tbox llx="238" lly="656" urx="265" ury="668" f="1"><![CDATA[gzip ]]></tbox><tbox llx="260" lly="656" urx="309" ury="668" f="2"><![CDATA[algorithm ]]></tbox></line>
<line><tbox llx="48" lly="644" urx="309" ury="656" f="2"><![CDATA[used for the transmission of the unmatched literals and the ]]></tbox></line>
<line><tbox llx="48" lly="632" urx="126" ury="644" f="2"><![CDATA[match tokens in ]]></tbox><tbox llx="120" lly="632" urx="152" ury="644" f="1"><![CDATA[rsync ]]></tbox><tbox llx="146" lly="632" urx="309" ury="644" f="2"><![CDATA[with an optimized delta compressor. ]]></tbox></line>
<line><tbox llx="48" lly="620" urx="309" ury="632" f="2"><![CDATA[A delta compressor is a tool that compresses one file called ]]></tbox></line>
<line><tbox llx="48" lly="608" urx="98" ury="620" f="1"><![CDATA[target file ]]></tbox><tbox llx="91" lly="608" urx="309" ury="620" f="2"><![CDATA[with respect to another, usually similar, file called ]]></tbox></line>
<line><tbox llx="48" lly="596" urx="114" ury="608" f="1"><![CDATA[reference file. ]]></tbox><tbox llx="107" lly="596" urx="172" ury="609" f="2"><![CDATA[The resulting ]]></tbox><tbox llx="166" lly="596" urx="196" ury="608" f="1"><![CDATA[delta ]]></tbox><tbox llx="190" lly="596" urx="309" ury="609" f="2"><![CDATA[is essentially a description ]]></tbox></line>
<line><tbox llx="48" lly="584" urx="309" ury="597" f="2"><![CDATA[of the differences between target and reference file, with the ]]></tbox></line>
<line><tbox llx="48" lly="572" urx="309" ury="585" f="2"><![CDATA[property that the target file can be reconstructed from the delta ]]></tbox></line>
<line><tbox llx="48" lly="561" urx="240" ury="573" f="2"><![CDATA[and the reference file. In our modification of ]]></tbox><tbox llx="232" lly="561" urx="267" ury="573" f="1"><![CDATA[rsync, ]]></tbox><tbox llx="259" lly="561" urx="309" ury="573" f="2"><![CDATA[the server ]]></tbox></line>
<line><tbox llx="48" lly="549" urx="309" ury="561" f="2"><![CDATA[creates a reference file from the contents of all matched blocks, ]]></tbox></line>
<line><tbox llx="48" lly="537" urx="309" ury="549" f="2"><![CDATA[then compresses the current file with respect to this reference ]]></tbox></line>
<line><tbox llx="48" lly="525" urx="309" ury="537" f="2"><![CDATA[file, and transmits the resulting delta to the client. In addition, ]]></tbox></line>
<line><tbox llx="48" lly="513" urx="309" ury="525" f="2"><![CDATA[the server sends a (possibly compressed) bit vector telling the ]]></tbox></line>
<line><tbox llx="48" lly="501" urx="309" ury="513" f="2"><![CDATA[client which of its hash values has found a match, allowing ]]></tbox></line>
<line><tbox llx="48" lly="489" urx="309" ury="501" f="2"><![CDATA[the client to create the same reference file and then decode ]]></tbox></line>
<line><tbox llx="48" lly="477" urx="121" ury="489" f="2"><![CDATA[the current file. ]]></tbox></line>
<line><tbox llx="58" lly="463" urx="309" ury="475" f="2"><![CDATA[Use of a delta compressor has two advantages: First, it ]]></tbox></line>
<line><tbox llx="48" lly="451" urx="309" ury="463" f="2"><![CDATA[exploits redundancies between unmatched and matched parts ]]></tbox></line>
<line><tbox llx="48" lly="439" urx="309" ury="452" f="2"><![CDATA[of the current file; we note that the idea of exploiting this ]]></tbox></line>
<line><tbox llx="48" lly="427" urx="309" ury="440" f="2"><![CDATA[redundancy was already discussed by Tridgell [39]. Second, ]]></tbox></line>
<line><tbox llx="48" lly="416" urx="309" ury="428" f="2"><![CDATA[an optimized delta compressor may provide a more efficient ]]></tbox></line>
<line><tbox llx="48" lly="404" urx="281" ury="416" f="2"><![CDATA[way to encode offsets and indices than the tokens in ]]></tbox><tbox llx="275" lly="404" urx="310" ury="416" f="1"><![CDATA[rsync. ]]></tbox></line>
<line><tbox llx="48" lly="392" urx="309" ury="404" f="2"><![CDATA[(This also simplifies implementation and evaluation of our ]]></tbox></line>
<line><tbox llx="48" lly="380" urx="309" ury="392" f="2"><![CDATA[various methods by allowing us to sidestep the issue of ]]></tbox></line>
<line><tbox llx="48" lly="368" urx="309" ury="380" f="2"><![CDATA[how to optimize the representation and compression of these ]]></tbox></line>
<line><tbox llx="48" lly="356" urx="146" ury="368" f="2"><![CDATA[tokens.) We used the ]]></tbox><tbox llx="139" lly="356" urx="174" ury="368" f="1"><![CDATA[zdelta ]]></tbox><tbox llx="167" lly="356" urx="309" ury="368" f="2"><![CDATA[delta compressor [38], available ]]></tbox></line>
<line><tbox llx="48" lly="344" urx="66" ury="356" f="2"><![CDATA[at ]]></tbox><tbox llx="62" lly="343" urx="232" ury="355" f="3"><![CDATA[http://cis.poly.edu/zdelta/, ]]></tbox><tbox llx="231" lly="344" urx="309" ury="356" f="2"><![CDATA[which is highly ]]></tbox></line>
<line><tbox llx="48" lly="332" urx="309" ury="344" f="2"><![CDATA[efficient and achieves particularly good compression for small ]]></tbox></line>
<line><tbox llx="48" lly="320" urx="309" ury="332" f="2"><![CDATA[to medium size files. For large files beyond a few megabytes, ]]></tbox></line>
<line><tbox llx="48" lly="308" urx="148" ury="320" f="2"><![CDATA[a compressor such as ]]></tbox><tbox llx="142" lly="308" urx="175" ury="320" f="1"><![CDATA[vcdiff ]]></tbox><tbox llx="170" lly="308" urx="309" ury="320" f="2"><![CDATA[[13], which can capture global ]]></tbox></line>
<line><tbox llx="48" lly="296" urx="249" ury="308" f="2"><![CDATA[reorderings of substrings, would be preferable. ]]></tbox></line>
<line><tbox llx="58" lly="282" urx="309" ury="295" f="2"><![CDATA[The second optimization chooses the number of bits in the ]]></tbox></line>
<line><tbox llx="48" lly="270" urx="309" ury="283" f="2"><![CDATA[hashes as a function of the file size (for the moment, assume ]]></tbox></line>
<line><tbox llx="48" lly="259" urx="309" ury="271" f="2"><![CDATA[both files are of similar size). In particular, we assume some ]]></tbox></line>
<line><tbox llx="48" lly="247" urx="270" ury="259" f="2"><![CDATA[upper bound on the probability of a collision, say ]]></tbox><tbox llx="262" lly="246" urx="289" ury="259" f="4"><![CDATA[1/2 ]]></tbox><tbox llx="280" lly="251" urx="291" ury="259" f="6"><![CDATA[d ]]></tbox><tbox llx="287" lly="247" urx="309" ury="259" f="2"><![CDATA[for ]]></tbox></line>
<line><tbox llx="48" lly="235" urx="79" ury="247" f="2"><![CDATA[some ]]></tbox><tbox llx="74" lly="234" urx="92" ury="245" f="5"><![CDATA[d, ]]></tbox><tbox llx="84" lly="235" urx="148" ury="247" f="2"><![CDATA[and then use ]]></tbox><tbox llx="140" lly="234" urx="235" ury="247" f="4"><![CDATA[lg(n)+lg(n/b)+d ]]></tbox><tbox llx="229" lly="235" urx="309" ury="247" f="2"><![CDATA[bits per hash. Of ]]></tbox></line>
<line><tbox llx="48" lly="223" urx="125" ury="235" f="2"><![CDATA[those bits, up to ]]></tbox><tbox llx="118" lly="222" urx="139" ury="235" f="4"><![CDATA[32 ]]></tbox><tbox llx="132" lly="223" urx="309" ury="235" f="2"><![CDATA[are chosen from the weak but fast hash, ]]></tbox></line>
<line><tbox llx="48" lly="211" urx="191" ury="223" f="2"><![CDATA[and the rest from the slow hash. ]]></tbox></line>
<line><tbox llx="58" lly="197" urx="166" ury="209" f="2"><![CDATA[We now compare basic ]]></tbox><tbox llx="159" lly="197" urx="192" ury="209" f="1"><![CDATA[rsync ]]></tbox><tbox llx="185" lly="197" urx="281" ury="209" f="2"><![CDATA[with a version using ]]></tbox><tbox llx="275" lly="197" urx="310" ury="209" f="1"><![CDATA[zdelta ]]></tbox></line>
<line><tbox llx="48" lly="185" urx="182" ury="197" f="2"><![CDATA[and with a version using both ]]></tbox><tbox llx="175" lly="185" urx="209" ury="197" f="1"><![CDATA[zdelta ]]></tbox><tbox llx="202" lly="185" urx="309" ury="197" f="2"><![CDATA[and shorter hash values ]]></tbox></line>
<line><tbox llx="48" lly="173" urx="70" ury="185" f="2"><![CDATA[for ]]></tbox><tbox llx="64" lly="173" urx="79" ury="184" f="5"><![CDATA[d ]]></tbox><tbox llx="70" lly="173" urx="105" ury="186" f="4"><![CDATA[=10. ]]></tbox><tbox llx="98" lly="173" urx="246" ury="185" f="2"><![CDATA[For the experiments, we used the ]]></tbox><tbox llx="239" lly="173" urx="263" ury="185" f="1"><![CDATA[gcc ]]></tbox><tbox llx="256" lly="173" urx="281" ury="185" f="2"><![CDATA[and ]]></tbox><tbox llx="274" lly="173" urx="310" ury="185" f="1"><![CDATA[emacs ]]></tbox></line>
<line><tbox llx="48" lly="161" urx="309" ury="173" f="2"><![CDATA[data sets also used in [11], [37], consisting of versions 2.7.0 ]]></tbox></line>
<line><tbox llx="48" lly="149" urx="109" ury="161" f="2"><![CDATA[and 2.7.1 of ]]></tbox><tbox llx="103" lly="149" urx="127" ury="161" f="1"><![CDATA[gcc ]]></tbox><tbox llx="121" lly="149" urx="230" ury="161" f="2"><![CDATA[and 19.28 and 19.29 of ]]></tbox><tbox llx="224" lly="149" urx="262" ury="161" f="1"><![CDATA[emacs. ]]></tbox><tbox llx="255" lly="149" urx="309" ury="161" f="2"><![CDATA[The newer ]]></tbox></line>
<line><tbox llx="48" lly="137" urx="103" ury="150" f="2"><![CDATA[versions of ]]></tbox><tbox llx="95" lly="137" urx="120" ury="149" f="1"><![CDATA[gcc ]]></tbox><tbox llx="112" lly="137" urx="137" ury="150" f="2"><![CDATA[and ]]></tbox><tbox llx="129" lly="137" urx="165" ury="149" f="1"><![CDATA[emacs ]]></tbox><tbox llx="157" lly="137" urx="207" ury="150" f="2"><![CDATA[consist of ]]></tbox><tbox llx="198" lly="137" urx="230" ury="150" f="4"><![CDATA[1002 ]]></tbox><tbox llx="222" lly="137" urx="247" ury="150" f="2"><![CDATA[and ]]></tbox><tbox llx="239" lly="137" urx="270" ury="150" f="4"><![CDATA[1286 ]]></tbox><tbox llx="262" lly="137" urx="309" ury="150" f="2"><![CDATA[files, and ]]></tbox></line>
<line><tbox llx="48" lly="125" urx="206" ury="138" f="2"><![CDATA[each collection has a size of around ]]></tbox><tbox llx="198" lly="125" urx="219" ury="138" f="4"><![CDATA[27 ]]></tbox><tbox llx="212" lly="125" urx="309" ury="138" f="2"><![CDATA[MB. In each case we ]]></tbox></line>
<line><tbox llx="48" lly="113" urx="309" ury="126" f="2"><![CDATA[measured the cost of updating all files in the older version to ]]></tbox></line>
<line><tbox llx="48" lly="102" urx="309" ury="114" f="2"><![CDATA[the newer one. Total communication cost is divided into two ]]></tbox></line>
<line><tbox llx="48" lly="90" urx="95" ury="102" f="2"><![CDATA[parts: the ]]></tbox><tbox llx="87" lly="90" urx="133" ury="102" f="1"><![CDATA[read size ]]></tbox><tbox llx="124" lly="90" urx="309" ury="102" f="2"><![CDATA[is the data sent from client to server (mostly ]]></tbox></line>
<line><tbox llx="48" lly="78" urx="134" ury="90" f="2"><![CDATA[hashes), while the ]]></tbox><tbox llx="127" lly="78" urx="177" ury="90" f="1"><![CDATA[write size ]]></tbox><tbox llx="171" lly="78" urx="309" ury="90" f="2"><![CDATA[is the data sent from server to ]]></tbox></line>
<line><tbox llx="48" lly="66" urx="159" ury="78" f="2"><![CDATA[client (mostly the delta). ]]></tbox></line>
<line><tbox llx="311" lly="564" urx="359" ury="574" f="7"><![CDATA[Figure II.2. ]]></tbox><tbox llx="358" lly="564" urx="509" ury="574" f="8"><![CDATA[Results of the first two optimizations on the ]]></tbox><tbox llx="503" lly="564" urx="523" ury="573" f="9"><![CDATA[gcc ]]></tbox><tbox llx="517" lly="564" urx="571" ury="574" f="8"><![CDATA[collection, for ]]></tbox></line>
<line><tbox llx="311" lly="555" urx="383" ury="565" f="8"><![CDATA[various block sizes. ]]></tbox></line>
<line><tbox llx="311" lly="360" urx="359" ury="371" f="7"><![CDATA[Figure II.3. ]]></tbox><tbox llx="359" lly="360" urx="512" ury="370" f="8"><![CDATA[Results of the first two optimizations on the ]]></tbox><tbox llx="506" lly="360" urx="534" ury="370" f="9"><![CDATA[emacs ]]></tbox><tbox llx="529" lly="360" urx="571" ury="370" f="8"><![CDATA[collection, ]]></tbox></line>
<line><tbox llx="311" lly="351" urx="396" ury="361" f="8"><![CDATA[for various block sizes. ]]></tbox></line>
<line><tbox llx="321" lly="318" urx="572" ury="330" f="10"><![CDATA[The results are shown in Figures II.2 and II.3. We note ]]></tbox></line>
<line><tbox llx="311" lly="306" urx="336" ury="318" f="10"><![CDATA[that ]]></tbox><tbox llx="330" lly="306" urx="354" ury="318" f="11"><![CDATA[gcc ]]></tbox><tbox llx="348" lly="306" urx="572" ury="318" f="10"><![CDATA[has a much larger degree of similarity between the ]]></tbox></line>
<line><tbox llx="311" lly="294" urx="416" ury="307" f="10"><![CDATA[different versions than ]]></tbox><tbox llx="410" lly="294" urx="448" ury="306" f="11"><![CDATA[emacs. ]]></tbox><tbox llx="443" lly="294" urx="573" ury="307" f="10"><![CDATA[As a result, there are fairly ]]></tbox></line>
<line><tbox llx="311" lly="282" urx="430" ury="295" f="10"><![CDATA[few unmatched literals in ]]></tbox><tbox llx="424" lly="282" urx="448" ury="294" f="11"><![CDATA[gcc ]]></tbox><tbox llx="443" lly="282" urx="572" ury="295" f="10"><![CDATA[even with fairly large block ]]></tbox></line>
<line><tbox llx="311" lly="270" urx="572" ury="283" f="10"><![CDATA[sizes, and it is not profitable to spend extra bits on sending ]]></tbox></line>
<line><tbox llx="311" lly="259" urx="546" ury="271" f="10"><![CDATA[hashes for a smaller block size. The best block size for ]]></tbox><tbox llx="538" lly="259" urx="563" ury="270" f="11"><![CDATA[gcc ]]></tbox><tbox llx="555" lly="259" urx="573" ury="271" f="10"><![CDATA[is ]]></tbox></line>
<line><tbox llx="311" lly="247" urx="429" ury="259" f="10"><![CDATA[close to the default size of ]]></tbox><tbox llx="421" lly="246" urx="447" ury="259" f="4"><![CDATA[700 ]]></tbox><tbox llx="440" lly="247" urx="482" ury="259" f="10"><![CDATA[bytes in ]]></tbox><tbox llx="475" lly="247" urx="576" ury="259" f="11"><![CDATA[rsync.Foremacs,the ]]></tbox></line>
<line><tbox llx="311" lly="235" urx="484" ury="247" f="10"><![CDATA[best block size is fairly small, between ]]></tbox><tbox llx="476" lly="234" urx="503" ury="247" f="4"><![CDATA[100 ]]></tbox><tbox llx="496" lly="235" urx="521" ury="247" f="10"><![CDATA[and ]]></tbox><tbox llx="513" lly="234" urx="576" ury="247" f="4"><![CDATA[200,asthis ]]></tbox></line>
<line><tbox llx="311" lly="223" urx="572" ury="235" f="10"><![CDATA[results in many additional matches that are not caught with ]]></tbox></line>
<line><tbox llx="311" lly="211" urx="573" ury="223" f="10"><![CDATA[larger block sizes. In general, the results show that there is ]]></tbox></line>
<line><tbox llx="311" lly="199" urx="572" ury="211" f="10"><![CDATA[no one optimal block size, and that the choice depends on the ]]></tbox></line>
<line><tbox llx="311" lly="187" urx="573" ury="199" f="10"><![CDATA[data. However, we see consistent improvements due to the two ]]></tbox></line>
<line><tbox llx="311" lly="175" urx="572" ury="187" f="10"><![CDATA[optimizations. We see improvements of 10% to 15% across the ]]></tbox></line>
<line><tbox llx="311" lly="163" urx="572" ury="175" f="10"><![CDATA[various block sizes, with improvements due to shorter hashes ]]></tbox></line>
<line><tbox llx="311" lly="151" urx="573" ury="163" f="10"><![CDATA[more prominent for small block sizes, since in this case the ]]></tbox></line>
<line><tbox llx="311" lly="139" urx="477" ury="151" f="10"><![CDATA[cost of the hashes is relatively higher. ]]></tbox></line>
<line><tbox llx="321" lly="125" urx="572" ury="138" f="10"><![CDATA[Next, we look at the actual rate of collisions that we ]]></tbox></line>
<line><tbox llx="311" lly="113" urx="572" ury="126" f="10"><![CDATA[encounter with the shorter hash values, and their impact on ]]></tbox></line>
<line><tbox llx="311" lly="102" urx="398" ury="114" f="10"><![CDATA[performance. As in ]]></tbox><tbox llx="390" lly="102" urx="424" ury="114" f="11"><![CDATA[rsync, ]]></tbox><tbox llx="416" lly="102" urx="494" ury="114" f="10"><![CDATA[we assume that a ]]></tbox><tbox llx="485" lly="101" urx="527" ury="114" f="4"><![CDATA[16-byte ]]></tbox><tbox llx="518" lly="102" urx="572" ury="114" f="10"><![CDATA[hash of the ]]></tbox></line>
<line><tbox llx="311" lly="90" urx="572" ury="102" f="10"><![CDATA[entire current file is transmitted to the client in order to detect ]]></tbox></line>
<line><tbox llx="311" lly="78" urx="572" ury="90" f="10"><![CDATA[any corruption due to false matches; in case of corruption ]]></tbox></line>
<line><tbox llx="311" lly="66" urx="498" ury="78" f="10"><![CDATA[the entire file is retransmitted encoded by ]]></tbox><tbox llx="492" lly="66" urx="521" ury="78" f="11"><![CDATA[gzip. ]]></tbox><tbox llx="515" lly="66" urx="572" ury="78" f="10"><![CDATA[We look at ]]></tbox></line>
<pbox llx="48.00" lly="66.00" urx="576.00" ury="739.00"/></page>
<page n="6">
<line><tbox llx="65" lly="728" urx="126" ury="739" f="1"><![CDATA[d % match ]]></tbox><tbox llx="128" lly="728" urx="166" ury="739" f="1"><![CDATA[file coll ]]></tbox><tbox llx="168" lly="728" urx="208" ury="739" f="1"><![CDATA[coll size ]]></tbox><tbox llx="211" lly="728" urx="294" ury="739" f="1"><![CDATA[gzip(coll) total ]]></tbox></line>
<line><tbox llx="65" lly="716" urx="294" ury="727" f="1"><![CDATA[5 92.15 3.00 3.79 283909 997797 ]]></tbox></line>
<line><tbox llx="65" lly="705" urx="294" ury="716" f="1"><![CDATA[6 92.15 1.40 1.66 126869 846825 ]]></tbox></line>
<line><tbox llx="65" lly="695" urx="294" ury="706" f="1"><![CDATA[7 92.15 0.40 0.17 14845 740626 ]]></tbox></line>
<line><tbox llx="65" lly="685" urx="294" ury="696" f="1"><![CDATA[8 92.15 0.30 0.11 8998 740536 ]]></tbox></line>
<line><tbox llx="65" lly="674" urx="294" ury="685" f="1"><![CDATA[9 92.15 0.10 0.01 1627 738821 ]]></tbox></line>
<line><tbox llx="63" lly="664" urx="294" ury="675" f="1"><![CDATA[10 92.15 0.00 0.00 0 742971 ]]></tbox></line>
<line><tbox llx="65" lly="652" urx="294" ury="663" f="1"><![CDATA[5 92.14 0.20 0.24 19274 734323 ]]></tbox></line>
<line><tbox llx="65" lly="641" urx="294" ury="652" f="1"><![CDATA[6 92.13 0.00 0.00 0 720828 ]]></tbox></line>
<line><tbox llx="65" lly="631" urx="294" ury="642" f="1"><![CDATA[7 92.13 0.00 0.00 0 726476 ]]></tbox></line>
<line><tbox llx="65" lly="621" urx="294" ury="632" f="1"><![CDATA[8 92.13 0.00 0.00 0 732233 ]]></tbox></line>
<line><tbox llx="65" lly="610" urx="294" ury="621" f="1"><![CDATA[9 92.13 0.00 0.00 0 737889 ]]></tbox></line>
<line><tbox llx="63" lly="600" urx="294" ury="611" f="1"><![CDATA[10 92.13 0.00 0.00 0 743666 ]]></tbox></line>
<line><tbox llx="157" lly="585" urx="199" ury="595" f="2"><![CDATA[Table II.1 ]]></tbox></line>
<line><tbox llx="52" lly="573" urx="83" ury="583" f="3"><![CDATA[TOTAL ]]></tbox><tbox llx="77" lly="574" urx="255" ury="582" f="4"><![CDATA[PERCENTAGE OF FILE SIZE COVERED BY MATCHES, ]]></tbox><tbox llx="251" lly="574" urx="302" ury="582" f="6"><![CDATA[PERCENTAGE ]]></tbox></line>
<line><tbox llx="55" lly="562" urx="228" ury="570" f="6"><![CDATA[OF CORRUPTED FILES DUE TO HASH COLLISIONS, ]]></tbox><tbox llx="224" lly="562" urx="301" ury="570" f="8"><![CDATA[SIZEOFCORRUPTED ]]></tbox></line>
<line><tbox llx="58" lly="550" urx="199" ury="558" f="8"><![CDATA[FILES AS PERCENTAGE OF COLLECTION, ]]></tbox><tbox llx="195" lly="550" urx="297" ury="558" f="10"><![CDATA[COST OF RETRANSMISSIONS ]]></tbox></line>
<line><tbox llx="57" lly="538" urx="85" ury="546" f="10"><![CDATA[USING ]]></tbox><tbox llx="80" lly="537" urx="104" ury="547" f="11"><![CDATA[gzip, ]]></tbox><tbox llx="98" lly="538" urx="269" ury="546" f="13"><![CDATA[AND TOTAL COST OF THE ALGORITHM IN BYTES, ]]></tbox><tbox llx="265" lly="538" urx="285" ury="546" f="15"><![CDATA[FOR ]]></tbox><tbox llx="280" lly="537" urx="299" ury="547" f="11"><![CDATA[gcc ]]></tbox></line>
<line><tbox llx="56" lly="526" urx="155" ury="534" f="15"><![CDATA[WITH VARIOUS CHOICES OF ]]></tbox><tbox llx="152" lly="525" urx="183" ury="534" f="16"><![CDATA[d.THE ]]></tbox><tbox llx="176" lly="526" urx="202" ury="534" f="18"><![CDATA[FIRST ]]></tbox><tbox llx="198" lly="525" urx="210" ury="534" f="19"><![CDATA[6 ]]></tbox><tbox llx="203" lly="526" urx="261" ury="534" f="18"><![CDATA[ROWS ARE FOR ]]></tbox><tbox llx="256" lly="525" urx="300" ury="535" f="20"><![CDATA["NO-SKIP" ]]></tbox></line>
<line><tbox llx="68" lly="514" urx="150" ury="522" f="25"><![CDATA[AND THE OTHERS FOR ]]></tbox><tbox llx="145" lly="513" urx="179" ury="523" f="26"><![CDATA["SKIP". ]]></tbox><tbox llx="173" lly="513" urx="196" ury="523" f="28"><![CDATA[THE ]]></tbox><tbox llx="190" lly="514" urx="245" ury="522" f="29"><![CDATA[BLOCK SIZE IS ]]></tbox><tbox llx="241" lly="513" urx="262" ury="522" f="19"><![CDATA[600 ]]></tbox><tbox llx="255" lly="514" urx="286" ury="522" f="29"><![CDATA[BYTES. ]]></tbox></line>
<line><tbox llx="48" lly="477" urx="309" ury="489" f="31"><![CDATA[two different implementations of the match discovery process ]]></tbox></line>
<line><tbox llx="48" lly="465" urx="309" ury="477" f="31"><![CDATA[at the server: "skip" is the implementation currently used in ]]></tbox></line>
<line><tbox llx="48" lly="453" urx="80" ury="465" f="32"><![CDATA[rsync ]]></tbox><tbox llx="73" lly="453" urx="309" ury="465" f="31"><![CDATA[where after each matched block we move our window ]]></tbox></line>
<line><tbox llx="48" lly="441" urx="309" ury="453" f="31"><![CDATA[to the end of the block, thus disallowing overlapping matches ]]></tbox></line>
<line><tbox llx="48" lly="429" urx="309" ury="441" f="31"><![CDATA[in the current file, while "no-skip" also looks for overlapping ]]></tbox></line>
<line><tbox llx="48" lly="417" urx="94" ury="429" f="31"><![CDATA[matches. ]]></tbox></line>
<line><tbox llx="58" lly="404" urx="309" ury="416" f="31"><![CDATA[The results are shown in Table II.1. We see that as expected ]]></tbox></line>
<line><tbox llx="48" lly="392" urx="309" ury="404" f="31"><![CDATA["skip" has significantly fewer collisions and file corruptions ]]></tbox></line>
<line><tbox llx="48" lly="380" urx="309" ury="392" f="31"><![CDATA[than "no-skip" and also fewer than predicted by our choice of ]]></tbox></line>
<line><tbox llx="49" lly="367" urx="64" ury="378" f="33"><![CDATA[k ]]></tbox><tbox llx="57" lly="368" urx="309" ury="380" f="31"><![CDATA[since it does not compare to all blocks in the current file. ]]></tbox></line>
<line><tbox llx="48" lly="356" urx="309" ury="368" f="31"><![CDATA[Thus, "skip" is the better option also in terms of bandwidth ]]></tbox></line>
<line><tbox llx="48" lly="344" urx="197" ury="356" f="31"><![CDATA[as it allows use of shorter hashes. ]]></tbox></line>
<line><tbox llx="48" lly="323" urx="156" ury="335" f="32"><![CDATA[D. Variable-Size Blocks ]]></tbox></line>
<line><tbox llx="58" lly="306" urx="309" ury="318" f="31"><![CDATA[Our next idea for improving performance is to use variable- ]]></tbox></line>
<line><tbox llx="48" lly="294" urx="309" ury="307" f="31"><![CDATA[size instead of fixed-size blocks. In particular, we evaluate the ]]></tbox></line>
<line><tbox llx="48" lly="282" urx="309" ury="295" f="31"><![CDATA[use of Karp-Rabin fingerprints [12] to determine the block ]]></tbox></line>
<line><tbox llx="48" lly="270" urx="309" ury="283" f="31"><![CDATA[boundaries, inspired by recent work [30], [34], [21], [9] that ]]></tbox></line>
<line><tbox llx="48" lly="259" urx="309" ury="271" f="31"><![CDATA[uses these techniques in other scenarios. This is done by ]]></tbox></line>
<line><tbox llx="48" lly="247" urx="220" ury="259" f="31"><![CDATA[moving a small window (e.g., of size ]]></tbox><tbox llx="213" lly="246" urx="235" ury="259" f="34"><![CDATA[20 ]]></tbox><tbox llx="229" lly="247" urx="309" ury="259" f="31"><![CDATA[bytes) over each ]]></tbox></line>
<line><tbox llx="48" lly="235" urx="309" ury="247" f="31"><![CDATA[file. For each byte position of the window, we hash the content ]]></tbox></line>
<line><tbox llx="48" lly="223" urx="309" ury="235" f="31"><![CDATA[using a simple random hash function (not identical to the block ]]></tbox></line>
<line><tbox llx="48" lly="211" urx="168" ury="223" f="31"><![CDATA[hash). If the hash value is ]]></tbox><tbox llx="160" lly="210" urx="206" ury="224" f="34"><![CDATA[0modb ]]></tbox><tbox llx="199" lly="211" urx="228" ury="223" f="31"><![CDATA[(say, ]]></tbox><tbox llx="223" lly="210" urx="237" ury="221" f="33"><![CDATA[b ]]></tbox><tbox llx="229" lly="210" urx="273" ury="224" f="34"><![CDATA[= 256), ]]></tbox><tbox llx="266" lly="211" urx="309" ury="223" f="31"><![CDATA[then we ]]></tbox></line>
<line><tbox llx="48" lly="199" urx="309" ury="211" f="31"><![CDATA[introduce a block boundary at the end of the current window. ]]></tbox></line>
<line><tbox llx="58" lly="185" urx="227" ury="197" f="31"><![CDATA[We use this technique to partition both ]]></tbox><tbox llx="222" lly="185" urx="236" ury="196" f="33"><![CDATA[f ]]></tbox><tbox llx="227" lly="184" urx="245" ury="192" f="35"><![CDATA[old ]]></tbox><tbox llx="240" lly="185" urx="265" ury="197" f="31"><![CDATA[and ]]></tbox><tbox llx="259" lly="185" urx="273" ury="196" f="33"><![CDATA[f ]]></tbox><tbox llx="264" lly="184" urx="286" ury="192" f="35"><![CDATA[new ]]></tbox><tbox llx="277" lly="185" urx="313" ury="197" f="31"><![CDATA[.The ]]></tbox></line>
<line><tbox llx="48" lly="173" urx="309" ury="185" f="31"><![CDATA[purpose of the small window is to define block boundaries in ]]></tbox></line>
<line><tbox llx="48" lly="161" urx="309" ury="173" f="31"><![CDATA[a content-dependent manner. Thus, when a substring in one ]]></tbox></line>
<line><tbox llx="48" lly="149" urx="309" ury="161" f="31"><![CDATA[file contains a block boundary, then if the same substring ]]></tbox></line>
<line><tbox llx="48" lly="137" urx="309" ury="150" f="31"><![CDATA[also appears in another file, it will also contain the same ]]></tbox></line>
<line><tbox llx="48" lly="125" urx="309" ury="138" f="31"><![CDATA[block boundary. The advantage of this technique for file ]]></tbox></line>
<line><tbox llx="48" lly="113" urx="309" ury="126" f="31"><![CDATA[synchronization is that we do not have to compare each ]]></tbox></line>
<line><tbox llx="48" lly="102" urx="100" ury="114" f="31"><![CDATA[hash from ]]></tbox><tbox llx="95" lly="101" urx="110" ury="112" f="33"><![CDATA[f ]]></tbox><tbox llx="100" lly="100" urx="118" ury="108" f="35"><![CDATA[old ]]></tbox><tbox llx="114" lly="102" urx="207" ury="114" f="31"><![CDATA[to all alignments in ]]></tbox><tbox llx="202" lly="101" urx="216" ury="112" f="33"><![CDATA[f ]]></tbox><tbox llx="207" lly="100" urx="228" ury="108" f="35"><![CDATA[new ]]></tbox><tbox llx="220" lly="102" urx="309" ury="114" f="31"><![CDATA[, but only to those ]]></tbox></line>
<line><tbox llx="48" lly="90" urx="166" ury="102" f="31"><![CDATA[corresponding to blocks in ]]></tbox><tbox llx="159" lly="89" urx="174" ury="100" f="33"><![CDATA[f ]]></tbox><tbox llx="165" lly="89" urx="186" ury="96" f="35"><![CDATA[new ]]></tbox><tbox llx="178" lly="90" urx="309" ury="102" f="31"><![CDATA[. Thus, the number of bits per ]]></tbox></line>
<line><tbox llx="48" lly="78" urx="157" ury="90" f="31"><![CDATA[hash can be reduced by ]]></tbox><tbox llx="149" lly="77" urx="181" ury="90" f="34"><![CDATA[lg(b) ]]></tbox><tbox llx="174" lly="78" urx="235" ury="90" f="31"><![CDATA[to a total of ]]></tbox><tbox llx="227" lly="77" urx="294" ury="90" f="34"><![CDATA[2lg(n/b)+d ]]></tbox><tbox llx="287" lly="78" urx="309" ury="90" f="31"><![CDATA[for ]]></tbox></line>
<line><tbox llx="48" lly="66" urx="136" ury="78" f="31"><![CDATA[expected block size ]]></tbox><tbox llx="130" lly="65" urx="146" ury="76" f="33"><![CDATA[b. ]]></tbox><tbox llx="138" lly="66" urx="170" ury="78" f="31"><![CDATA[Since ]]></tbox><tbox llx="164" lly="65" urx="178" ury="76" f="33"><![CDATA[b ]]></tbox><tbox llx="169" lly="66" urx="309" ury="78" f="31"><![CDATA[is typically a few hundred bytes, ]]></tbox></line>
<line><tbox llx="493" lly="675" urx="517" ury="685" f="36"><![CDATA[hash ]]></tbox></line>
<line><tbox llx="341" lly="711" urx="373" ury="721" f="36"><![CDATA[block 1 ]]></tbox><tbox llx="468" lly="711" urx="500" ury="721" f="36"><![CDATA[block 3 ]]></tbox></line>
<line><tbox llx="398" lly="711" urx="431" ury="721" f="36"><![CDATA[block 2 ]]></tbox></line>
<line><tbox llx="332" lly="693" urx="525" ury="704" f="37"><![CDATA[abacabcadabcbbdadacbacddaccb ... ]]></tbox></line>
<line><tbox llx="332" lly="652" urx="525" ury="663" f="37"><![CDATA[xxx1562057121245623037214652 ... ]]></tbox></line>
<line><tbox llx="311" lly="609" urx="359" ury="620" f="38"><![CDATA[Figure II.4. ]]></tbox><tbox llx="360" lly="609" urx="571" ury="619" f="39"><![CDATA[Use of Karp-Rabin fingerprints to partition a file into blocks. ]]></tbox></line>
<line><tbox llx="311" lly="600" urx="571" ury="610" f="39"><![CDATA[In this case, a window of size four bytes is moved over the file and at each ]]></tbox></line>
<line><tbox llx="311" lly="591" urx="368" ury="601" f="39"><![CDATA[position a hash ]]></tbox><tbox llx="364" lly="591" urx="383" ury="600" f="16"><![CDATA[h() ]]></tbox><tbox llx="377" lly="591" urx="571" ury="601" f="39"><![CDATA[of the window is computed. Hash values are in the range ]]></tbox></line>
<line><tbox llx="312" lly="577" urx="359" ury="591" f="40"><![CDATA[{0,...,7}, ]]></tbox><tbox llx="352" lly="582" urx="536" ury="592" f="39"><![CDATA[and a block ends whenever we have a hash value of ]]></tbox><tbox llx="532" lly="582" urx="571" ury="591" f="19"><![CDATA[0mod8. ]]></tbox></line>
<line><tbox llx="311" lly="574" urx="427" ury="583" f="39"><![CDATA[Thus, the expected block size is ]]></tbox><tbox llx="423" lly="573" urx="435" ury="582" f="19"><![CDATA[8 ]]></tbox><tbox llx="429" lly="574" urx="571" ury="583" f="39"><![CDATA[bytes unless there are repetitive patterns ]]></tbox></line>
<line><tbox llx="311" lly="565" urx="353" ury="574" f="39"><![CDATA[in the file. ]]></tbox></line>
<line><tbox llx="311" lly="530" urx="572" ury="542" f="41"><![CDATA[this can result in nontrivial reductions in the cost of sending ]]></tbox></line>
<line><tbox llx="311" lly="518" urx="366" ury="530" f="41"><![CDATA[the hashes. ]]></tbox></line>
<line><tbox llx="321" lly="505" urx="573" ury="517" f="41"><![CDATA[We experimented with two implementations. In one, we ]]></tbox></line>
<line><tbox llx="311" lly="493" urx="572" ury="505" f="41"><![CDATA[defined block boundaries as above, by introducing a block ]]></tbox></line>
<line><tbox llx="311" lly="481" urx="572" ury="493" f="41"><![CDATA[boundary at the end of the current window if the window ]]></tbox></line>
<line><tbox llx="311" lly="469" urx="361" ury="481" f="41"><![CDATA[hashes to ]]></tbox><tbox llx="355" lly="468" urx="403" ury="482" f="34"><![CDATA[0modb. ]]></tbox><tbox llx="397" lly="469" urx="572" ury="481" f="41"><![CDATA[In the second implementation, we use ]]></tbox></line>
<line><tbox llx="311" lly="457" urx="573" ury="469" f="41"><![CDATA[overlapping blocks by including both the boundary window to ]]></tbox></line>
<line><tbox llx="311" lly="445" urx="572" ury="457" f="41"><![CDATA[the right and to the left in each block. We also experimented ]]></tbox></line>
<line><tbox llx="311" lly="433" urx="572" ury="445" f="41"><![CDATA[with an alternative partitioning rule proposed in [32] that ]]></tbox></line>
<line><tbox llx="311" lly="421" urx="572" ury="433" f="41"><![CDATA[guarantees a lower variation in block sizes, but this did not ]]></tbox></line>
<line><tbox llx="311" lly="409" urx="435" ury="421" f="41"><![CDATA[result in any improvements. ]]></tbox></line>
<line><tbox llx="311" lly="384" urx="481" ury="396" f="32"><![CDATA[E. Matches with Half-Block Alignment ]]></tbox></line>
<line><tbox llx="321" lly="366" urx="572" ury="378" f="41"><![CDATA[We studied one other optimization that goes a little beyond ]]></tbox></line>
<line><tbox llx="311" lly="354" urx="370" ury="366" f="41"><![CDATA[the standard ]]></tbox><tbox llx="362" lly="354" urx="394" ury="366" f="32"><![CDATA[rsync ]]></tbox><tbox llx="386" lly="354" urx="572" ury="366" f="41"><![CDATA[framework. The goal is to try to address two ]]></tbox></line>
<line><tbox llx="311" lly="342" urx="425" ury="354" f="41"><![CDATA[common shortcomings in ]]></tbox><tbox llx="418" lly="342" urx="453" ury="354" f="32"><![CDATA[rsync: ]]></tbox><tbox llx="446" lly="342" urx="572" ury="354" f="41"><![CDATA[(1) Suppose we have hashes ]]></tbox></line>
<line><tbox llx="311" lly="330" urx="572" ury="342" f="41"><![CDATA[for two consecutive blocks that do not find a match at the ]]></tbox></line>
<line><tbox llx="311" lly="318" urx="572" ury="330" f="41"><![CDATA[server, but if we had a hash for a block of the same size that ]]></tbox></line>
<line><tbox llx="311" lly="306" urx="572" ury="318" f="41"><![CDATA[goes from the middle of the first block to the middle of the ]]></tbox></line>
<line><tbox llx="311" lly="294" urx="572" ury="307" f="41"><![CDATA[second block, it might be possible to find a match. In general, ]]></tbox></line>
<line><tbox llx="311" lly="282" urx="572" ury="295" f="41"><![CDATA[we would like to be able to find matches of large enough size ]]></tbox></line>
<line><tbox llx="311" lly="270" urx="572" ury="283" f="41"><![CDATA[that go across the block boundaries, at least for a selected set ]]></tbox></line>
<line><tbox llx="311" lly="259" urx="572" ury="271" f="41"><![CDATA[of alignments. (2) Having identified a match of one block, we ]]></tbox></line>
<line><tbox llx="311" lly="247" urx="572" ury="259" f="41"><![CDATA[should be able to efficiently extend such a match, say, into one ]]></tbox></line>
<line><tbox llx="311" lly="235" urx="572" ury="247" f="41"><![CDATA[half of the neighboring block, even if the whole neighboring ]]></tbox></line>
<line><tbox llx="311" lly="223" urx="572" ury="235" f="41"><![CDATA[block does not find a match. This is basically the idea behind ]]></tbox></line>
<line><tbox llx="311" lly="211" urx="334" ury="223" f="41"><![CDATA[the ]]></tbox><tbox llx="327" lly="211" urx="419" ury="223" f="32"><![CDATA[continuation hashes ]]></tbox><tbox llx="412" lly="211" urx="572" ury="223" f="41"><![CDATA[proposed in [37], that far fewer bits ]]></tbox></line>
<line><tbox llx="311" lly="199" urx="572" ury="211" f="41"><![CDATA[are needed if a hash is only compared to one block position ]]></tbox></line>
<line><tbox llx="311" lly="187" urx="572" ury="199" f="41"><![CDATA[in the other file, in this case the position adjacent to a known ]]></tbox></line>
<line><tbox llx="311" lly="175" urx="348" ury="187" f="41"><![CDATA[match. ]]></tbox></line>
<line><tbox llx="321" lly="161" urx="572" ury="173" f="41"><![CDATA[However, implementing these ideas in a single round is ]]></tbox></line>
<line><tbox llx="311" lly="149" urx="572" ury="161" f="41"><![CDATA[tricky, and we can not get everything we want. We take the ]]></tbox></line>
<line><tbox llx="311" lly="137" urx="572" ury="150" f="41"><![CDATA[following approach: We partition the client file into blocks of ]]></tbox></line>
<line><tbox llx="311" lly="125" urx="387" ury="138" f="41"><![CDATA[fairly small size ]]></tbox><tbox llx="381" lly="125" urx="395" ury="136" f="33"><![CDATA[b ]]></tbox><tbox llx="385" lly="125" urx="395" ury="138" f="42"><![CDATA[# ]]></tbox><tbox llx="390" lly="125" urx="472" ury="138" f="41"><![CDATA[(say, half the size ]]></tbox><tbox llx="466" lly="125" urx="480" ury="136" f="33"><![CDATA[b ]]></tbox><tbox llx="472" lly="125" urx="572" ury="138" f="41"><![CDATA[that we would usually ]]></tbox></line>
<line><tbox llx="311" lly="113" urx="369" ury="126" f="41"><![CDATA[select under ]]></tbox><tbox llx="361" lly="114" urx="399" ury="125" f="32"><![CDATA[rsync), ]]></tbox><tbox llx="390" lly="113" urx="572" ury="126" f="41"><![CDATA[but send far fewer bits per hash (only about ]]></tbox></line>
<line><tbox llx="311" lly="102" urx="572" ury="114" f="41"><![CDATA[half as many). At the server, we look for matches in the other ]]></tbox></line>
<line><tbox llx="311" lly="90" urx="572" ury="102" f="41"><![CDATA[file, but we only accept matches that are part of a sequence of ]]></tbox></line>
<line><tbox llx="311" lly="78" urx="350" ury="90" f="41"><![CDATA[at least ]]></tbox><tbox llx="342" lly="77" urx="359" ury="90" f="34"><![CDATA[2 ]]></tbox><tbox llx="351" lly="78" urx="572" ury="90" f="41"><![CDATA[consecutive matches. The reason is that the number ]]></tbox></line>
<line><tbox llx="311" lly="66" urx="573" ury="78" f="41"><![CDATA[of hash bits per single block is not large enough to identify ]]></tbox></line>
<pbox llx="48.00" lly="65.00" urx="573.00" ury="739.00"/></page>
<page n="7">
<line><tbox llx="48" lly="723" urx="309" ury="735" f="1"><![CDATA[isolated matches with confidence. To get a probability of less ]]></tbox></line>
<line><tbox llx="48" lly="711" urx="76" ury="723" f="1"><![CDATA[than ]]></tbox><tbox llx="68" lly="711" urx="94" ury="724" f="2"><![CDATA[1/2 ]]></tbox><tbox llx="85" lly="715" urx="96" ury="723" f="4"><![CDATA[d ]]></tbox><tbox llx="91" lly="711" urx="309" ury="723" f="1"><![CDATA[of a false match in the file, we need to satisfy two ]]></tbox></line>
<line><tbox llx="48" lly="699" urx="214" ury="712" f="1"><![CDATA[conditions on the number of hash bits ]]></tbox><tbox llx="209" lly="699" urx="224" ury="710" f="3"><![CDATA[h ]]></tbox><tbox llx="216" lly="699" urx="268" ury="712" f="1"><![CDATA[per block: ]]></tbox></line>
<line><tbox llx="68" lly="681" urx="91" ury="694" f="2"><![CDATA[2h ]]></tbox><tbox llx="84" lly="674" urx="102" ury="692" f="5"><![CDATA[# ]]></tbox><tbox llx="92" lly="681" urx="186" ury="694" f="2"><![CDATA[lg(n)+lg(n/b)+d ]]></tbox><tbox llx="184" lly="681" urx="209" ury="693" f="1"><![CDATA[and ]]></tbox><tbox llx="209" lly="681" urx="224" ury="692" f="3"><![CDATA[h ]]></tbox><tbox llx="217" lly="674" urx="236" ury="692" f="5"><![CDATA[# ]]></tbox><tbox llx="226" lly="681" urx="288" ury="694" f="2"><![CDATA[lg(n/b)+d. ]]></tbox></line>
<line><tbox llx="48" lly="663" urx="309" ury="675" f="1"><![CDATA[The first condition assures that two consecutive block matches ]]></tbox></line>
<line><tbox llx="48" lly="651" urx="309" ury="663" f="1"><![CDATA[suffice to identify a valid match, while the second condition ]]></tbox></line>
<line><tbox llx="48" lly="639" urx="309" ury="651" f="1"><![CDATA[assures that we can extend a match by single blocks to the left ]]></tbox></line>
<line><tbox llx="48" lly="627" urx="309" ury="640" f="1"><![CDATA[and right without too much danger of a false match. We note ]]></tbox></line>
<line><tbox llx="48" lly="615" urx="309" ury="628" f="1"><![CDATA[that instead of choosing blocks of half the usual size, other ]]></tbox></line>
<line><tbox llx="48" lly="603" urx="309" ury="616" f="1"><![CDATA[settings are possible to recognize various other alignments not ]]></tbox></line>
<line><tbox llx="48" lly="592" urx="110" ury="604" f="1"><![CDATA[exploited by ]]></tbox><tbox llx="104" lly="592" urx="139" ury="604" f="6"><![CDATA[rsync, ]]></tbox><tbox llx="133" lly="592" urx="309" ury="604" f="1"><![CDATA[but we did not find significant benefits ]]></tbox></line>
<line><tbox llx="48" lly="580" urx="266" ury="592" f="1"><![CDATA[in this. The above algorithm, which we refer to as ]]></tbox><tbox llx="259" lly="580" urx="310" ury="592" f="6"><![CDATA[half-block ]]></tbox></line>
<line><tbox llx="48" lly="568" urx="101" ury="580" f="6"><![CDATA[alignment, ]]></tbox><tbox llx="94" lly="568" urx="309" ury="580" f="1"><![CDATA[is basically a fairly crude way to exploit the fact ]]></tbox></line>
<line><tbox llx="48" lly="556" urx="309" ury="568" f="1"><![CDATA[that matches in files are clustered and that adjacent blocks in ]]></tbox></line>
<line><tbox llx="48" lly="544" urx="309" ury="556" f="1"><![CDATA[one file are more likely to match with adjacent blocks in the ]]></tbox></line>
<line><tbox llx="48" lly="532" urx="309" ury="544" f="1"><![CDATA[other file than with blocks that are far away from each other. ]]></tbox></line>
<line><tbox llx="48" lly="520" urx="197" ury="532" f="1"><![CDATA[We implemented this method for ]]></tbox><tbox llx="192" lly="519" urx="207" ury="530" f="3"><![CDATA[d ]]></tbox><tbox llx="200" lly="519" urx="252" ury="533" f="2"><![CDATA[=10and ]]></tbox><tbox llx="246" lly="520" urx="309" ury="532" f="1"><![CDATA[also checked ]]></tbox></line>
<line><tbox llx="48" lly="508" urx="265" ury="520" f="1"><![CDATA[that the frequency of false matches is as expected. ]]></tbox></line>
<line><tbox llx="48" lly="488" urx="228" ury="500" f="6"><![CDATA[F. Performance of the Two Optimizations ]]></tbox></line>
<line><tbox llx="58" lly="472" urx="288" ury="484" f="1"><![CDATA[In Figure II.5 and II.6, we compare the performance of ]]></tbox><tbox llx="280" lly="472" urx="310" ury="484" f="6"><![CDATA[half- ]]></tbox></line>
<line><tbox llx="48" lly="460" urx="122" ury="472" f="6"><![CDATA[block alignment ]]></tbox><tbox llx="114" lly="460" urx="309" ury="472" f="1"><![CDATA[and of the approach using variable size blocks ]]></tbox></line>
<line><tbox llx="48" lly="448" urx="87" ury="460" f="1"><![CDATA[against ]]></tbox><tbox llx="81" lly="448" urx="113" ury="460" f="6"><![CDATA[rsync ]]></tbox><tbox llx="107" lly="448" urx="309" ury="460" f="1"><![CDATA[and the optimized version from the previous ]]></tbox></line>
<line><tbox llx="48" lly="436" urx="309" ury="448" f="1"><![CDATA[subsection, on a range of block sizes. For the methods with ]]></tbox></line>
<line><tbox llx="48" lly="424" urx="309" ury="436" f="1"><![CDATA[variable block size, we show the expected block size and ]]></tbox></line>
<line><tbox llx="48" lly="412" urx="70" ury="424" f="1"><![CDATA[for ]]></tbox><tbox llx="64" lly="412" urx="160" ury="424" f="6"><![CDATA[half-block alignment ]]></tbox><tbox llx="155" lly="412" urx="267" ury="424" f="1"><![CDATA[we show twice the size ]]></tbox><tbox llx="263" lly="412" urx="277" ury="422" f="3"><![CDATA[b ]]></tbox><tbox llx="267" lly="411" urx="277" ury="424" f="7"><![CDATA[# ]]></tbox><tbox llx="273" lly="412" urx="309" ury="424" f="1"><![CDATA[of the ]]></tbox></line>
<line><tbox llx="48" lly="400" urx="309" ury="412" f="1"><![CDATA[small blocks in the figure (since the small blocks are half ]]></tbox></line>
<line><tbox llx="48" lly="388" urx="130" ury="400" f="1"><![CDATA[the "normal" size ]]></tbox><tbox llx="124" lly="388" urx="138" ury="399" f="3"><![CDATA[b ]]></tbox><tbox llx="131" lly="388" urx="279" ury="400" f="1"><![CDATA[to capture half-block alignments). ]]></tbox></line>
<line><tbox llx="48" lly="202" urx="96" ury="213" f="8"><![CDATA[Figure II.5. ]]></tbox><tbox llx="96" lly="202" urx="158" ury="212" f="9"><![CDATA[Results for basic ]]></tbox><tbox llx="153" lly="202" urx="180" ury="212" f="10"><![CDATA[rsync, ]]></tbox><tbox llx="175" lly="202" urx="227" ury="212" f="9"><![CDATA[the optimized ]]></tbox><tbox llx="222" lly="202" urx="247" ury="212" f="10"><![CDATA[rsync ]]></tbox><tbox llx="241" lly="202" urx="308" ury="212" f="9"><![CDATA[from the previous ]]></tbox></line>
<line><tbox llx="48" lly="193" urx="307" ury="203" f="9"><![CDATA[subsection, the variable block size approach without and with overlap, and the ]]></tbox></line>
<line><tbox llx="48" lly="185" urx="123" ury="194" f="10"><![CDATA[half-block alignment ]]></tbox><tbox llx="117" lly="185" urx="175" ury="194" f="9"><![CDATA[protocol on the ]]></tbox><tbox llx="169" lly="185" urx="188" ury="194" f="10"><![CDATA[gcc ]]></tbox><tbox llx="182" lly="185" urx="299" ury="194" f="9"><![CDATA[collection, for various block sizes ]]></tbox><tbox llx="295" lly="184" urx="308" ury="193" f="11"><![CDATA[b. ]]></tbox></line>
<line><tbox llx="58" lly="161" urx="309" ury="173" f="12"><![CDATA[We observe that the variable block-size methods do very ]]></tbox></line>
<line><tbox llx="48" lly="149" urx="309" ury="161" f="12"><![CDATA[well for small blocks. The reason is that these methods use ]]></tbox></line>
<line><tbox llx="48" lly="137" urx="309" ury="150" f="12"><![CDATA[shorter hashes, and thus benefit when the size of the hashes ]]></tbox></line>
<line><tbox llx="48" lly="125" urx="309" ury="138" f="12"><![CDATA[is significant compared to the total cost. On the other hand, ]]></tbox></line>
<line><tbox llx="48" lly="113" urx="309" ury="126" f="12"><![CDATA[methods with variable blocks tend to result in more unmatched ]]></tbox></line>
<line><tbox llx="48" lly="102" urx="309" ury="114" f="12"><![CDATA[literals, mainly due to variations in the block sizes, that ]]></tbox></line>
<line><tbox llx="48" lly="90" urx="309" ury="102" f="12"><![CDATA[dominate the savings in hash bits for larger block sizes. As ]]></tbox></line>
<line><tbox llx="48" lly="78" urx="309" ury="90" f="12"><![CDATA[suggested in [21], [30], we enforce certain minimum and ]]></tbox></line>
<line><tbox llx="48" lly="66" urx="309" ury="78" f="12"><![CDATA[maximum block sizes to deal with regular patterns in the data, ]]></tbox></line>
<line><tbox llx="311" lly="557" urx="359" ury="567" f="8"><![CDATA[Figure II.6. ]]></tbox><tbox llx="359" lly="557" urx="421" ury="567" f="13"><![CDATA[Results for basic ]]></tbox><tbox llx="416" lly="557" urx="443" ury="567" f="10"><![CDATA[rsync, ]]></tbox><tbox llx="438" lly="557" urx="490" ury="567" f="13"><![CDATA[the optimized ]]></tbox><tbox llx="485" lly="557" urx="510" ury="567" f="10"><![CDATA[rsync ]]></tbox><tbox llx="504" lly="557" urx="571" ury="567" f="13"><![CDATA[from the previous ]]></tbox></line>
<line><tbox llx="311" lly="548" urx="571" ury="558" f="13"><![CDATA[subsection, the variable block size approach without and with overlap, and ]]></tbox></line>
<line><tbox llx="311" lly="539" urx="329" ury="549" f="13"><![CDATA[the ]]></tbox><tbox llx="324" lly="539" urx="399" ury="549" f="10"><![CDATA[half-block alignment ]]></tbox><tbox llx="394" lly="539" urx="452" ury="549" f="13"><![CDATA[protocol on the ]]></tbox><tbox llx="447" lly="539" urx="475" ury="549" f="10"><![CDATA[emacs ]]></tbox><tbox llx="470" lly="539" urx="571" ury="549" f="13"><![CDATA[collection, for various block ]]></tbox></line>
<line><tbox llx="311" lly="530" urx="335" ury="540" f="13"><![CDATA[sizes ]]></tbox><tbox llx="331" lly="530" urx="344" ury="539" f="11"><![CDATA[b. ]]></tbox></line>
<line><tbox llx="311" lly="496" urx="572" ury="508" f="14"><![CDATA[but even with optimum choice of these parameters the block ]]></tbox></line>
<line><tbox llx="311" lly="484" urx="572" ury="496" f="14"><![CDATA[sizes are distributed over a certain range, and large blocks ]]></tbox></line>
<line><tbox llx="311" lly="472" urx="572" ury="484" f="14"><![CDATA[are more likely to not find a match. Moreover, we note that ]]></tbox></line>
<line><tbox llx="311" lly="460" urx="572" ury="472" f="14"><![CDATA[the savings in bits per hash for variable-size blocks are only ]]></tbox></line>
<line><tbox llx="311" lly="448" urx="572" ury="460" f="14"><![CDATA[compared to the "no-skip" version of the fixed-size method, ]]></tbox></line>
<line><tbox llx="311" lly="436" urx="573" ury="448" f="14"><![CDATA[and as seen in Table II.1 we could actually use fewer bits per ]]></tbox></line>
<line><tbox llx="311" lly="424" urx="572" ury="436" f="14"><![CDATA[hash when using the "skip" method. We observe that there is ]]></tbox></line>
<line><tbox llx="311" lly="412" urx="572" ury="424" f="14"><![CDATA[at most a very slight benefit in using overlapping instead of ]]></tbox></line>
<line><tbox llx="311" lly="400" urx="419" ury="412" f="14"><![CDATA[non-overlapping blocks. ]]></tbox></line>
<line><tbox llx="321" lly="386" urx="347" ury="399" f="14"><![CDATA[The ]]></tbox><tbox llx="341" lly="387" urx="436" ury="398" f="15"><![CDATA[half-block alignment ]]></tbox><tbox llx="430" lly="386" urx="572" ury="399" f="14"><![CDATA[approach outperforms the other ]]></tbox></line>
<line><tbox llx="311" lly="375" urx="572" ury="387" f="14"><![CDATA[methods on most block sizes, with the notable exception of ]]></tbox></line>
<line><tbox llx="311" lly="363" urx="335" ury="375" f="15"><![CDATA[gcc ]]></tbox><tbox llx="330" lly="363" urx="399" ury="375" f="14"><![CDATA[for block size ]]></tbox><tbox llx="393" lly="362" urx="419" ury="375" f="2"><![CDATA[100 ]]></tbox><tbox llx="413" lly="363" urx="572" ury="375" f="14"><![CDATA[where the second condition on the ]]></tbox></line>
<line><tbox llx="311" lly="351" urx="572" ury="363" f="14"><![CDATA[number of hash bits stated above results in a fairly high cost ]]></tbox></line>
<line><tbox llx="311" lly="339" urx="572" ury="351" f="14"><![CDATA[for the hashes. Note that this block size is not a good choice ]]></tbox></line>
<line><tbox llx="311" lly="327" urx="333" ury="339" f="14"><![CDATA[for ]]></tbox><tbox llx="326" lly="327" urx="351" ury="339" f="15"><![CDATA[gcc ]]></tbox><tbox llx="344" lly="327" urx="572" ury="339" f="14"><![CDATA[under any method, and is far away from the default ]]></tbox></line>
<line><tbox llx="311" lly="315" urx="349" ury="327" f="14"><![CDATA[size of ]]></tbox><tbox llx="341" lly="314" urx="368" ury="328" f="2"><![CDATA[700 ]]></tbox><tbox llx="361" lly="315" urx="383" ury="327" f="14"><![CDATA[for ]]></tbox><tbox llx="376" lly="315" urx="408" ury="327" f="15"><![CDATA[rsync ]]></tbox><tbox llx="401" lly="315" urx="541" ury="327" f="14"><![CDATA[or any suitable default size. On ]]></tbox><tbox llx="534" lly="315" urx="573" ury="327" f="15"><![CDATA[emacs, ]]></tbox></line>
<line><tbox llx="311" lly="303" urx="572" ury="315" f="14"><![CDATA[we see an improvement of 5% to 10% over the next best ]]></tbox></line>
<line><tbox llx="311" lly="291" urx="572" ury="303" f="14"><![CDATA[method, and overall we see an improvement of 15% to 25% ]]></tbox></line>
<line><tbox llx="311" lly="279" urx="378" ury="291" f="14"><![CDATA[over the basic ]]></tbox><tbox llx="371" lly="279" urx="403" ury="291" f="15"><![CDATA[rsync ]]></tbox><tbox llx="396" lly="279" urx="572" ury="291" f="14"><![CDATA[method across the different blocks sizes, ]]></tbox></line>
<line><tbox llx="311" lly="267" urx="572" ury="279" f="14"><![CDATA[including the default size. Similar results were also obtained ]]></tbox></line>
<line><tbox llx="311" lly="255" urx="572" ury="267" f="14"><![CDATA[on several other data sets. Thus, some moderate improvements ]]></tbox></line>
<line><tbox llx="311" lly="243" urx="492" ury="255" f="14"><![CDATA[are possible through careful tuning of the ]]></tbox><tbox llx="485" lly="243" urx="517" ury="255" f="15"><![CDATA[rsync ]]></tbox><tbox llx="510" lly="243" urx="559" ury="255" f="14"><![CDATA[approach. ]]></tbox></line>
<line><tbox llx="334" lly="218" urx="377" ury="230" f="14"><![CDATA[III. AN ]]></tbox><tbox llx="370" lly="218" urx="427" ury="230" f="17"><![CDATA[APPROACH ]]></tbox><tbox llx="419" lly="218" urx="459" ury="230" f="19"><![CDATA[BASED ]]></tbox><tbox llx="451" lly="219" urx="472" ury="229" f="20"><![CDATA[ON ]]></tbox><tbox llx="466" lly="218" urx="518" ury="230" f="21"><![CDATA[ERASURE ]]></tbox><tbox llx="510" lly="218" urx="550" ury="230" f="23"><![CDATA[CODES ]]></tbox></line>
<line><tbox llx="321" lly="199" urx="572" ury="211" f="25"><![CDATA[In this section, we provide the main result of this paper, a ]]></tbox></line>
<line><tbox llx="311" lly="187" urx="572" ury="199" f="25"><![CDATA[new approach to single-round file synchronization based on ]]></tbox></line>
<line><tbox llx="311" lly="175" urx="572" ury="187" f="25"><![CDATA[the use of erasure code. Using this approach, we design two ]]></tbox></line>
<line><tbox llx="311" lly="163" urx="572" ury="175" f="25"><![CDATA[algorithms, one primarily of theoretical interest and another ]]></tbox></line>
<line><tbox llx="311" lly="151" urx="572" ury="163" f="25"><![CDATA[one that performs well in practice. The basic idea underlying ]]></tbox></line>
<line><tbox llx="311" lly="139" urx="572" ury="151" f="25"><![CDATA[the new approach is quite simple: essentially, erasure codes are ]]></tbox></line>
<line><tbox llx="311" lly="127" urx="572" ury="139" f="25"><![CDATA[used to convert certain multi-round protocols into single-round ]]></tbox></line>
<line><tbox llx="311" lly="115" urx="498" ury="127" f="25"><![CDATA[protocols with similar communication cost. ]]></tbox></line>
<line><tbox llx="321" lly="102" urx="572" ury="114" f="25"><![CDATA[We start by describing a simple multi-round protocol. ]]></tbox></line>
<line><tbox llx="311" lly="90" urx="573" ury="102" f="25"><![CDATA[Subsection III-B contains the theoretical result obtained by ]]></tbox></line>
<line><tbox llx="311" lly="78" urx="573" ury="90" f="25"><![CDATA[converting the multi-round protocol, and Subsection III-C ]]></tbox></line>
<line><tbox llx="311" lly="66" urx="509" ury="78" f="25"><![CDATA[describes and evaluates the practical protocol. ]]></tbox></line>
<pbox llx="48.00" lly="66.00" urx="573.00" ury="735.00"/></page>
<page n="8">
<line><tbox llx="48" lly="723" urx="201" ury="735" f="1"><![CDATA[A. A Simple Multi-Round Protocol ]]></tbox></line>
<line><tbox llx="58" lly="707" urx="309" ury="719" f="2"><![CDATA[We now describe a simple multi-round protocol for file ]]></tbox></line>
<line><tbox llx="48" lly="695" urx="233" ury="707" f="2"><![CDATA[synchronization, which we refer to as the ]]></tbox><tbox llx="226" lly="695" urx="310" ury="707" f="1"><![CDATA[basic multi-round ]]></tbox></line>
<line><tbox llx="48" lly="683" urx="94" ury="695" f="1"><![CDATA[protocol. ]]></tbox><tbox llx="88" lly="683" urx="309" ury="695" f="2"><![CDATA[The protocol is not new and variations of it have ]]></tbox></line>
<line><tbox llx="48" lly="671" urx="309" ury="683" f="2"><![CDATA[previously appeared in [33], [8], [25], [37]. (The multi-round ]]></tbox></line>
<line><tbox llx="48" lly="659" urx="309" ury="671" f="2"><![CDATA[protocols in [15], [22] are also similar, but send hashes from ]]></tbox></line>
<line><tbox llx="48" lly="647" urx="125" ury="659" f="2"><![CDATA[client to server.) ]]></tbox></line>
<line><tbox llx="58" lly="633" urx="309" ury="645" f="2"><![CDATA[The protocol runs in a number of rounds, starting with a ]]></tbox></line>
<line><tbox llx="48" lly="621" urx="114" ury="634" f="2"><![CDATA[block size of ]]></tbox><tbox llx="110" lly="621" urx="124" ury="632" f="3"><![CDATA[b ]]></tbox><tbox llx="115" lly="620" urx="138" ury="628" f="4"><![CDATA[max ]]></tbox><tbox llx="135" lly="621" urx="309" ury="634" f="2"><![CDATA[and then decreasing the block size by ]]></tbox></line>
<line><tbox llx="48" lly="609" urx="104" ury="622" f="2"><![CDATA[a factor of ]]></tbox><tbox llx="97" lly="609" urx="114" ury="622" f="5"><![CDATA[2 ]]></tbox><tbox llx="108" lly="609" urx="309" ury="622" f="2"><![CDATA[in each round until reaching a block size of ]]></tbox></line>
<line><tbox llx="49" lly="597" urx="63" ury="608" f="3"><![CDATA[b ]]></tbox><tbox llx="54" lly="596" urx="76" ury="604" f="4"><![CDATA[min ]]></tbox><tbox llx="67" lly="597" urx="309" ury="610" f="2"><![CDATA[. In the first round, the server holding the current version ]]></tbox></line>
<line><tbox llx="48" lly="586" urx="209" ury="598" f="2"><![CDATA[partitions the file into blocks of size ]]></tbox><tbox llx="203" lly="585" urx="217" ury="596" f="3"><![CDATA[b ]]></tbox><tbox llx="208" lly="584" urx="231" ury="592" f="4"><![CDATA[max ]]></tbox><tbox llx="222" lly="586" urx="309" ury="598" f="2"><![CDATA[, and sends a hash ]]></tbox></line>
<line><tbox llx="48" lly="574" urx="309" ury="586" f="2"><![CDATA[value for each block to the client. The client attempts to match ]]></tbox></line>
<line><tbox llx="48" lly="562" urx="309" ury="574" f="2"><![CDATA[the received hashes to all possible alignments in the outdated ]]></tbox></line>
<line><tbox llx="48" lly="550" urx="309" ury="562" f="2"><![CDATA[file, and then responds with a bit vector containing a "1" for ]]></tbox></line>
<line><tbox llx="48" lly="538" urx="309" ury="550" f="2"><![CDATA[each hash that found a match, and a "0" for all other hashes. ]]></tbox></line>
<line><tbox llx="48" lly="526" urx="309" ury="538" f="2"><![CDATA[By doing so, the client notifies the server which of the hashes ]]></tbox></line>
<line><tbox llx="48" lly="514" urx="309" ury="526" f="2"><![CDATA[were "understood" by the client, and which hashes could not ]]></tbox></line>
<line><tbox llx="48" lly="502" urx="246" ury="514" f="2"><![CDATA[be decoded by looking for a match in its file. ]]></tbox></line>
<line><tbox llx="58" lly="488" urx="309" ury="500" f="2"><![CDATA[Next the server partitions each block whose hash did not ]]></tbox></line>
<line><tbox llx="48" lly="476" urx="309" ury="488" f="2"><![CDATA[find a match into two halves, and sends hashes for these ]]></tbox></line>
<line><tbox llx="48" lly="464" urx="309" ury="477" f="2"><![CDATA[smaller blocks to the client. The client again replies with a ]]></tbox></line>
<line><tbox llx="48" lly="452" urx="309" ury="465" f="2"><![CDATA[bit vector, and the server further splits any unmatched blocks. ]]></tbox></line>
<line><tbox llx="48" lly="440" urx="128" ury="453" f="2"><![CDATA[Once block size ]]></tbox><tbox llx="123" lly="440" urx="138" ury="451" f="3"><![CDATA[b ]]></tbox><tbox llx="128" lly="439" urx="150" ury="447" f="4"><![CDATA[min ]]></tbox><tbox llx="147" lly="440" urx="309" ury="453" f="2"><![CDATA[is reached, the server simply sends ]]></tbox></line>
<line><tbox llx="48" lly="429" urx="309" ury="441" f="2"><![CDATA[all unmatched blocks as literals. Figure III.1 illustrates the ]]></tbox></line>
<line><tbox llx="48" lly="417" urx="178" ury="429" f="2"><![CDATA[protocol on a small example. ]]></tbox></line>
<line><tbox llx="71" lly="292" urx="279" ury="300" f="6"><![CDATA[cxefghij klmnopxr stuvwxyz 01zz2345 ]]></tbox></line>
<line><tbox llx="82" lly="314" urx="263" ury="322" f="6"><![CDATA[cxefghijklmnopxr stuvwxyz01zz2345 ]]></tbox></line>
<line><tbox llx="104" lly="339" urx="240" ury="347" f="6"><![CDATA[cxefghijklmnopxrstuvwxyz01zz2345 ]]></tbox></line>
<line><tbox llx="91" lly="247" urx="146" ury="255" f="6"><![CDATA[gh kl mn ]]></tbox><tbox llx="178" lly="247" urx="234" ury="255" f="6"><![CDATA[st uv wx yz ]]></tbox><tbox llx="265" lly="247" urx="292" ury="255" f="6"><![CDATA[23 45 ]]></tbox></line>
<line><tbox llx="105" lly="247" urx="118" ury="256" f="6"><![CDATA[ij ]]></tbox></line>
<line><tbox llx="76" lly="248" urx="249" ury="255" f="6"><![CDATA[ef op 01 ]]></tbox></line>
<line><tbox llx="62" lly="248" urx="264" ury="255" f="6"><![CDATA[cx xr zz ]]></tbox></line>
<line><tbox llx="237" lly="270" urx="287" ury="278" f="6"><![CDATA[01zz 2345 ]]></tbox></line>
<line><tbox llx="150" lly="270" urx="171" ury="278" f="6"><![CDATA[opxr ]]></tbox></line>
<line><tbox llx="122" lly="270" urx="142" ury="278" f="6"><![CDATA[klmn ]]></tbox></line>
<line><tbox llx="93" lly="270" urx="114" ury="279" f="6"><![CDATA[ghij ]]></tbox></line>
<line><tbox llx="64" lly="270" urx="229" ury="278" f="6"><![CDATA[cxef stuv wxyz ]]></tbox></line>
<line><tbox llx="90" lly="353" urx="102" ury="359" f="7"><![CDATA[new ]]></tbox></line>
<line><tbox llx="60" lly="354" urx="97" ury="363" f="8"><![CDATA[The file F ]]></tbox><tbox llx="101" lly="354" urx="144" ury="363" f="8"><![CDATA[at the server ]]></tbox></line>
<line><tbox llx="103" lly="376" urx="239" ury="384" f="6"><![CDATA[abcdefghijklmnopqrstuvwxyz012345 ]]></tbox></line>
<line><tbox llx="91" lly="391" urx="102" ury="398" f="9"><![CDATA[old ]]></tbox></line>
<line><tbox llx="61" lly="393" urx="141" ury="401" f="10"><![CDATA[The file F at the client ]]></tbox></line>
<line><tbox llx="48" lly="220" urx="99" ury="230" f="11"><![CDATA[Figure III.1. ]]></tbox><tbox llx="100" lly="220" urx="307" ury="230" f="12"><![CDATA[The basic multi-round protocol on a small example file pair. ]]></tbox></line>
<line><tbox llx="48" lly="211" urx="307" ury="221" f="12"><![CDATA[Shown in bold outlines are blocks in the server file that find a match at the ]]></tbox></line>
<line><tbox llx="48" lly="202" urx="308" ury="212" f="12"><![CDATA[client, while blocks that have a matched ancestors are shaded. Hashes for ]]></tbox></line>
<line><tbox llx="48" lly="193" urx="204" ury="203" f="12"><![CDATA[the latter blocks are not communicated in the ]]></tbox><tbox llx="198" lly="193" urx="310" ury="203" f="13"><![CDATA[basic multi-round protocol,but ]]></tbox></line>
<line><tbox llx="48" lly="184" urx="158" ury="194" f="12"><![CDATA[would be communicated in the ]]></tbox><tbox llx="152" lly="184" urx="261" ury="194" f="13"><![CDATA[complete multi-round protocol. ]]></tbox></line>
<line><tbox llx="58" lly="161" urx="150" ury="173" f="14"><![CDATA[Suppose we choose ]]></tbox><tbox llx="146" lly="161" urx="160" ury="172" f="3"><![CDATA[b ]]></tbox><tbox llx="150" lly="160" urx="173" ury="168" f="4"><![CDATA[max ]]></tbox><tbox llx="169" lly="161" urx="188" ury="174" f="5"><![CDATA[= ]]></tbox><tbox llx="184" lly="154" urx="219" ury="172" f="15"><![CDATA[#n/k# ]]></tbox><tbox llx="209" lly="159" urx="220" ury="167" f="16"><![CDATA[2 ]]></tbox><tbox llx="212" lly="161" urx="225" ury="173" f="14"><![CDATA[, ]]></tbox><tbox llx="220" lly="161" urx="234" ury="172" f="3"><![CDATA[b ]]></tbox><tbox llx="225" lly="160" urx="247" ury="168" f="4"><![CDATA[min ]]></tbox><tbox llx="243" lly="161" urx="291" ury="174" f="5"><![CDATA[=lg(n), ]]></tbox><tbox llx="284" lly="161" urx="309" ury="173" f="14"><![CDATA[and ]]></tbox></line>
<line><tbox llx="48" lly="149" urx="153" ury="161" f="14"><![CDATA[use hashes of size, say, ]]></tbox><tbox llx="145" lly="149" urx="179" ury="162" f="5"><![CDATA[4lgn ]]></tbox><tbox llx="172" lly="149" urx="309" ury="161" f="14"><![CDATA[bits. Then it can be shown that ]]></tbox></line>
<line><tbox llx="48" lly="137" urx="296" ury="150" f="14"><![CDATA[given two files with edit distance with block moves of ]]></tbox><tbox llx="292" lly="137" urx="310" ury="148" f="3"><![CDATA[k, ]]></tbox></line>
<line><tbox llx="48" lly="125" urx="190" ury="138" f="14"><![CDATA[the algorithm transmits at most ]]></tbox><tbox llx="185" lly="125" urx="211" ury="136" f="3"><![CDATA[O(k ]]></tbox><tbox llx="201" lly="125" urx="272" ury="138" f="5"><![CDATA[lg(n)lg(n/k)) ]]></tbox><tbox llx="266" lly="125" urx="309" ury="138" f="14"><![CDATA[bits and ]]></tbox></line>
<line><tbox llx="48" lly="113" urx="265" ury="126" f="14"><![CDATA[correctly updates the file with probability at least ]]></tbox><tbox llx="258" lly="113" urx="274" ury="126" f="5"><![CDATA[1 ]]></tbox><tbox llx="268" lly="106" urx="286" ury="124" f="15"><![CDATA[- ]]></tbox><tbox llx="280" lly="118" urx="291" ury="126" f="16"><![CDATA[1 ]]></tbox></line>
<line><tbox llx="279" lly="110" urx="292" ury="118" f="4"><![CDATA[n ]]></tbox></line>
<line><tbox llx="284" lly="114" urx="314" ury="126" f="14"><![CDATA[.In ]]></tbox></line>
<line><tbox llx="48" lly="102" urx="248" ury="114" f="14"><![CDATA[particular, on the first level we have at most ]]></tbox><tbox llx="241" lly="101" urx="263" ury="114" f="5"><![CDATA[2k ]]></tbox><tbox llx="257" lly="102" urx="309" ury="114" f="14"><![CDATA[blocks for ]]></tbox></line>
<line><tbox llx="48" lly="90" urx="229" ury="102" f="14"><![CDATA[which hashes are sent. There are at most ]]></tbox><tbox llx="221" lly="89" urx="264" ury="102" f="5"><![CDATA[lg(n/k) ]]></tbox><tbox llx="258" lly="90" urx="309" ury="102" f="14"><![CDATA[levels. On ]]></tbox></line>
<line><tbox llx="48" lly="78" urx="135" ury="90" f="14"><![CDATA[each level at most ]]></tbox><tbox llx="129" lly="77" urx="144" ury="88" f="3"><![CDATA[k ]]></tbox><tbox llx="138" lly="78" urx="309" ury="90" f="14"><![CDATA[of the hashes that are sent do not find ]]></tbox></line>
<line><tbox llx="48" lly="66" urx="244" ury="78" f="14"><![CDATA[a match at the client, and thus again at most ]]></tbox><tbox llx="237" lly="65" urx="258" ury="79" f="5"><![CDATA[2k ]]></tbox><tbox llx="252" lly="66" urx="309" ury="78" f="14"><![CDATA[hash values ]]></tbox></line>
<line><tbox llx="311" lly="723" urx="572" ury="735" f="14"><![CDATA[are sent at the next level, as implied by the following simple ]]></tbox></line>
<line><tbox llx="311" lly="711" urx="351" ury="723" f="14"><![CDATA[lemma. ]]></tbox></line>
<line><tbox llx="321" lly="698" urx="380" ury="710" f="17"><![CDATA[Lemma 3.1: ]]></tbox><tbox llx="374" lly="698" urx="398" ury="710" f="14"><![CDATA[Let ]]></tbox><tbox llx="393" lly="698" urx="408" ury="708" f="3"><![CDATA[f ]]></tbox><tbox llx="398" lly="697" urx="420" ury="705" f="4"><![CDATA[new ]]></tbox><tbox llx="415" lly="698" urx="441" ury="710" f="14"><![CDATA[and ]]></tbox><tbox llx="435" lly="698" urx="450" ury="708" f="3"><![CDATA[f ]]></tbox><tbox llx="440" lly="697" urx="458" ury="705" f="4"><![CDATA[old ]]></tbox><tbox llx="454" lly="698" urx="572" ury="710" f="14"><![CDATA[be two files with edit dis- ]]></tbox></line>
<line><tbox llx="311" lly="686" urx="449" ury="698" f="14"><![CDATA[tance with block moves at most ]]></tbox><tbox llx="442" lly="686" urx="460" ury="697" f="3"><![CDATA[k, ]]></tbox><tbox llx="451" lly="686" urx="572" ury="698" f="14"><![CDATA[where each move operation ]]></tbox></line>
<line><tbox llx="311" lly="674" urx="431" ury="686" f="14"><![CDATA[is counted as a distance of ]]></tbox><tbox llx="423" lly="674" urx="442" ury="687" f="5"><![CDATA[3. ]]></tbox><tbox llx="435" lly="674" urx="505" ury="686" f="14"><![CDATA[If we partition ]]></tbox><tbox llx="499" lly="674" urx="514" ury="685" f="3"><![CDATA[f ]]></tbox><tbox llx="505" lly="673" urx="526" ury="681" f="4"><![CDATA[new ]]></tbox><tbox llx="522" lly="674" urx="572" ury="686" f="14"><![CDATA[into some ]]></tbox></line>
<line><tbox llx="311" lly="662" urx="352" ury="674" f="14"><![CDATA[number ]]></tbox><tbox llx="347" lly="662" urx="365" ury="673" f="3"><![CDATA[m ]]></tbox><tbox llx="358" lly="662" urx="441" ury="674" f="14"><![CDATA[of disjoint blocks ]]></tbox><tbox llx="436" lly="662" urx="450" ury="673" f="3"><![CDATA[s ]]></tbox><tbox llx="440" lly="661" urx="451" ury="669" f="16"><![CDATA[0 ]]></tbox><tbox llx="447" lly="662" urx="466" ury="674" f="14"><![CDATA[to ]]></tbox><tbox llx="461" lly="662" urx="475" ury="673" f="3"><![CDATA[s ]]></tbox><tbox llx="466" lly="661" urx="490" ury="669" f="4"><![CDATA[m-1 ]]></tbox><tbox llx="482" lly="662" urx="551" ury="674" f="14"><![CDATA[, then at most ]]></tbox><tbox llx="545" lly="662" urx="560" ury="673" f="3"><![CDATA[k ]]></tbox><tbox llx="554" lly="662" urx="572" ury="674" f="14"><![CDATA[of ]]></tbox></line>
<line><tbox llx="311" lly="650" urx="438" ury="662" f="14"><![CDATA[these blocks do not occur in ]]></tbox><tbox llx="432" lly="650" urx="447" ury="661" f="3"><![CDATA[f ]]></tbox><tbox llx="437" lly="649" urx="455" ury="657" f="4"><![CDATA[old ]]></tbox><tbox llx="447" lly="650" urx="460" ury="662" f="14"><![CDATA[. ]]></tbox></line>
<line><tbox llx="321" lly="636" urx="572" ury="649" f="14"><![CDATA[We only sketch the proof of the lemma, which is not really ]]></tbox></line>
<line><tbox llx="311" lly="625" urx="437" ury="637" f="14"><![CDATA[new. Consider a sequence of ]]></tbox><tbox llx="431" lly="624" urx="446" ury="635" f="3"><![CDATA[k ]]></tbox><tbox llx="438" lly="625" urx="573" ury="637" f="14"><![CDATA[edit operations that transforms ]]></tbox></line>
<line><tbox llx="312" lly="612" urx="327" ury="623" f="3"><![CDATA[f ]]></tbox><tbox llx="317" lly="612" urx="335" ury="619" f="4"><![CDATA[old ]]></tbox><tbox llx="330" lly="613" urx="356" ury="625" f="14"><![CDATA[into ]]></tbox><tbox llx="350" lly="612" urx="364" ury="623" f="3"><![CDATA[f ]]></tbox><tbox llx="355" lly="612" urx="377" ury="619" f="4"><![CDATA[new ]]></tbox><tbox llx="369" lly="613" urx="435" ury="625" f="14"><![CDATA[. Imagine that ]]></tbox><tbox llx="429" lly="612" urx="444" ury="623" f="3"><![CDATA[f ]]></tbox><tbox llx="434" lly="612" urx="452" ury="619" f="4"><![CDATA[old ]]></tbox><tbox llx="447" lly="613" urx="572" ury="625" f="14"><![CDATA[is printed on a long piece of ]]></tbox></line>
<line><tbox llx="311" lly="601" urx="572" ury="613" f="14"><![CDATA[paper, and that each edit operation may require us to cut the ]]></tbox></line>
<line><tbox llx="311" lly="589" urx="572" ury="601" f="14"><![CDATA[piece of paper in order to insert, delete, or change a character ]]></tbox></line>
<line><tbox llx="311" lly="577" urx="572" ury="589" f="14"><![CDATA[at a particular position, or to move a block from one position to ]]></tbox></line>
<line><tbox llx="311" lly="565" urx="572" ury="577" f="14"><![CDATA[another. Each single-character operation increases the number ]]></tbox></line>
<line><tbox llx="311" lly="553" urx="572" ury="565" f="14"><![CDATA[of pieces of the old file by at most one, while each move ]]></tbox></line>
<line><tbox llx="311" lly="541" urx="572" ury="553" f="14"><![CDATA[operation may require up to three cuts and thus increases the ]]></tbox></line>
<line><tbox llx="311" lly="529" urx="531" ury="541" f="14"><![CDATA[number of pieces by at most three. Any substring ]]></tbox><tbox llx="525" lly="529" urx="540" ury="540" f="3"><![CDATA[s ]]></tbox><tbox llx="530" lly="528" urx="540" ury="536" f="4"><![CDATA[i ]]></tbox><tbox llx="536" lly="529" urx="572" ury="541" f="14"><![CDATA[that is ]]></tbox></line>
<line><tbox llx="311" lly="517" urx="480" ury="529" f="14"><![CDATA[completely within one of the at most ]]></tbox><tbox llx="476" lly="517" urx="491" ury="528" f="3"><![CDATA[k ]]></tbox><tbox llx="485" lly="517" urx="573" ury="529" f="14"><![CDATA[pieces clearly also ]]></tbox></line>
<line><tbox llx="311" lly="505" urx="359" ury="517" f="14"><![CDATA[occurs in ]]></tbox><tbox llx="353" lly="505" urx="368" ury="516" f="3"><![CDATA[f ]]></tbox><tbox llx="358" lly="504" urx="376" ury="512" f="4"><![CDATA[old ]]></tbox><tbox llx="368" lly="505" urx="453" ury="517" f="14"><![CDATA[, giving the result. ]]></tbox></line>
<line><tbox llx="321" lly="491" urx="573" ury="504" f="14"><![CDATA[There are several possible practical optimizations to this ]]></tbox></line>
<line><tbox llx="311" lly="480" urx="573" ury="492" f="14"><![CDATA[algorithm [37], but this is not our concern. In the following, ]]></tbox></line>
<line><tbox llx="311" lly="468" urx="572" ury="480" f="14"><![CDATA[we show how to convert this algorithm into a single-round ]]></tbox></line>
<line><tbox llx="311" lly="456" urx="465" ury="468" f="14"><![CDATA[protocol with the same complexity. ]]></tbox></line>
<line><tbox llx="311" lly="436" urx="478" ury="448" f="17"><![CDATA[B. An Efficient Single-Round Protocol ]]></tbox></line>
<line><tbox llx="321" lly="419" urx="414" ury="431" f="14"><![CDATA[First, we define the ]]></tbox><tbox llx="407" lly="419" urx="543" ury="431" f="17"><![CDATA[complete multi-round protocol ]]></tbox><tbox llx="537" lly="419" urx="572" ury="431" f="14"><![CDATA[as the ]]></tbox></line>
<line><tbox llx="311" lly="407" urx="572" ury="419" f="14"><![CDATA[variation of the basic multi-round protocol from the previous ]]></tbox></line>
<line><tbox llx="311" lly="395" urx="572" ury="407" f="14"><![CDATA[subsection where in each round, we split all blocks in half and ]]></tbox></line>
<line><tbox llx="311" lly="383" urx="572" ury="395" f="14"><![CDATA[send hashes for all the resulting smaller blocks, including those ]]></tbox></line>
<line><tbox llx="311" lly="371" urx="572" ury="383" f="14"><![CDATA[whose ancestors have already found matches on a higher level. ]]></tbox></line>
<line><tbox llx="311" lly="359" urx="572" ury="371" f="14"><![CDATA[(Obviously, this is not a communication-efficient algorithm.) ]]></tbox></line>
<line><tbox llx="311" lly="347" urx="572" ury="359" f="14"><![CDATA[Due to the above lemma, both variations have the property ]]></tbox></line>
<line><tbox llx="311" lly="335" urx="428" ury="347" f="14"><![CDATA[that on each level at most ]]></tbox><tbox llx="422" lly="335" urx="437" ury="346" f="3"><![CDATA[k ]]></tbox><tbox llx="429" lly="335" urx="553" ury="347" f="14"><![CDATA[hashes do not find a match. ]]></tbox></line>
<line><tbox llx="321" lly="322" urx="472" ury="334" f="14"><![CDATA[Our second required ingredient is a ]]></tbox><tbox llx="464" lly="322" urx="573" ury="334" f="17"><![CDATA[systematic erasure code, ]]></tbox></line>
<line><tbox llx="311" lly="310" urx="573" ury="322" f="14"><![CDATA[which we now discuss briefly. We refer to [31] for a more ]]></tbox></line>
<line><tbox llx="311" lly="298" urx="423" ury="310" f="14"><![CDATA[detailed discussion. In an ]]></tbox><tbox llx="414" lly="298" urx="573" ury="310" f="17"><![CDATA[erasure code,wearegivenm source ]]></tbox></line>
<line><tbox llx="311" lly="286" urx="364" ury="298" f="17"><![CDATA[data items ]]></tbox><tbox llx="356" lly="286" urx="442" ury="298" f="14"><![CDATA[of some fixed size ]]></tbox><tbox llx="436" lly="286" urx="450" ury="297" f="3"><![CDATA[s ]]></tbox><tbox llx="442" lly="286" urx="573" ury="298" f="14"><![CDATA[each, which are encoded into ]]></tbox></line>
<line><tbox llx="312" lly="274" urx="331" ury="285" f="3"><![CDATA[m ]]></tbox><tbox llx="321" lly="273" urx="331" ury="286" f="18"><![CDATA[# ]]></tbox><tbox llx="326" lly="274" urx="391" ury="285" f="3"><![CDATA[}mencoded ]]></tbox><tbox llx="382" lly="274" urx="434" ury="286" f="17"><![CDATA[data items ]]></tbox><tbox llx="426" lly="274" urx="500" ury="286" f="14"><![CDATA[of the same size ]]></tbox><tbox llx="493" lly="274" urx="510" ury="285" f="3"><![CDATA[s, ]]></tbox><tbox llx="501" lly="274" urx="572" ury="286" f="14"><![CDATA[such that if any ]]></tbox></line>
<line><tbox llx="312" lly="262" urx="331" ury="273" f="3"><![CDATA[m ]]></tbox><tbox llx="321" lly="261" urx="331" ury="274" f="18"><![CDATA[# ]]></tbox><tbox llx="324" lly="255" urx="352" ury="273" f="15"><![CDATA[-m ]]></tbox><tbox llx="343" lly="262" urx="573" ury="274" f="14"><![CDATA[of the encoded data items are lost during transmission, ]]></tbox></line>
<line><tbox llx="311" lly="250" urx="449" ury="262" f="14"><![CDATA[they can be recovered from the ]]></tbox><tbox llx="443" lly="250" urx="461" ury="261" f="3"><![CDATA[m ]]></tbox><tbox llx="453" lly="250" urx="572" ury="262" f="14"><![CDATA[correctly received encoded ]]></tbox></line>
<line><tbox llx="311" lly="238" urx="572" ury="250" f="14"><![CDATA[data items. Note that it is assumed here that a receiver knows ]]></tbox></line>
<line><tbox llx="311" lly="226" urx="573" ury="238" f="14"><![CDATA[which items have been correctly received and which are lost. A ]]></tbox></line>
<line><tbox llx="311" lly="214" urx="363" ury="226" f="17"><![CDATA[systematic ]]></tbox><tbox llx="356" lly="214" urx="572" ury="226" f="14"><![CDATA[erasure code is one where the encoded data items ]]></tbox></line>
<line><tbox llx="311" lly="202" urx="378" ury="214" f="14"><![CDATA[consist of the ]]></tbox><tbox llx="374" lly="202" urx="392" ury="213" f="3"><![CDATA[m ]]></tbox><tbox llx="385" lly="202" urx="490" ury="214" f="14"><![CDATA[source data items plus ]]></tbox><tbox llx="485" lly="202" urx="504" ury="213" f="3"><![CDATA[m ]]></tbox><tbox llx="494" lly="201" urx="504" ury="214" f="18"><![CDATA[# ]]></tbox><tbox llx="500" lly="195" urx="518" ury="213" f="15"><![CDATA[- ]]></tbox><tbox llx="510" lly="202" urx="529" ury="213" f="3"><![CDATA[m ]]></tbox><tbox llx="522" lly="202" urx="572" ury="214" f="14"><![CDATA[additional ]]></tbox></line>
<line><tbox llx="311" lly="190" urx="572" ury="202" f="14"><![CDATA[items. In our application, which requires a systematic erasure ]]></tbox></line>
<line><tbox llx="311" lly="178" urx="572" ury="190" f="14"><![CDATA[code, the source data items are hashes, and we refer to the ]]></tbox></line>
<line><tbox llx="312" lly="166" urx="331" ury="177" f="3"><![CDATA[m ]]></tbox><tbox llx="321" lly="165" urx="331" ury="179" f="18"><![CDATA[# ]]></tbox><tbox llx="326" lly="159" urx="355" ury="177" f="15"><![CDATA[-m ]]></tbox><tbox llx="347" lly="166" urx="434" ury="178" f="14"><![CDATA[additional items as ]]></tbox><tbox llx="427" lly="166" urx="501" ury="178" f="17"><![CDATA[erasure hashes. ]]></tbox></line>
<line><tbox llx="321" lly="153" urx="572" ury="165" f="14"><![CDATA[Our algorithm is essentially a communication-efficient ]]></tbox></line>
<line><tbox llx="311" lly="141" urx="572" ury="153" f="14"><![CDATA[single-round simulation of the complete multi-round algo- ]]></tbox></line>
<line><tbox llx="311" lly="129" urx="485" ury="141" f="14"><![CDATA[rithm. Suppose we know an upper bound ]]></tbox><tbox llx="478" lly="129" urx="493" ury="140" f="3"><![CDATA[k ]]></tbox><tbox llx="485" lly="129" urx="572" ury="141" f="14"><![CDATA[on the edit distance ]]></tbox></line>
<line><tbox llx="311" lly="117" urx="572" ury="129" f="14"><![CDATA[with block moves between the files. Then on each level, we ]]></tbox></line>
<line><tbox llx="311" lly="105" urx="573" ury="117" f="14"><![CDATA[can simulate the complete multi-round algorithm according to ]]></tbox></line>
<line><tbox llx="311" lly="93" urx="401" ury="105" f="14"><![CDATA[the following rules: ]]></tbox></line>
<line><tbox llx="322" lly="73" urx="334" ury="86" f="18"><![CDATA[. ]]></tbox><tbox llx="331" lly="78" urx="572" ury="90" f="14"><![CDATA[Any hash value sent in the complete multi-round protocol ]]></tbox></line>
<line><tbox llx="331" lly="66" urx="572" ury="78" f="14"><![CDATA[that would not be sent in the basic multi-round protocol ]]></tbox></line>
<pbox llx="48.00" lly="65.00" urx="573.00" ury="735.00"/></page>
<page n="9">
<line><tbox llx="68" lly="723" urx="309" ury="735" f="1"><![CDATA[(since it corresponds to a block whose ancestor has ]]></tbox></line>
<line><tbox llx="68" lly="711" urx="309" ury="723" f="1"><![CDATA[already found a match) is not transmitted, as it can be ]]></tbox></line>
<line><tbox llx="68" lly="699" urx="309" ury="712" f="1"><![CDATA[recreated at the client by evaluating the hash function on ]]></tbox></line>
<line><tbox llx="68" lly="687" urx="228" ury="700" f="1"><![CDATA[the corresponding part of the match. ]]></tbox></line>
<line><tbox llx="59" lly="671" urx="71" ury="684" f="2"><![CDATA[. ]]></tbox><tbox llx="68" lly="675" urx="309" ury="688" f="1"><![CDATA[Any hash value that would be sent by the basic multi- ]]></tbox></line>
<line><tbox llx="68" lly="664" urx="309" ury="676" f="1"><![CDATA[round algorithm (since it corresponds to a block with ]]></tbox></line>
<line><tbox llx="68" lly="652" urx="309" ury="664" f="1"><![CDATA[no matched ancestors) is also not sent to the client, but ]]></tbox></line>
<line><tbox llx="68" lly="640" urx="122" ury="652" f="1"><![CDATA[considered ]]></tbox><tbox llx="114" lly="640" urx="142" ury="652" f="3"><![CDATA[lost. ]]></tbox></line>
<line><tbox llx="59" lly="623" urx="71" ury="636" f="2"><![CDATA[. ]]></tbox><tbox llx="68" lly="628" urx="245" ury="640" f="1"><![CDATA[Since on each level there can be at most ]]></tbox><tbox llx="236" lly="627" urx="258" ury="640" f="4"><![CDATA[2k ]]></tbox><tbox llx="251" lly="628" urx="309" ury="640" f="1"><![CDATA[such blocks ]]></tbox></line>
<line><tbox llx="68" lly="616" urx="146" ury="628" f="1"><![CDATA[that are declared ]]></tbox><tbox llx="139" lly="616" urx="167" ury="628" f="3"><![CDATA[lost, ]]></tbox><tbox llx="159" lly="616" urx="309" ury="628" f="1"><![CDATA[we can recreate the entire level of ]]></tbox></line>
<line><tbox llx="68" lly="604" urx="206" ury="616" f="1"><![CDATA[hashes at the client by sending ]]></tbox><tbox llx="199" lly="603" urx="220" ury="617" f="4"><![CDATA[2k ]]></tbox><tbox llx="214" lly="604" urx="309" ury="616" f="1"><![CDATA[extra erasure hashes, ]]></tbox></line>
<line><tbox llx="68" lly="592" urx="309" ury="604" f="1"><![CDATA[computed with a systematic erasure code from all hashes ]]></tbox></line>
<line><tbox llx="68" lly="580" urx="221" ury="592" f="1"><![CDATA[on a level, and then recovering the ]]></tbox><tbox llx="214" lly="580" urx="239" ury="592" f="3"><![CDATA[lost ]]></tbox><tbox llx="232" lly="580" urx="272" ury="592" f="1"><![CDATA[hashes. ]]></tbox></line>
<line><tbox llx="48" lly="565" urx="252" ury="577" f="1"><![CDATA[To summarize, the algorithm works as follows: ]]></tbox></line>
<line><tbox llx="50" lly="550" urx="164" ury="562" f="1"><![CDATA[(1) The server partitions ]]></tbox><tbox llx="159" lly="550" urx="174" ury="561" f="5"><![CDATA[f ]]></tbox><tbox llx="164" lly="549" urx="186" ury="557" f="6"><![CDATA[new ]]></tbox><tbox llx="182" lly="550" urx="309" ury="562" f="1"><![CDATA[recursively into blocks from ]]></tbox></line>
<line><tbox llx="68" lly="538" urx="94" ury="550" f="1"><![CDATA[size ]]></tbox><tbox llx="88" lly="538" urx="102" ury="549" f="5"><![CDATA[b ]]></tbox><tbox llx="92" lly="537" urx="116" ury="545" f="6"><![CDATA[max ]]></tbox><tbox llx="110" lly="538" urx="154" ury="550" f="1"><![CDATA[down to ]]></tbox><tbox llx="148" lly="538" urx="162" ury="549" f="5"><![CDATA[b ]]></tbox><tbox llx="152" lly="537" urx="174" ury="545" f="6"><![CDATA[min ]]></tbox><tbox llx="166" lly="538" urx="309" ury="550" f="1"><![CDATA[, and for each level computes all ]]></tbox></line>
<line><tbox llx="68" lly="526" urx="133" ury="538" f="1"><![CDATA[block hashes. ]]></tbox></line>
<line><tbox llx="50" lly="514" urx="309" ury="526" f="1"><![CDATA[(2) The server applies a systematic erasure code to each level ]]></tbox></line>
<line><tbox llx="68" lly="502" urx="263" ury="514" f="1"><![CDATA[of hashes except the top level, and computes ]]></tbox><tbox llx="255" lly="502" urx="277" ury="515" f="4"><![CDATA[2k ]]></tbox><tbox llx="270" lly="502" urx="309" ury="514" f="1"><![CDATA[erasure ]]></tbox></line>
<line><tbox llx="68" lly="490" urx="167" ury="502" f="1"><![CDATA[hashes for each level. ]]></tbox></line>
<line><tbox llx="50" lly="478" urx="309" ury="490" f="1"><![CDATA[(3) In one message, the servers sends all hashes at the highest ]]></tbox></line>
<line><tbox llx="68" lly="466" urx="192" ury="478" f="1"><![CDATA[level to the client, plus the ]]></tbox><tbox llx="185" lly="466" urx="207" ury="479" f="4"><![CDATA[2k ]]></tbox><tbox llx="201" lly="466" urx="309" ury="478" f="1"><![CDATA[erasure hashes for each ]]></tbox></line>
<line><tbox llx="68" lly="454" urx="100" ury="466" f="1"><![CDATA[level. ]]></tbox></line>
<line><tbox llx="50" lly="442" urx="309" ury="455" f="1"><![CDATA[(4) The client, upon receiving the message, recovers the ]]></tbox></line>
<line><tbox llx="68" lly="430" urx="309" ury="443" f="1"><![CDATA[hashes on all levels in a top-down manner, by first ]]></tbox></line>
<line><tbox llx="68" lly="418" urx="309" ury="431" f="1"><![CDATA[matching the top-level hashes. Then on the next level, ]]></tbox></line>
<line><tbox llx="68" lly="407" urx="309" ury="419" f="1"><![CDATA[the hash function is applied to all children of blocks ]]></tbox></line>
<line><tbox llx="68" lly="395" urx="309" ury="407" f="1"><![CDATA[that were already matched on a higher level in order to ]]></tbox></line>
<line><tbox llx="68" lly="383" urx="198" ury="395" f="1"><![CDATA[compute their hashes, and the ]]></tbox><tbox llx="190" lly="382" urx="212" ury="395" f="4"><![CDATA[2k ]]></tbox><tbox llx="204" lly="383" urx="309" ury="395" f="1"><![CDATA[erasure hashes are used ]]></tbox></line>
<line><tbox llx="68" lly="371" urx="229" ury="383" f="1"><![CDATA[to recover the hashes of the at most ]]></tbox><tbox llx="222" lly="370" urx="244" ury="383" f="4"><![CDATA[2k ]]></tbox><tbox llx="237" lly="371" urx="309" ury="383" f="1"><![CDATA[blocks with no ]]></tbox></line>
<line><tbox llx="68" lly="359" urx="155" ury="371" f="1"><![CDATA[matched ancestors. ]]></tbox></line>
<line><tbox llx="50" lly="347" urx="220" ury="359" f="1"><![CDATA[(5) At the bottom level with block size ]]></tbox><tbox llx="214" lly="346" urx="228" ury="357" f="5"><![CDATA[b ]]></tbox><tbox llx="218" lly="346" urx="240" ury="354" f="6"><![CDATA[min ]]></tbox><tbox llx="232" lly="347" urx="309" ury="359" f="1"><![CDATA[, we assume that ]]></tbox></line>
<line><tbox llx="68" lly="335" urx="309" ury="347" f="1"><![CDATA[the hash is simply the content of the block, and thus we ]]></tbox></line>
<line><tbox llx="68" lly="323" urx="243" ury="335" f="1"><![CDATA[can recover the current file at the client. ]]></tbox></line>
<line><tbox llx="48" lly="308" urx="309" ury="320" f="1"><![CDATA[Assuming no hash collisions, the algorithm correctly simu- ]]></tbox></line>
<line><tbox llx="48" lly="296" urx="309" ury="308" f="1"><![CDATA[lates the complete multi-round algorithm. Choosing as before ]]></tbox></line>
<line><tbox llx="49" lly="284" urx="63" ury="295" f="5"><![CDATA[b ]]></tbox><tbox llx="54" lly="283" urx="77" ury="291" f="6"><![CDATA[max ]]></tbox><tbox llx="70" lly="284" urx="90" ury="297" f="4"><![CDATA[= ]]></tbox><tbox llx="83" lly="277" urx="119" ury="295" f="7"><![CDATA[#n/k# ]]></tbox><tbox llx="109" lly="281" urx="120" ury="289" f="8"><![CDATA[2 ]]></tbox></line>
<line><tbox llx="112" lly="284" urx="125" ury="296" f="1"><![CDATA[, ]]></tbox><tbox llx="119" lly="284" urx="133" ury="295" f="5"><![CDATA[b ]]></tbox><tbox llx="123" lly="283" urx="145" ury="291" f="6"><![CDATA[min ]]></tbox><tbox llx="139" lly="284" urx="185" ury="297" f="4"><![CDATA[=lg(n), ]]></tbox><tbox llx="178" lly="284" urx="264" ury="296" f="1"><![CDATA[and hashes of size ]]></tbox><tbox llx="256" lly="284" urx="289" ury="297" f="4"><![CDATA[4lgn ]]></tbox><tbox llx="282" lly="284" urx="309" ury="296" f="1"><![CDATA[bits, ]]></tbox></line>
<line><tbox llx="48" lly="272" urx="172" ury="284" f="1"><![CDATA[we get the following result: ]]></tbox></line>
<line><tbox llx="58" lly="259" urx="115" ury="270" f="3"><![CDATA[Theorem 1: ]]></tbox><tbox llx="110" lly="259" urx="184" ury="271" f="1"><![CDATA[Given a bound ]]></tbox><tbox llx="180" lly="258" urx="195" ury="269" f="5"><![CDATA[k ]]></tbox><tbox llx="190" lly="259" urx="309" ury="271" f="1"><![CDATA[on the edit distance with ]]></tbox></line>
<line><tbox llx="48" lly="247" urx="149" ury="259" f="1"><![CDATA[block moves between ]]></tbox><tbox llx="144" lly="246" urx="159" ury="257" f="5"><![CDATA[f ]]></tbox><tbox llx="149" lly="246" urx="167" ury="253" f="6"><![CDATA[old ]]></tbox><tbox llx="164" lly="247" urx="189" ury="259" f="1"><![CDATA[and ]]></tbox><tbox llx="184" lly="246" urx="199" ury="257" f="5"><![CDATA[f ]]></tbox><tbox llx="189" lly="246" urx="211" ury="253" f="6"><![CDATA[new ]]></tbox><tbox llx="203" lly="247" urx="309" ury="259" f="1"><![CDATA[, the erasure-based file ]]></tbox></line>
<line><tbox llx="48" lly="235" urx="246" ury="247" f="1"><![CDATA[synchronization algorithm correctly updates ]]></tbox><tbox llx="243" lly="234" urx="258" ury="245" f="5"><![CDATA[f ]]></tbox><tbox llx="249" lly="234" urx="266" ury="242" f="6"><![CDATA[old ]]></tbox><tbox llx="265" lly="235" urx="283" ury="247" f="1"><![CDATA[to ]]></tbox><tbox llx="280" lly="234" urx="295" ury="245" f="5"><![CDATA[f ]]></tbox><tbox llx="285" lly="234" urx="307" ury="242" f="6"><![CDATA[new ]]></tbox></line>
<line><tbox llx="48" lly="223" urx="160" ury="235" f="1"><![CDATA[with probability at least ]]></tbox><tbox llx="153" lly="222" urx="170" ury="235" f="4"><![CDATA[1 ]]></tbox><tbox llx="164" lly="215" urx="182" ury="234" f="7"><![CDATA[- ]]></tbox><tbox llx="176" lly="227" urx="187" ury="235" f="8"><![CDATA[1 ]]></tbox></line>
<line><tbox llx="176" lly="220" urx="188" ury="228" f="6"><![CDATA[n ]]></tbox></line>
<line><tbox llx="180" lly="223" urx="309" ury="235" f="1"><![CDATA[, using a single message of ]]></tbox></line>
<line><tbox llx="49" lly="210" urx="76" ury="221" f="5"><![CDATA[O(k ]]></tbox><tbox llx="66" lly="210" urx="137" ury="224" f="4"><![CDATA[lg(n)lg(n/k)) ]]></tbox><tbox llx="129" lly="211" urx="157" ury="223" f="1"><![CDATA[bits. ]]></tbox></line>
<line><tbox llx="48" lly="197" urx="309" ury="209" f="1"><![CDATA[We note that there are highly efficient single-message pro- ]]></tbox></line>
<line><tbox llx="48" lly="185" urx="309" ury="197" f="1"><![CDATA[tocols for estimating file distances according to a variety ]]></tbox></line>
<line><tbox llx="48" lly="173" urx="309" ury="185" f="1"><![CDATA[of edit distance measures; see [8]. These results imply that ]]></tbox></line>
<line><tbox llx="48" lly="161" urx="309" ury="173" f="1"><![CDATA[the above bound can be achieved by a single-round protocol ]]></tbox></line>
<line><tbox llx="48" lly="149" urx="309" ury="161" f="1"><![CDATA[even if there is no a-priori known bound on the file distance ]]></tbox></line>
<line><tbox llx="49" lly="137" urx="67" ury="148" f="5"><![CDATA[k, ]]></tbox><tbox llx="61" lly="137" urx="309" ury="150" f="1"><![CDATA[if the request message from client to server is used to ]]></tbox></line>
<line><tbox llx="48" lly="125" urx="92" ury="138" f="1"><![CDATA[estimate ]]></tbox><tbox llx="86" lly="125" urx="104" ury="136" f="5"><![CDATA[k. ]]></tbox><tbox llx="97" lly="125" urx="309" ury="138" f="1"><![CDATA[To our knowledge, this result is the first feasible ]]></tbox></line>
<line><tbox llx="48" lly="113" urx="309" ury="126" f="1"><![CDATA[single-round protocol for file synchronization that is provably ]]></tbox></line>
<line><tbox llx="48" lly="102" urx="309" ury="114" f="1"><![CDATA[communication-efficient with respect to edit distance with ]]></tbox></line>
<line><tbox llx="48" lly="90" urx="309" ury="102" f="1"><![CDATA[block moves, or any distance measure allowing for block ]]></tbox></line>
<line><tbox llx="48" lly="78" urx="309" ury="90" f="1"><![CDATA[operations. Another interesting property of the protocol is that ]]></tbox></line>
<line><tbox llx="48" lly="66" urx="309" ury="78" f="1"><![CDATA[by broadcasting a single message, the current version can ]]></tbox></line>
<line><tbox llx="311" lly="723" urx="572" ury="735" f="1"><![CDATA[be communicated to many clients holding different outdated ]]></tbox></line>
<line><tbox llx="311" lly="711" urx="357" ury="723" f="1"><![CDATA[versions. ]]></tbox></line>
<line><tbox llx="311" lly="691" urx="525" ury="703" f="3"><![CDATA[C. A Practical Protocol Based on Erasure Codes ]]></tbox></line>
<line><tbox llx="321" lly="674" urx="572" ury="686" f="1"><![CDATA[While the protocol from the previous subsection is effi- ]]></tbox></line>
<line><tbox llx="311" lly="662" urx="572" ury="674" f="1"><![CDATA[ciently implementable and has reasonable performance, it does ]]></tbox></line>
<line><tbox llx="311" lly="650" urx="572" ury="662" f="1"><![CDATA[suffer from two main shortcomings that make it inferior to ]]></tbox></line>
<line><tbox llx="311" lly="638" urx="343" ury="650" f="3"><![CDATA[rsync ]]></tbox><tbox llx="336" lly="638" urx="509" ury="650" f="1"><![CDATA[and other existing protocols in practice. ]]></tbox></line>
<line><tbox llx="322" lly="618" urx="334" ury="631" f="2"><![CDATA[. ]]></tbox><tbox llx="331" lly="623" urx="572" ury="635" f="1"><![CDATA[The protocol requires us to estimate an upper bound ]]></tbox></line>
<line><tbox llx="331" lly="611" urx="427" ury="623" f="1"><![CDATA[on the file distance ]]></tbox><tbox llx="424" lly="611" urx="442" ury="621" f="5"><![CDATA[k. ]]></tbox><tbox llx="437" lly="611" urx="572" ury="623" f="1"><![CDATA[This adds complexity to the ]]></tbox></line>
<line><tbox llx="331" lly="599" urx="572" ury="611" f="1"><![CDATA[implementation, and while there are efficient protocols for ]]></tbox></line>
<line><tbox llx="331" lly="587" urx="572" ury="599" f="1"><![CDATA[this, we need to make sure that we do not underestimate, ]]></tbox></line>
<line><tbox llx="331" lly="575" urx="572" ury="587" f="1"><![CDATA[since otherwise the client is unable to recover the current ]]></tbox></line>
<line><tbox llx="331" lly="563" urx="572" ury="575" f="1"><![CDATA[file. Thus, to be sure we may have to send more than ]]></tbox></line>
<line><tbox llx="331" lly="551" urx="372" ury="563" f="1"><![CDATA[needed. ]]></tbox></line>
<line><tbox llx="322" lly="535" urx="334" ury="548" f="2"><![CDATA[. ]]></tbox><tbox llx="331" lly="539" urx="572" ury="551" f="1"><![CDATA[More importantly, the algorithm does not support com- ]]></tbox></line>
<line><tbox llx="331" lly="527" urx="572" ury="539" f="1"><![CDATA[pression of unmatched literals but essentially sends them ]]></tbox></line>
<line><tbox llx="331" lly="515" urx="527" ury="527" f="1"><![CDATA[in raw form as hashes. The performance of ]]></tbox><tbox llx="521" lly="515" urx="554" ury="527" f="3"><![CDATA[rsync ]]></tbox><tbox llx="547" lly="515" urx="572" ury="527" f="1"><![CDATA[and ]]></tbox></line>
<line><tbox llx="331" lly="503" urx="572" ury="515" f="1"><![CDATA[other protocols such as [37] is significantly improved ]]></tbox></line>
<line><tbox llx="331" lly="491" urx="573" ury="503" f="1"><![CDATA[through the use of compression for literals. There are ]]></tbox></line>
<line><tbox llx="331" lly="479" urx="572" ury="491" f="1"><![CDATA[some tricks that one can use to integrate compression into ]]></tbox></line>
<line><tbox llx="331" lly="467" urx="572" ury="479" f="1"><![CDATA[the algorithm, but this seems to lead either to variable- ]]></tbox></line>
<line><tbox llx="331" lly="455" urx="572" ury="468" f="1"><![CDATA[size data items in the erasure coding at the leaf level, or ]]></tbox></line>
<line><tbox llx="331" lly="443" urx="573" ury="456" f="1"><![CDATA[to severely reduced compression if we force all items to ]]></tbox></line>
<line><tbox llx="331" lly="432" urx="424" ury="444" f="1"><![CDATA[be of the same size. ]]></tbox></line>
<line><tbox llx="311" lly="416" urx="572" ury="428" f="1"><![CDATA[To address these problems we design another erasure-based ]]></tbox></line>
<line><tbox llx="311" lly="404" urx="572" ury="416" f="1"><![CDATA[algorithm that works better in practice. The main change is ]]></tbox></line>
<line><tbox llx="311" lly="392" urx="385" ury="404" f="1"><![CDATA[that now, as in ]]></tbox><tbox llx="378" lly="392" urx="413" ury="404" f="3"><![CDATA[rsync, ]]></tbox><tbox llx="407" lly="392" urx="572" ury="404" f="1"><![CDATA[hashes are sent from client to server ]]></tbox></line>
<line><tbox llx="311" lly="380" urx="573" ury="392" f="1"><![CDATA[as part of the request, while the server uses the hashes to ]]></tbox></line>
<line><tbox llx="311" lly="368" urx="572" ury="380" f="1"><![CDATA[identify common blocks and then sends the unmatched literals ]]></tbox></line>
<line><tbox llx="311" lly="356" urx="573" ury="368" f="1"><![CDATA[in compressed form. In fact, similar to the way the first ]]></tbox></line>
<line><tbox llx="311" lly="344" urx="573" ury="356" f="1"><![CDATA[algorithm was obtained from the basic and complete multi- ]]></tbox></line>
<line><tbox llx="311" lly="332" urx="572" ury="344" f="1"><![CDATA[round algorithms by adding erasure hashes, the new algorithm ]]></tbox></line>
<line><tbox llx="311" lly="320" urx="572" ury="332" f="1"><![CDATA[can be obtained by adding erasure hashes to a multi-round ]]></tbox></line>
<line><tbox llx="311" lly="308" urx="572" ury="320" f="1"><![CDATA[algorithm similar to those in [15], [22] that sends hashes ]]></tbox></line>
<line><tbox llx="311" lly="296" urx="573" ury="309" f="1"><![CDATA[from client to server. (These algorithms are essentially multi- ]]></tbox></line>
<line><tbox llx="311" lly="284" urx="393" ury="297" f="1"><![CDATA[round versions of ]]></tbox><tbox llx="386" lly="284" urx="421" ury="296" f="3"><![CDATA[rsync, ]]></tbox><tbox llx="414" lly="284" urx="572" ury="297" f="1"><![CDATA[which explains the similarity of our ]]></tbox></line>
<line><tbox llx="311" lly="273" urx="400" ury="285" f="1"><![CDATA[algorithm below to ]]></tbox><tbox llx="393" lly="273" urx="431" ury="284" f="3"><![CDATA[rsync.) ]]></tbox><tbox llx="424" lly="273" urx="572" ury="285" f="1"><![CDATA[In the following description, note ]]></tbox></line>
<line><tbox llx="311" lly="261" urx="572" ury="273" f="1"><![CDATA[that the first three steps are identical to the previous algorithm ]]></tbox></line>
<line><tbox llx="311" lly="249" urx="525" ury="261" f="1"><![CDATA[but with the roles of client and server exchanged. ]]></tbox></line>
<line><tbox llx="313" lly="233" urx="422" ury="245" f="1"><![CDATA[(1) The client partitions ]]></tbox><tbox llx="415" lly="233" urx="429" ury="244" f="5"><![CDATA[f ]]></tbox><tbox llx="420" lly="232" urx="438" ury="240" f="6"><![CDATA[old ]]></tbox><tbox llx="432" lly="233" urx="573" ury="245" f="1"><![CDATA[recursively into blocks from size ]]></tbox></line>
<line><tbox llx="332" lly="221" urx="346" ury="232" f="5"><![CDATA[b ]]></tbox><tbox llx="337" lly="220" urx="360" ury="228" f="6"><![CDATA[max ]]></tbox><tbox llx="354" lly="221" urx="397" ury="233" f="1"><![CDATA[down to ]]></tbox><tbox llx="390" lly="221" urx="404" ury="232" f="5"><![CDATA[b ]]></tbox><tbox llx="395" lly="220" urx="417" ury="228" f="6"><![CDATA[min ]]></tbox><tbox llx="408" lly="221" urx="572" ury="233" f="1"><![CDATA[, and for each level computes all block ]]></tbox></line>
<line><tbox llx="331" lly="209" urx="371" ury="221" f="1"><![CDATA[hashes. ]]></tbox></line>
<line><tbox llx="313" lly="197" urx="572" ury="209" f="1"><![CDATA[(2) The client applies a systematic erasure code to each level ]]></tbox></line>
<line><tbox llx="332" lly="185" urx="345" ury="196" f="5"><![CDATA[i ]]></tbox><tbox llx="337" lly="185" urx="526" ury="197" f="1"><![CDATA[of hashes except the top level, and computes ]]></tbox><tbox llx="520" lly="185" urx="538" ury="196" f="5"><![CDATA[m ]]></tbox><tbox llx="529" lly="184" urx="539" ury="192" f="6"><![CDATA[i ]]></tbox><tbox llx="533" lly="185" urx="572" ury="197" f="1"><![CDATA[erasure ]]></tbox></line>
<line><tbox llx="331" lly="173" urx="516" ury="185" f="1"><![CDATA[hashes for each level, for some appropriate ]]></tbox><tbox llx="510" lly="173" urx="528" ury="184" f="5"><![CDATA[m ]]></tbox><tbox llx="519" lly="172" urx="529" ury="180" f="6"><![CDATA[i ]]></tbox><tbox llx="524" lly="173" urx="572" ury="185" f="1"><![CDATA[discussed ]]></tbox></line>
<line><tbox llx="331" lly="161" urx="361" ury="173" f="1"><![CDATA[later. ]]></tbox></line>
<line><tbox llx="313" lly="149" urx="572" ury="161" f="1"><![CDATA[(3) In one message, the client sends all hashes at the highest ]]></tbox></line>
<line><tbox llx="331" lly="137" urx="455" ury="150" f="1"><![CDATA[level to the server, plus the ]]></tbox><tbox llx="450" lly="137" urx="469" ury="148" f="5"><![CDATA[m ]]></tbox><tbox llx="459" lly="136" urx="469" ury="144" f="6"><![CDATA[i ]]></tbox><tbox llx="465" lly="137" urx="572" ury="150" f="1"><![CDATA[erasure hashes for each ]]></tbox></line>
<line><tbox llx="331" lly="125" urx="360" ury="138" f="1"><![CDATA[level ]]></tbox><tbox llx="355" lly="125" urx="370" ury="136" f="5"><![CDATA[i. ]]></tbox></line>
<line><tbox llx="313" lly="113" urx="573" ury="126" f="1"><![CDATA[(4) The server, upon receiving the message, attempts to ]]></tbox></line>
<line><tbox llx="331" lly="102" urx="572" ury="114" f="1"><![CDATA[recover the hashes on all levels in a top-down manner, ]]></tbox></line>
<line><tbox llx="331" lly="90" urx="572" ury="102" f="1"><![CDATA[by first matching the top-level hashes. Then on the next ]]></tbox></line>
<line><tbox llx="331" lly="78" urx="360" ury="90" f="1"><![CDATA[level ]]></tbox><tbox llx="356" lly="77" urx="372" ury="88" f="5"><![CDATA[i, ]]></tbox><tbox llx="366" lly="78" urx="572" ury="90" f="1"><![CDATA[if the number of blocks without any matched ]]></tbox></line>
<line><tbox llx="331" lly="66" urx="421" ury="78" f="1"><![CDATA[ancestor is at most ]]></tbox><tbox llx="416" lly="65" urx="434" ury="76" f="5"><![CDATA[m ]]></tbox><tbox llx="425" lly="65" urx="435" ury="73" f="6"><![CDATA[i ]]></tbox><tbox llx="426" lly="66" urx="572" ury="78" f="1"><![CDATA[, the hash function is applied to ]]></tbox></line>
<pbox llx="48.00" lly="65.00" urx="573.00" ury="735.00"/></page>
<page n="10">
<line><tbox llx="68" lly="723" urx="293" ury="735" f="1"><![CDATA[all blocks that do have a matched ancestor, and the ]]></tbox><tbox llx="288" lly="723" urx="307" ury="734" f="2"><![CDATA[m ]]></tbox><tbox llx="297" lly="722" urx="307" ury="730" f="3"><![CDATA[i ]]></tbox></line>
<line><tbox llx="68" lly="711" urx="309" ury="723" f="1"><![CDATA[erasure hashes are used to recover the hashes of the other ]]></tbox></line>
<line><tbox llx="68" lly="699" urx="309" ury="712" f="1"><![CDATA[blocks. Otherwise, we stop at the previous level of hashes. ]]></tbox></line>
<line><tbox llx="50" lly="687" urx="309" ury="700" f="1"><![CDATA[(5) We now use the hashes on the lowest level that was ]]></tbox></line>
<line><tbox llx="68" lly="675" urx="310" ury="688" f="1"><![CDATA[successfully decoded, in exactly the same way they are ]]></tbox></line>
<line><tbox llx="68" lly="664" urx="107" ury="676" f="1"><![CDATA[used in ]]></tbox><tbox llx="99" lly="664" urx="131" ury="676" f="4"><![CDATA[rsync ]]></tbox><tbox llx="123" lly="664" urx="221" ury="676" f="1"><![CDATA[or in our variations of ]]></tbox><tbox llx="212" lly="664" urx="247" ury="676" f="4"><![CDATA[rsync. ]]></tbox><tbox llx="239" lly="664" urx="309" ury="676" f="1"><![CDATA[Thus, common ]]></tbox></line>
<line><tbox llx="68" lly="652" urx="309" ury="664" f="1"><![CDATA[blocks are identified and all unmatched literals are sent ]]></tbox></line>
<line><tbox llx="68" lly="640" urx="215" ury="652" f="1"><![CDATA[in compressed form to the client. ]]></tbox></line>
<line><tbox llx="48" lly="620" urx="309" ury="632" f="1"><![CDATA[If we set the parameters as in the theoretical algorithm, we ]]></tbox></line>
<line><tbox llx="48" lly="608" urx="309" ury="620" f="1"><![CDATA[can show that this algorithm achieves the same performance ]]></tbox></line>
<line><tbox llx="48" lly="596" urx="298" ury="609" f="1"><![CDATA[bounds, assuming an upper bound on the file distance ]]></tbox><tbox llx="295" lly="596" urx="310" ury="607" f="2"><![CDATA[k ]]></tbox></line>
<line><tbox llx="48" lly="584" urx="221" ury="597" f="1"><![CDATA[that can be used to choose appropriate ]]></tbox><tbox llx="216" lly="584" urx="234" ury="595" f="2"><![CDATA[m ]]></tbox><tbox llx="225" lly="583" urx="235" ury="591" f="3"><![CDATA[i ]]></tbox><tbox llx="231" lly="584" urx="309" ury="597" f="1"><![CDATA[(and making the ]]></tbox></line>
<line><tbox llx="48" lly="572" urx="309" ury="585" f="1"><![CDATA[reasonable assumption that compression does not significantly ]]></tbox></line>
<line><tbox llx="48" lly="561" urx="309" ury="573" f="1"><![CDATA[increase the size of the literals). However, even if we do ]]></tbox></line>
<line><tbox llx="48" lly="549" urx="176" ury="561" f="1"><![CDATA[not have an upper bound on ]]></tbox><tbox llx="170" lly="548" urx="188" ury="559" f="2"><![CDATA[k, ]]></tbox><tbox llx="181" lly="549" urx="309" ury="561" f="1"><![CDATA[the algorithm degrades more ]]></tbox></line>
<line><tbox llx="48" lly="537" urx="287" ury="549" f="1"><![CDATA[gracefully: While the previous algorithm fails to transmit ]]></tbox><tbox llx="280" lly="536" urx="295" ury="547" f="2"><![CDATA[f ]]></tbox><tbox llx="285" lly="536" urx="307" ury="544" f="3"><![CDATA[new ]]></tbox></line>
<line><tbox llx="48" lly="525" urx="309" ury="537" f="1"><![CDATA[if not enough erasure hashes are available, this algorithm, like ]]></tbox></line>
<line><tbox llx="48" lly="513" urx="82" ury="525" f="4"><![CDATA[rsync, ]]></tbox><tbox llx="77" lly="513" urx="201" ury="525" f="1"><![CDATA[will still correctly transmit ]]></tbox><tbox llx="197" lly="512" urx="212" ury="523" f="2"><![CDATA[f ]]></tbox><tbox llx="202" lly="512" urx="224" ury="520" f="3"><![CDATA[new ]]></tbox><tbox llx="221" lly="513" urx="309" ury="525" f="1"><![CDATA[though possibly at ]]></tbox></line>
<line><tbox llx="48" lly="501" urx="310" ury="513" f="1"><![CDATA[increased cost. In the worst case, when not enough erasure ]]></tbox></line>
<line><tbox llx="48" lly="489" urx="309" ury="501" f="1"><![CDATA[hashes are available to encode any of the lower levels, the ]]></tbox></line>
<line><tbox llx="48" lly="477" urx="249" ury="489" f="1"><![CDATA[algorithm will achieve the same performance as ]]></tbox><tbox llx="240" lly="477" urx="273" ury="489" f="4"><![CDATA[rsync ]]></tbox><tbox llx="264" lly="477" urx="309" ury="489" f="1"><![CDATA[on block ]]></tbox></line>
<line><tbox llx="48" lly="465" urx="74" ury="477" f="1"><![CDATA[size ]]></tbox><tbox llx="68" lly="465" urx="82" ury="476" f="2"><![CDATA[b ]]></tbox><tbox llx="73" lly="464" urx="96" ury="472" f="3"><![CDATA[max ]]></tbox><tbox llx="87" lly="465" urx="101" ury="477" f="1"><![CDATA[. ]]></tbox></line>
<line><tbox llx="58" lly="451" urx="210" ury="463" f="1"><![CDATA[In practice, we will usually choose ]]></tbox><tbox llx="203" lly="451" urx="217" ury="462" f="2"><![CDATA[b ]]></tbox><tbox llx="208" lly="450" urx="231" ury="458" f="3"><![CDATA[max ]]></tbox><tbox llx="226" lly="451" urx="309" ury="463" f="1"><![CDATA[to be similar to or ]]></tbox></line>
<line><tbox llx="48" lly="439" urx="232" ury="452" f="1"><![CDATA[slightly larger than the default block size of ]]></tbox><tbox llx="223" lly="439" urx="250" ury="452" f="5"><![CDATA[700 ]]></tbox><tbox llx="242" lly="439" urx="283" ury="452" f="1"><![CDATA[used by ]]></tbox><tbox llx="275" lly="439" urx="310" ury="451" f="4"><![CDATA[rsync, ]]></tbox></line>
<line><tbox llx="48" lly="427" urx="192" ury="440" f="1"><![CDATA[and then use a smaller value of ]]></tbox><tbox llx="187" lly="427" urx="201" ury="438" f="2"><![CDATA[b ]]></tbox><tbox llx="191" lly="426" urx="213" ury="434" f="3"><![CDATA[min ]]></tbox><tbox llx="209" lly="427" urx="278" ury="440" f="1"><![CDATA[maybe around ]]></tbox><tbox llx="271" lly="427" urx="298" ury="440" f="5"><![CDATA[100 ]]></tbox><tbox llx="291" lly="427" urx="309" ury="440" f="1"><![CDATA[to ]]></tbox></line>
<line><tbox llx="47" lly="415" urx="73" ury="428" f="5"><![CDATA[200 ]]></tbox><tbox llx="66" lly="416" urx="119" ury="428" f="1"><![CDATA[bytes. The ]]></tbox><tbox llx="113" lly="415" urx="131" ury="426" f="2"><![CDATA[m ]]></tbox><tbox llx="122" lly="414" urx="132" ury="422" f="3"><![CDATA[i ]]></tbox><tbox llx="126" lly="416" urx="309" ury="428" f="1"><![CDATA[for the different levels are determined as a ]]></tbox></line>
<line><tbox llx="48" lly="404" urx="89" ury="416" f="1"><![CDATA[fraction ]]></tbox><tbox llx="83" lly="403" urx="97" ury="414" f="2"><![CDATA[r ]]></tbox><tbox llx="88" lly="402" urx="98" ury="410" f="3"><![CDATA[i ]]></tbox><tbox llx="92" lly="404" urx="309" ury="416" f="1"><![CDATA[of the total number of hashes on a particular block. ]]></tbox></line>
<line><tbox llx="48" lly="392" urx="156" ury="404" f="1"><![CDATA[For example, if we have ]]></tbox><tbox llx="147" lly="391" urx="169" ury="404" f="5"><![CDATA[50 ]]></tbox><tbox llx="161" lly="392" urx="309" ury="404" f="1"><![CDATA[blocks on the second highest level ]]></tbox></line>
<line><tbox llx="48" lly="380" urx="65" ury="392" f="1"><![CDATA[(i ]]></tbox><tbox llx="57" lly="379" urx="90" ury="392" f="5"><![CDATA[=2), ]]></tbox><tbox llx="83" lly="380" urx="163" ury="392" f="1"><![CDATA[we might choose ]]></tbox><tbox llx="157" lly="379" urx="171" ury="390" f="2"><![CDATA[r ]]></tbox><tbox llx="162" lly="379" urx="173" ury="387" f="6"><![CDATA[2 ]]></tbox><tbox llx="167" lly="379" urx="202" ury="392" f="5"><![CDATA[=0.2 ]]></tbox><tbox llx="195" lly="380" urx="309" ury="392" f="1"><![CDATA[which means that we use ]]></tbox></line>
<line><tbox llx="49" lly="367" urx="68" ury="378" f="2"><![CDATA[m ]]></tbox><tbox llx="58" lly="367" urx="69" ury="375" f="6"><![CDATA[2 ]]></tbox><tbox llx="65" lly="367" urx="84" ury="381" f="5"><![CDATA[= ]]></tbox><tbox llx="80" lly="367" urx="94" ury="378" f="2"><![CDATA[r ]]></tbox><tbox llx="84" lly="367" urx="95" ury="375" f="6"><![CDATA[2 ]]></tbox><tbox llx="92" lly="360" urx="105" ury="379" f="7"><![CDATA[ ]]></tbox><tbox llx="95" lly="367" urx="144" ury="381" f="5"><![CDATA[50 = 10 ]]></tbox><tbox llx="138" lly="368" urx="309" ury="380" f="1"><![CDATA[erasure hashes on this level. Then we ]]></tbox></line>
<line><tbox llx="48" lly="356" urx="309" ury="368" f="1"><![CDATA[will be able to decode this second level successfully provided ]]></tbox></line>
<line><tbox llx="48" lly="344" urx="309" ury="356" f="1"><![CDATA[that at most 20% of the hashes on the highest level did not ]]></tbox></line>
<line><tbox llx="48" lly="332" urx="121" ury="344" f="1"><![CDATA[find a match in ]]></tbox><tbox llx="115" lly="332" urx="130" ury="342" f="2"><![CDATA[f ]]></tbox><tbox llx="121" lly="331" urx="138" ury="339" f="3"><![CDATA[old ]]></tbox><tbox llx="130" lly="332" urx="309" ury="344" f="1"><![CDATA[. Thus, by assuming some minimum rate ]]></tbox></line>
<line><tbox llx="48" lly="320" urx="309" ury="332" f="1"><![CDATA[of matches on the higher levels we can decrease the cost of ]]></tbox></line>
<line><tbox llx="48" lly="308" urx="309" ury="320" f="1"><![CDATA[hashes at the lower levels and hence afford to go to smaller ]]></tbox></line>
<line><tbox llx="48" lly="296" urx="309" ury="308" f="1"><![CDATA[block sizes on very similar files. We experimented with a ]]></tbox></line>
<line><tbox llx="48" lly="284" urx="146" ury="296" f="1"><![CDATA[number of choices of ]]></tbox><tbox llx="140" lly="284" urx="154" ury="295" f="2"><![CDATA[b ]]></tbox><tbox llx="145" lly="283" urx="168" ury="291" f="3"><![CDATA[max ]]></tbox><tbox llx="159" lly="284" urx="172" ury="296" f="1"><![CDATA[, ]]></tbox><tbox llx="167" lly="284" urx="181" ury="295" f="2"><![CDATA[b ]]></tbox><tbox llx="171" lly="283" urx="193" ury="291" f="3"><![CDATA[min ]]></tbox><tbox llx="185" lly="284" urx="232" ury="296" f="1"><![CDATA[, and the ]]></tbox><tbox llx="226" lly="284" urx="240" ury="295" f="2"><![CDATA[r ]]></tbox><tbox llx="231" lly="283" urx="241" ury="291" f="3"><![CDATA[i ]]></tbox><tbox llx="232" lly="284" urx="245" ury="296" f="1"><![CDATA[. ]]></tbox></line>
<line><tbox llx="58" lly="270" urx="309" ury="283" f="1"><![CDATA[We implemented the algorithm based on an implementation ]]></tbox></line>
<line><tbox llx="48" lly="259" urx="309" ury="271" f="1"><![CDATA[of systematic erasure codes by Rizzo, available at ]]></tbox></line>
<line><tbox llx="49" lly="246" urx="298" ury="258" f="8"><![CDATA[http://info.iet.unipi.it/#luigi/fec.html. ]]></tbox></line>
<line><tbox llx="48" lly="235" urx="309" ury="247" f="1"><![CDATA[The erasure code implementation is based on Vandermonde ]]></tbox></line>
<line><tbox llx="48" lly="223" urx="309" ury="235" f="1"><![CDATA[matrices, and achieves encoding and decoding rates of several ]]></tbox></line>
<line><tbox llx="48" lly="211" urx="309" ury="223" f="1"><![CDATA[MB per second. Given that the hashes are much smaller than ]]></tbox></line>
<line><tbox llx="48" lly="199" urx="309" ury="211" f="1"><![CDATA[the actual files, this translates to a file processing speed of ]]></tbox></line>
<line><tbox llx="48" lly="187" urx="309" ury="199" f="1"><![CDATA[tens to hundreds of MB/s. Thus, we do not expect coding to ]]></tbox></line>
<line><tbox llx="48" lly="175" urx="309" ury="187" f="1"><![CDATA[be a bottleneck in most cases. We chose the number of bits ]]></tbox></line>
<line><tbox llx="48" lly="163" urx="104" ury="175" f="1"><![CDATA[per hash as ]]></tbox><tbox llx="96" lly="163" urx="178" ury="176" f="5"><![CDATA[lg(n)+lg(y)+k ]]></tbox><tbox llx="170" lly="163" urx="193" ury="175" f="1"><![CDATA[for ]]></tbox><tbox llx="187" lly="163" urx="202" ury="174" f="2"><![CDATA[k ]]></tbox><tbox llx="193" lly="163" urx="227" ury="176" f="5"><![CDATA[=10, ]]></tbox><tbox llx="220" lly="163" urx="255" ury="175" f="1"><![CDATA[where ]]></tbox><tbox llx="249" lly="163" urx="263" ury="174" f="2"><![CDATA[y ]]></tbox><tbox llx="256" lly="163" urx="309" ury="175" f="1"><![CDATA[is the total ]]></tbox></line>
<line><tbox llx="48" lly="151" urx="309" ury="163" f="1"><![CDATA[number of hashes (top-level and erasure hashes) sent from ]]></tbox></line>
<line><tbox llx="48" lly="139" urx="121" ury="151" f="1"><![CDATA[client to server. ]]></tbox></line>
<line><tbox llx="58" lly="125" urx="309" ury="138" f="1"><![CDATA[We integrated two additional optimizations into the imple- ]]></tbox></line>
<line><tbox llx="48" lly="113" urx="309" ury="126" f="1"><![CDATA[mentation, both of which are completely orthogonal to the ]]></tbox></line>
<line><tbox llx="48" lly="102" urx="309" ury="114" f="1"><![CDATA[erasure coding approach and very simple to add. First, we ]]></tbox></line>
<line><tbox llx="48" lly="90" urx="98" ury="102" f="1"><![CDATA[integrated ]]></tbox><tbox llx="92" lly="90" urx="195" ury="102" f="4"><![CDATA[decomposable hashes, ]]></tbox><tbox llx="189" lly="90" urx="309" ury="102" f="1"><![CDATA[first proposed in [33] and ]]></tbox></line>
<line><tbox llx="48" lly="78" urx="309" ury="90" f="1"><![CDATA[recently rediscovered in [37], which allow the hash of a child ]]></tbox></line>
<line><tbox llx="48" lly="66" urx="309" ury="78" f="1"><![CDATA[block to be computed from the hashes of its parent and its ]]></tbox></line>
<line><tbox llx="311" lly="723" urx="572" ury="735" f="1"><![CDATA[sibling, halving the number of hashes transmitted on all except ]]></tbox></line>
<line><tbox llx="311" lly="711" urx="573" ury="723" f="1"><![CDATA[the top level. In particular, we apply erasure coding only to ]]></tbox></line>
<line><tbox llx="311" lly="699" urx="572" ury="712" f="1"><![CDATA[left siblings and compute the hashes of the right siblings at the ]]></tbox></line>
<line><tbox llx="311" lly="687" urx="573" ury="700" f="1"><![CDATA[server after decoding left siblings. Second, we added the half- ]]></tbox></line>
<line><tbox llx="311" lly="675" urx="572" ury="688" f="1"><![CDATA[block alignment approach from Subsection II-E. Alternatively, ]]></tbox></line>
<line><tbox llx="311" lly="664" urx="419" ury="676" f="1"><![CDATA[we could also integrate ]]></tbox><tbox llx="413" lly="664" urx="506" ury="675" f="4"><![CDATA[continuation hashes ]]></tbox><tbox llx="500" lly="664" urx="572" ury="676" f="1"><![CDATA[[37] instead of ]]></tbox></line>
<line><tbox llx="311" lly="652" urx="572" ury="664" f="1"><![CDATA[half-block alignments to get additional minor improvements, ]]></tbox></line>
<line><tbox llx="311" lly="640" urx="481" ury="652" f="1"><![CDATA[but this has not been implemented yet. ]]></tbox></line>
<line><tbox llx="311" lly="457" urx="361" ury="467" f="9"><![CDATA[Figure III.2. ]]></tbox><tbox llx="359" lly="457" urx="400" ury="467" f="10"><![CDATA[Results on ]]></tbox><tbox llx="394" lly="457" urx="413" ury="467" f="11"><![CDATA[gcc ]]></tbox><tbox llx="407" lly="457" urx="571" ury="467" f="10"><![CDATA[data with the best possible parameter settings for ]]></tbox></line>
<line><tbox llx="311" lly="448" urx="461" ury="458" f="10"><![CDATA[the following methods (from left to right): ]]></tbox><tbox llx="456" lly="448" urx="483" ury="458" f="11"><![CDATA[rsync, ]]></tbox><tbox llx="478" lly="448" urx="531" ury="458" f="10"><![CDATA[the optimized ]]></tbox><tbox llx="526" lly="448" urx="552" ury="458" f="11"><![CDATA[rsync ]]></tbox><tbox llx="547" lly="448" urx="571" ury="458" f="10"><![CDATA[from ]]></tbox></line>
<line><tbox llx="311" lly="439" urx="571" ury="449" f="10"><![CDATA[Subsection II-C, the erasure-code approach with decomposable hashes, the ]]></tbox></line>
<line><tbox llx="311" lly="430" urx="570" ury="440" f="10"><![CDATA[half-block alignment approach, the erasure-code approach with decomposable ]]></tbox></line>
<line><tbox llx="311" lly="421" urx="570" ury="431" f="10"><![CDATA[hashes and half-block alignment, and the optimized multi-round approach ]]></tbox></line>
<line><tbox llx="311" lly="412" urx="571" ury="422" f="10"><![CDATA[from [37]. Results on the left are for all files, while results on the right are ]]></tbox></line>
<line><tbox llx="311" lly="403" urx="449" ury="413" f="10"><![CDATA[only for changed files in the collection. ]]></tbox></line>
<line><tbox llx="311" lly="210" urx="361" ury="220" f="9"><![CDATA[Figure III.3. ]]></tbox><tbox llx="359" lly="210" urx="401" ury="220" f="10"><![CDATA[Results on ]]></tbox><tbox llx="395" lly="210" urx="423" ury="220" f="11"><![CDATA[emacs ]]></tbox><tbox llx="417" lly="210" urx="571" ury="220" f="10"><![CDATA[data with the best possible parameter settings ]]></tbox></line>
<line><tbox llx="311" lly="201" urx="466" ury="211" f="10"><![CDATA[for the following methods (from left to right): ]]></tbox><tbox llx="460" lly="201" urx="488" ury="211" f="11"><![CDATA[rsync, ]]></tbox><tbox llx="481" lly="201" urx="534" ury="211" f="10"><![CDATA[the optimized ]]></tbox><tbox llx="527" lly="201" urx="553" ury="211" f="11"><![CDATA[rsync ]]></tbox><tbox llx="547" lly="201" urx="571" ury="211" f="10"><![CDATA[from ]]></tbox></line>
<line><tbox llx="311" lly="192" urx="571" ury="202" f="10"><![CDATA[Subsection II-C, the erasure-code approach with decomposable hashes, the ]]></tbox></line>
<line><tbox llx="311" lly="183" urx="570" ury="193" f="10"><![CDATA[half-block alignment approach, the erasure-code approach with decomposable ]]></tbox></line>
<line><tbox llx="311" lly="174" urx="570" ury="184" f="10"><![CDATA[hashes and half-block alignment, and the optimized multi-round approach ]]></tbox></line>
<line><tbox llx="311" lly="165" urx="571" ury="175" f="10"><![CDATA[from [37]. Results on the left are for all files, while results on the right are ]]></tbox></line>
<line><tbox llx="311" lly="156" urx="491" ury="166" f="10"><![CDATA[only for changed files in the collection. Note that the ]]></tbox><tbox llx="487" lly="156" urx="515" ury="165" f="12"><![CDATA[y-axis ]]></tbox><tbox llx="508" lly="156" urx="551" ury="166" f="10"><![CDATA[starts from ]]></tbox><tbox llx="546" lly="156" urx="571" ury="165" f="13"><![CDATA[2000 ]]></tbox></line>
<line><tbox llx="311" lly="147" urx="333" ury="157" f="10"><![CDATA[KB. ]]></tbox></line>
<line><tbox llx="321" lly="125" urx="573" ury="138" f="14"><![CDATA[In Figures III.2 and III.3 we show experimental results ]]></tbox></line>
<line><tbox llx="311" lly="113" urx="572" ury="126" f="14"><![CDATA[comparing the erasure-code approach to the various optimized ]]></tbox></line>
<line><tbox llx="311" lly="102" urx="572" ury="114" f="14"><![CDATA[methods discussed in this paper. For each method, we show the ]]></tbox></line>
<line><tbox llx="311" lly="90" urx="573" ury="102" f="14"><![CDATA[best result that we obtained. The result from [37] essentially ]]></tbox></line>
<line><tbox llx="311" lly="78" urx="572" ury="90" f="14"><![CDATA[provides a upper bound on what we can realistically hope ]]></tbox></line>
<line><tbox llx="311" lly="66" urx="572" ury="78" f="14"><![CDATA[to gain with a single-round approach, barring further break- ]]></tbox></line>
<pbox llx="47.00" lly="66.00" urx="573.00" ury="735.00"/></page>
<page n="11">
<line><tbox llx="48" lly="723" urx="309" ury="735" f="1"><![CDATA[throughs in techniques. We see that the erasure-code based ]]></tbox></line>
<line><tbox llx="48" lly="711" urx="145" ury="723" f="1"><![CDATA[approach does about ]]></tbox><tbox llx="138" lly="711" urx="168" ury="724" f="2"><![CDATA[10% ]]></tbox><tbox llx="162" lly="711" urx="309" ury="723" f="1"><![CDATA[better than the other approaches ]]></tbox></line>
<line><tbox llx="48" lly="699" urx="68" ury="712" f="1"><![CDATA[on ]]></tbox><tbox llx="61" lly="699" urx="88" ury="711" f="3"><![CDATA[gcc, ]]></tbox><tbox llx="81" lly="699" urx="279" ury="712" f="1"><![CDATA[but provides only negligible improvements on ]]></tbox><tbox llx="271" lly="699" urx="310" ury="711" f="3"><![CDATA[emacs. ]]></tbox></line>
<line><tbox llx="48" lly="687" urx="186" ury="700" f="1"><![CDATA[Recall that the two versions of ]]></tbox><tbox llx="180" lly="687" urx="204" ury="699" f="3"><![CDATA[gcc ]]></tbox><tbox llx="197" lly="687" urx="309" ury="700" f="1"><![CDATA[are more similar to each ]]></tbox></line>
<line><tbox llx="48" lly="675" urx="117" ury="688" f="1"><![CDATA[other than the ]]></tbox><tbox llx="111" lly="675" urx="147" ury="687" f="3"><![CDATA[emacs ]]></tbox><tbox llx="141" lly="675" urx="291" ury="688" f="1"><![CDATA[versions. The best block size for ]]></tbox><tbox llx="285" lly="675" urx="310" ury="687" f="3"><![CDATA[gcc ]]></tbox></line>
<line><tbox llx="48" lly="664" urx="154" ury="676" f="1"><![CDATA[was fairly large, around ]]></tbox><tbox llx="145" lly="663" urx="180" ury="676" f="2"><![CDATA[700% ]]></tbox><tbox llx="172" lly="664" urx="309" ury="676" f="1"><![CDATA[bytes, since most matches were ]]></tbox></line>
<line><tbox llx="48" lly="652" urx="309" ury="664" f="1"><![CDATA[already found at such large block sizes and the cost of using ]]></tbox></line>
<line><tbox llx="48" lly="640" urx="309" ury="652" f="1"><![CDATA[smaller blocks would outweigh any benefits due to additional ]]></tbox></line>
<line><tbox llx="48" lly="628" urx="309" ury="640" f="1"><![CDATA[matches. The erasure-code approach allows us to effectively ]]></tbox></line>
<line><tbox llx="48" lly="616" urx="144" ury="628" f="1"><![CDATA[use smaller blocks in ]]></tbox><tbox llx="137" lly="616" urx="161" ury="628" f="3"><![CDATA[gcc ]]></tbox><tbox llx="154" lly="616" urx="309" ury="628" f="1"><![CDATA[without paying the full cost of each ]]></tbox></line>
<line><tbox llx="48" lly="604" urx="295" ury="616" f="1"><![CDATA[block, since many matches already occur at higher levels. ]]></tbox></line>
<line><tbox llx="58" lly="590" urx="309" ury="602" f="1"><![CDATA[We also show results for both collections were we only ]]></tbox></line>
<line><tbox llx="48" lly="578" urx="309" ury="590" f="1"><![CDATA[consider files that differ in the two versions. The motivation for ]]></tbox></line>
<line><tbox llx="48" lly="566" urx="309" ury="578" f="1"><![CDATA[this is that even in scenarios that use a single-round protocol, ]]></tbox></line>
<line><tbox llx="48" lly="554" urx="309" ury="566" f="1"><![CDATA[there is often an extra initial round of communication where ]]></tbox></line>
<line><tbox llx="48" lly="542" urx="309" ury="555" f="1"><![CDATA[client and server exchange lists of file names, last modification ]]></tbox></line>
<line><tbox llx="48" lly="530" urx="309" ury="543" f="1"><![CDATA[dates, and possibly file checksums in order to identify the ]]></tbox></line>
<line><tbox llx="48" lly="518" urx="309" ury="531" f="1"><![CDATA[files that need to be synchronized. As we see the results ]]></tbox></line>
<line><tbox llx="48" lly="507" urx="309" ury="519" f="1"><![CDATA[are not substantially different for this case. We note that one ]]></tbox></line>
<line><tbox llx="48" lly="495" urx="309" ury="507" f="1"><![CDATA[problem with the erasure-based approach is how to select the ]]></tbox></line>
<line><tbox llx="48" lly="483" urx="309" ury="495" f="1"><![CDATA[optimum setting of the parameters, i.e., the block sizes and the ]]></tbox></line>
<line><tbox llx="48" lly="471" urx="99" ury="483" f="1"><![CDATA[thresholds ]]></tbox><tbox llx="94" lly="470" urx="108" ury="481" f="4"><![CDATA[r ]]></tbox><tbox llx="99" lly="470" urx="109" ury="478" f="5"><![CDATA[i ]]></tbox><tbox llx="100" lly="471" urx="309" ury="483" f="1"><![CDATA[. We used for each method the best setting that ]]></tbox></line>
<line><tbox llx="48" lly="459" urx="309" ury="471" f="1"><![CDATA[we could find for each collection; this maybe gives erasure ]]></tbox></line>
<line><tbox llx="48" lly="447" urx="309" ury="459" f="1"><![CDATA[coding an advantage since there are more parameters and thus ]]></tbox></line>
<line><tbox llx="48" lly="435" urx="309" ury="447" f="1"><![CDATA[more knobs that we can tweak to optimize performance. It is ]]></tbox></line>
<line><tbox llx="48" lly="423" urx="309" ury="435" f="1"><![CDATA[an open problem to come up with good rules for choosing ]]></tbox></line>
<line><tbox llx="48" lly="411" urx="309" ury="423" f="1"><![CDATA[parameters, and possibly one could use an extra initial round ]]></tbox></line>
<line><tbox llx="48" lly="399" urx="309" ury="411" f="1"><![CDATA[to exchange statistics that allow a good choice of parameters ]]></tbox></line>
<line><tbox llx="48" lly="387" urx="110" ury="399" f="1"><![CDATA[for each file. ]]></tbox></line>
<line><tbox llx="58" lly="373" urx="309" ury="386" f="1"><![CDATA[The erasure-based approach presented here allows for a ]]></tbox></line>
<line><tbox llx="48" lly="362" urx="309" ury="374" f="1"><![CDATA[number of additional optimizations and could be used to ]]></tbox></line>
<line><tbox llx="48" lly="350" urx="309" ury="362" f="1"><![CDATA[design other new algorithms. For example, one could design ]]></tbox></line>
<line><tbox llx="48" lly="338" urx="309" ury="350" f="1"><![CDATA[protocols with two or more round-trips that first send a very ]]></tbox></line>
<line><tbox llx="48" lly="326" urx="309" ury="338" f="1"><![CDATA[small number of erasure hashes, and then send additional ]]></tbox></line>
<line><tbox llx="48" lly="314" urx="309" ury="326" f="1"><![CDATA[erasure hashes in the next round if needed to successfully ]]></tbox></line>
<line><tbox llx="48" lly="302" urx="309" ury="314" f="1"><![CDATA[decode the lower levels. Thus, instead of processing one ]]></tbox></line>
<line><tbox llx="48" lly="290" urx="309" ury="302" f="1"><![CDATA[level of blocks in each round, as the previous multi-round ]]></tbox></line>
<line><tbox llx="48" lly="278" urx="309" ury="290" f="1"><![CDATA[approaches do, this approach would simultaneously add redun- ]]></tbox></line>
<line><tbox llx="48" lly="266" urx="309" ury="278" f="1"><![CDATA[dancy to several levels until decoding succeeds on the other ]]></tbox></line>
<line><tbox llx="48" lly="254" urx="309" ury="266" f="1"><![CDATA[side. This idea could potentially also be generalized into a ]]></tbox></line>
<line><tbox llx="48" lly="242" urx="121" ury="254" f="3"><![CDATA[digital fountain ]]></tbox><tbox llx="113" lly="242" urx="309" ury="254" f="1"><![CDATA[approach [5] for broadcasting updated content ]]></tbox></line>
<line><tbox llx="48" lly="230" urx="249" ury="242" f="1"><![CDATA[to clients that may have different old versions. ]]></tbox></line>
<line><tbox llx="58" lly="216" urx="309" ury="229" f="1"><![CDATA[One could also try to combine erasure coding with error ]]></tbox></line>
<line><tbox llx="48" lly="205" urx="309" ury="217" f="1"><![CDATA[correcting codes where the positions of corrupted symbols are ]]></tbox></line>
<line><tbox llx="48" lly="193" urx="309" ury="205" f="1"><![CDATA[unknown to the decoder. The current algorithm chooses the ]]></tbox></line>
<line><tbox llx="48" lly="181" urx="309" ury="193" f="1"><![CDATA[bit strength of the hashes such that it is unlikely that there ]]></tbox></line>
<line><tbox llx="48" lly="169" urx="309" ury="181" f="1"><![CDATA[are any false matches at all in the entire file. This could be ]]></tbox></line>
<line><tbox llx="48" lly="157" urx="309" ury="169" f="1"><![CDATA[relaxed to a bit strength such that most matches are correct ]]></tbox></line>
<line><tbox llx="48" lly="145" urx="309" ury="157" f="1"><![CDATA[(even though there are likely to be some false matches in a ]]></tbox></line>
<line><tbox llx="48" lly="133" urx="309" ury="145" f="1"><![CDATA[larger file), if we use an error correcting code that can correct ]]></tbox></line>
<line><tbox llx="48" lly="121" urx="309" ury="133" f="1"><![CDATA[a few corrupted hashes due to false matches at the parent level. ]]></tbox></line>
<line><tbox llx="48" lly="109" urx="309" ury="121" f="1"><![CDATA[Thus, in this scenario a number of hashes would be known to ]]></tbox></line>
<line><tbox llx="48" lly="97" urx="309" ury="109" f="1"><![CDATA[be lost (erasure case), while a few others in unknown positions ]]></tbox></line>
<line><tbox llx="48" lly="85" urx="309" ury="97" f="1"><![CDATA[would be corrupted (ECC case). We believe there are other ]]></tbox></line>
<line><tbox llx="48" lly="73" urx="309" ury="85" f="1"><![CDATA[interesting protocols that can be designed with our approach. ]]></tbox></line>
<line><tbox llx="392" lly="723" urx="461" ury="735" f="1"><![CDATA[IV. RELATED ]]></tbox><tbox llx="453" lly="723" urx="492" ury="735" f="7"><![CDATA[WORK ]]></tbox></line>
<line><tbox llx="321" lly="707" urx="572" ury="719" f="9"><![CDATA[In the following, we give a brief summary of related work. ]]></tbox></line>
<line><tbox llx="311" lly="695" urx="337" ury="707" f="9"><![CDATA[The ]]></tbox><tbox llx="330" lly="695" urx="363" ury="707" f="3"><![CDATA[rsync ]]></tbox><tbox llx="356" lly="695" urx="572" ury="707" f="9"><![CDATA[algorithm proposed by Tridgell and MacKerras is ]]></tbox></line>
<line><tbox llx="311" lly="683" urx="572" ury="695" f="9"><![CDATA[described in [39], [41], and is the basis of the very widely ]]></tbox></line>
<line><tbox llx="311" lly="671" urx="340" ury="683" f="9"><![CDATA[used ]]></tbox><tbox llx="332" lly="671" urx="364" ury="683" f="3"><![CDATA[rsync ]]></tbox><tbox llx="356" lly="671" urx="572" ury="683" f="9"><![CDATA[open source tool. There are a number of theoretical ]]></tbox></line>
<line><tbox llx="311" lly="659" urx="572" ury="671" f="9"><![CDATA[studies of the file synchronization problem [8], [7], [23], ]]></tbox></line>
<line><tbox llx="311" lly="647" urx="572" ury="659" f="9"><![CDATA[[24]. In particular, Orlitsky [23], [24] presents almost tight ]]></tbox></line>
<line><tbox llx="311" lly="635" urx="572" ury="647" f="9"><![CDATA[bounds for the problem with varying numbers of communica- ]]></tbox></line>
<line><tbox llx="311" lly="623" urx="572" ury="635" f="9"><![CDATA[tion phases, under some assumptions about the assumed file ]]></tbox></line>
<line><tbox llx="311" lly="611" urx="572" ury="623" f="9"><![CDATA[distance metric. As explained, these results typically require ]]></tbox></line>
<line><tbox llx="311" lly="599" urx="572" ury="611" f="9"><![CDATA[exponential time for decoding; while this is allowable under ]]></tbox></line>
<line><tbox llx="311" lly="587" urx="573" ury="599" f="9"><![CDATA[the standard model for communication complexity [14], it ]]></tbox></line>
<line><tbox llx="311" lly="575" urx="572" ury="587" f="9"><![CDATA[makes the algorithms impractical. Within this framework, [26] ]]></tbox></line>
<line><tbox llx="311" lly="563" urx="572" ury="575" f="9"><![CDATA[discusses a relationship between Error Correcting Codes and ]]></tbox></line>
<line><tbox llx="311" lly="551" urx="404" ury="563" f="9"><![CDATA[file synchronization. ]]></tbox></line>
<line><tbox llx="321" lly="538" urx="572" ury="550" f="9"><![CDATA[Various practical multi-round algorithms are proposed in ]]></tbox></line>
<line><tbox llx="311" lly="526" urx="572" ury="538" f="9"><![CDATA[[33], [8], [7], [10], [25], [15], [37], [22]. These algorithms are ]]></tbox></line>
<line><tbox llx="311" lly="514" urx="573" ury="526" f="9"><![CDATA[based on recursive partitioning of unmatched blocks, mostly ]]></tbox></line>
<line><tbox llx="311" lly="502" urx="573" ury="514" f="9"><![CDATA[in a breadth-first manner with the exception of [10]. The al- ]]></tbox></line>
<line><tbox llx="311" lly="490" urx="572" ury="502" f="9"><![CDATA[gorithms in [15], [22] send hashes from client to server, while ]]></tbox></line>
<line><tbox llx="311" lly="478" urx="572" ury="490" f="9"><![CDATA[the others send hashes in the other direction. Experimental ]]></tbox></line>
<line><tbox llx="311" lly="466" urx="573" ury="478" f="9"><![CDATA[results for multi-round algorithms are provided in [15], [25], ]]></tbox></line>
<line><tbox llx="311" lly="454" urx="363" ury="466" f="9"><![CDATA[[37], [22]. ]]></tbox></line>
<line><tbox llx="321" lly="440" urx="572" ury="453" f="9"><![CDATA[Some available open source tools for delta compression ]]></tbox></line>
<line><tbox llx="311" lly="429" urx="572" ury="441" f="9"><![CDATA[are described in [13], [16], [38], and an overview of delta ]]></tbox></line>
<line><tbox llx="311" lly="417" urx="572" ury="429" f="9"><![CDATA[compression and file synchronization techniques and their ]]></tbox></line>
<line><tbox llx="311" lly="405" urx="572" ury="417" f="9"><![CDATA[applications is given in [36]. Note that delta compression can ]]></tbox></line>
<line><tbox llx="311" lly="393" urx="572" ury="405" f="9"><![CDATA[be seen as a special case of file synchronization where the ]]></tbox></line>
<line><tbox llx="311" lly="381" urx="476" ury="393" f="9"><![CDATA[outdated file is known to the encoder. ]]></tbox></line>
<line><tbox llx="321" lly="367" urx="572" ury="379" f="9"><![CDATA[A number of authors have studied problems related to ]]></tbox></line>
<line><tbox llx="311" lly="355" urx="572" ury="367" f="9"><![CDATA[identifying disk pages, files, or data records that have been ]]></tbox></line>
<line><tbox llx="311" lly="343" urx="572" ury="355" f="9"><![CDATA[changed or added or deleted, or that differ between two or ]]></tbox></line>
<line><tbox llx="311" lly="331" urx="573" ury="343" f="9"><![CDATA[more replicas; see, e.g., [1], [4], [17], [18], [19], [20], [27], ]]></tbox></line>
<line><tbox llx="311" lly="319" urx="572" ury="331" f="9"><![CDATA[[33]. Common approaches for these problems are based on ]]></tbox></line>
<line><tbox llx="311" lly="307" urx="572" ury="320" f="9"><![CDATA[hashing or coding techniques. The problem setup differs from ]]></tbox></line>
<line><tbox llx="311" lly="295" urx="572" ury="308" f="9"><![CDATA[ours in that data is assumed to be partitioned into fixed units ]]></tbox></line>
<line><tbox llx="311" lly="283" urx="572" ury="296" f="9"><![CDATA[such as pages, records, or files, that are treated as atomic. ]]></tbox></line>
<line><tbox llx="311" lly="272" urx="405" ury="284" f="9"><![CDATA[Recent work on the ]]></tbox><tbox llx="399" lly="272" urx="518" ury="284" f="3"><![CDATA[set reconciliation problem ]]></tbox><tbox llx="512" lly="272" urx="573" ury="284" f="9"><![CDATA[in [20], [2], ]]></tbox></line>
<line><tbox llx="311" lly="260" urx="572" ury="272" f="9"><![CDATA[[35] also falls into this category. Very recent independent ]]></tbox></line>
<line><tbox llx="311" lly="248" urx="573" ury="260" f="9"><![CDATA[work by Chauhan and Trachtenberg [6] shows how to use ]]></tbox></line>
<line><tbox llx="311" lly="236" urx="538" ury="248" f="9"><![CDATA[set reconciliation techniques for file synchronization. ]]></tbox></line>
<line><tbox llx="321" lly="222" urx="466" ury="234" f="9"><![CDATA[Hash-based techniques similar to ]]></tbox><tbox llx="458" lly="222" urx="491" ury="234" f="3"><![CDATA[rsync ]]></tbox><tbox llx="483" lly="222" urx="572" ury="234" f="9"><![CDATA[have been explored ]]></tbox></line>
<line><tbox llx="311" lly="210" urx="572" ury="222" f="9"><![CDATA[by the OS and Systems community for purposes such as ]]></tbox></line>
<line><tbox llx="311" lly="198" urx="572" ury="210" f="9"><![CDATA[compression of network traffic [34], distributed file systems ]]></tbox></line>
<line><tbox llx="311" lly="186" urx="573" ury="198" f="9"><![CDATA[[21], distributed backup [9], and web caching [30]. These ]]></tbox></line>
<line><tbox llx="311" lly="174" urx="573" ury="186" f="9"><![CDATA[techniques use string fingerprinting techniques [12] to partition ]]></tbox></line>
<line><tbox llx="311" lly="162" urx="552" ury="174" f="9"><![CDATA[a data stream into blocks, as we did in Subsection II-D. ]]></tbox></line>
<line><tbox llx="348" lly="142" urx="436" ury="154" f="9"><![CDATA[V. CONCLUSIONS ]]></tbox><tbox llx="428" lly="143" urx="455" ury="152" f="10"><![CDATA[AND ]]></tbox><tbox llx="449" lly="142" urx="483" ury="154" f="11"><![CDATA[OPEN ]]></tbox><tbox llx="475" lly="142" urx="536" ury="154" f="13"><![CDATA[QUESTIONS ]]></tbox></line>
<line><tbox llx="321" lly="125" urx="573" ury="138" f="15"><![CDATA[In this paper, we have studied single-round protocols for ]]></tbox></line>
<line><tbox llx="311" lly="113" urx="572" ury="126" f="15"><![CDATA[file synchronization. Our main contribution has been a new ]]></tbox></line>
<line><tbox llx="311" lly="102" urx="572" ury="114" f="15"><![CDATA[approach based on the use of erasure codes. Using this ap- ]]></tbox></line>
<line><tbox llx="311" lly="90" urx="572" ury="102" f="15"><![CDATA[proach, we have derived a single-round protocol that is feasible ]]></tbox></line>
<line><tbox llx="311" lly="78" urx="572" ury="90" f="15"><![CDATA[and communication-efficient with respect to a common file ]]></tbox></line>
<line><tbox llx="311" lly="66" urx="572" ury="78" f="15"><![CDATA[distance measure, and another protocol that shows promising ]]></tbox></line>
<pbox llx="48.00" lly="66.00" urx="573.00" ury="735.00"/></page>
<page n="12">
<line><tbox llx="48" lly="723" urx="135" ury="735" f="1"><![CDATA[improvements over ]]></tbox><tbox llx="127" lly="723" urx="159" ury="735" f="2"><![CDATA[rsync ]]></tbox><tbox llx="151" lly="723" urx="309" ury="735" f="1"><![CDATA[in experiments. We expect additional ]]></tbox></line>
<line><tbox llx="48" lly="711" urx="309" ury="723" f="1"><![CDATA[slight gains once we fully optimize the implementation and ]]></tbox></line>
<line><tbox llx="48" lly="699" urx="309" ury="712" f="1"><![CDATA[parameter settings. We hope to make a stable and high- ]]></tbox></line>
<line><tbox llx="48" lly="687" urx="309" ury="700" f="1"><![CDATA[performance version of the new practical algorithm available ]]></tbox></line>
<line><tbox llx="48" lly="675" urx="309" ury="688" f="1"><![CDATA[in the near future, as part of a library of file synchronization ]]></tbox></line>
<line><tbox llx="48" lly="664" urx="309" ury="676" f="1"><![CDATA[operations. We expect that our approach can be used to derive ]]></tbox></line>
<line><tbox llx="48" lly="652" urx="267" ury="664" f="1"><![CDATA[other interesting single- and multi-round protocols. ]]></tbox></line>
<line><tbox llx="58" lly="638" urx="309" ury="650" f="1"><![CDATA[It would be interesting to explore the trade-off between ]]></tbox></line>
<line><tbox llx="48" lly="626" urx="309" ury="638" f="1"><![CDATA[bandwidth consumption and the number of round-trips. We ]]></tbox></line>
<line><tbox llx="48" lly="614" urx="309" ury="626" f="1"><![CDATA[suspect that an approach with two or three rounds might do ]]></tbox></line>
<line><tbox llx="48" lly="602" urx="309" ury="614" f="1"><![CDATA[significantly better than the single-round approaches in this ]]></tbox></line>
<line><tbox llx="48" lly="590" urx="309" ury="602" f="1"><![CDATA[paper. Closely related to this problem is how to adaptively ]]></tbox></line>
<line><tbox llx="48" lly="578" urx="309" ury="590" f="1"><![CDATA[choose the best algorithm and parameter setting for a given ]]></tbox></line>
<line><tbox llx="48" lly="566" urx="309" ury="578" f="1"><![CDATA[pair of files, say by exchanging samples or other statistics ]]></tbox></line>
<line><tbox llx="48" lly="554" urx="309" ury="566" f="1"><![CDATA[at the start of the synchronization. In addition, there are ]]></tbox></line>
<line><tbox llx="48" lly="542" urx="309" ury="555" f="1"><![CDATA[a number of interesting open theoretical questions on file ]]></tbox></line>
<line><tbox llx="48" lly="530" urx="309" ury="543" f="1"><![CDATA[synchronization problems. The current communication bounds ]]></tbox></line>
<line><tbox llx="48" lly="518" urx="309" ury="531" f="1"><![CDATA[for feasible protocols are still a logarithmic factor from the ]]></tbox></line>
<line><tbox llx="48" lly="507" urx="309" ury="519" f="1"><![CDATA[lower bounds for most interesting distance metrics, even for ]]></tbox></line>
<line><tbox llx="48" lly="495" urx="149" ury="507" f="1"><![CDATA[multi-round protocols. ]]></tbox></line>
<line><tbox llx="127" lly="474" urx="230" ury="486" f="1"><![CDATA[ACKNOWLEDGMENTS ]]></tbox></line>
<line><tbox llx="58" lly="458" urx="309" ury="470" f="4"><![CDATA[This work was supported by NSF CAREER Award CCR- ]]></tbox></line>
<line><tbox llx="48" lly="446" urx="309" ury="458" f="4"><![CDATA[0093400, NSF ITR Awards CNS-0325777 and IDM-0205647, ]]></tbox></line>
<line><tbox llx="48" lly="434" urx="309" ury="446" f="4"><![CDATA[and the Wireless Internet Center for Advanced Technology ]]></tbox></line>
<line><tbox llx="48" lly="422" urx="205" ury="434" f="4"><![CDATA[(WICAT) at Polytechnic University. ]]></tbox></line>
<line><tbox llx="145" lly="402" urx="212" ury="414" f="4"><![CDATA[REFERENCES ]]></tbox></line>
<line><tbox llx="52" lly="387" urx="307" ury="397" f="5"><![CDATA[[1] K. Abdel-Ghaffar and A. El Abbadi. An optimal strategy for comparing ]]></tbox></line>
<line><tbox llx="66" lly="378" urx="111" ury="388" f="5"><![CDATA[file copies. ]]></tbox><tbox llx="110" lly="378" urx="308" ury="388" f="6"><![CDATA[IEEE Transactions on Parallel and Distributed Systems, ]]></tbox></line>
<line><tbox llx="66" lly="369" urx="160" ury="379" f="5"><![CDATA[5(1):87--93, January 1994. ]]></tbox></line>
<line><tbox llx="52" lly="360" urx="308" ury="370" f="5"><![CDATA[[2] S. Agarwal, D. Starobinski, and A. Trachtenberg. On the scalability of ]]></tbox></line>
<line><tbox llx="66" lly="351" urx="283" ury="361" f="5"><![CDATA[data synchronization protocols for PDAs and mobile devices. ]]></tbox><tbox llx="282" lly="351" urx="308" ury="361" f="6"><![CDATA[IEEE ]]></tbox></line>
<line><tbox llx="66" lly="342" urx="308" ury="352" f="6"><![CDATA[Network Magazine, special issue on Scalability in Communication ]]></tbox></line>
<line><tbox llx="66" lly="333" urx="107" ury="343" f="6"><![CDATA[Networks, ]]></tbox><tbox llx="101" lly="333" urx="144" ury="343" f="5"><![CDATA[July 2002. ]]></tbox></line>
<line><tbox llx="52" lly="324" urx="288" ury="334" f="5"><![CDATA[[3] S. Balasubramaniam and B. Pierce. What is a file synchronizer? In ]]></tbox><tbox llx="282" lly="324" urx="308" ury="334" f="6"><![CDATA[Proc. ]]></tbox></line>
<line><tbox llx="66" lly="315" urx="227" ury="325" f="6"><![CDATA[of the ACM/IEEE MOBICOM'98 Conference, ]]></tbox><tbox llx="222" lly="315" urx="307" ury="325" f="5"><![CDATA[pages 98--108, October ]]></tbox></line>
<line><tbox llx="66" lly="307" urx="93" ury="316" f="5"><![CDATA[1998. ]]></tbox></line>
<line><tbox llx="52" lly="298" urx="307" ury="307" f="5"><![CDATA[[4] D. Barbara and R. Lipton. A class of randomized strategies for low- ]]></tbox></line>
<line><tbox llx="66" lly="289" urx="180" ury="298" f="5"><![CDATA[cost comparison of file copies. ]]></tbox><tbox llx="179" lly="289" urx="308" ury="298" f="6"><![CDATA[IEEE Transactions on Parallel and ]]></tbox></line>
<line><tbox llx="66" lly="280" urx="141" ury="289" f="6"><![CDATA[Distributed Systems, ]]></tbox><tbox llx="135" lly="280" urx="229" ury="290" f="5"><![CDATA[2(2):160--170, April 1991. ]]></tbox></line>
<line><tbox llx="52" lly="271" urx="213" ury="281" f="5"><![CDATA[[5] J. Byers, M. Luby, and M. Mitzenmacher. ]]></tbox><tbox llx="209" lly="271" urx="307" ury="281" f="5"><![CDATA[A digital fountain approach ]]></tbox></line>
<line><tbox llx="66" lly="262" urx="201" ury="272" f="5"><![CDATA[to the reliable distribution of bulk data. ]]></tbox><tbox llx="195" lly="262" urx="308" ury="271" f="6"><![CDATA[IEEE Journal on Selected Areas ]]></tbox></line>
<line><tbox llx="66" lly="253" urx="140" ury="262" f="6"><![CDATA[in Communications, ]]></tbox><tbox llx="134" lly="253" urx="250" ury="263" f="5"><![CDATA[pages 1528--1540, October 2002. ]]></tbox></line>
<line><tbox llx="52" lly="244" urx="186" ury="254" f="5"><![CDATA[[6] V. Chauhan and A. Trachtenberg. ]]></tbox><tbox llx="182" lly="244" urx="278" ury="254" f="5"><![CDATA[Reconciliation puzzles. In ]]></tbox><tbox llx="273" lly="244" urx="308" ury="254" f="6"><![CDATA[Proc. of ]]></tbox></line>
<line><tbox llx="66" lly="235" urx="183" ury="245" f="6"><![CDATA[the IEEE GlobeCom Conference, ]]></tbox><tbox llx="178" lly="235" urx="275" ury="245" f="5"><![CDATA[November 2004. to appear. ]]></tbox></line>
<line><tbox llx="52" lly="226" urx="117" ury="236" f="5"><![CDATA[[7] G. Cormode. ]]></tbox><tbox llx="114" lly="226" urx="229" ury="236" f="6"><![CDATA[Sequence Distance Embeddings. ]]></tbox><tbox llx="225" lly="226" urx="308" ury="236" f="5"><![CDATA[PhD thesis, University ]]></tbox></line>
<line><tbox llx="66" lly="217" urx="163" ury="227" f="5"><![CDATA[of Warwick, January 2003. ]]></tbox></line>
<line><tbox llx="52" lly="208" urx="307" ury="218" f="5"><![CDATA[[8] G. Cormode, M. Paterson, S. Sahinalp, and U. Vishkin. Communication ]]></tbox></line>
<line><tbox llx="66" lly="199" urx="190" ury="209" f="5"><![CDATA[complexity of document exchange. ]]></tbox><tbox llx="186" lly="199" urx="201" ury="209" f="5"><![CDATA[In ]]></tbox><tbox llx="196" lly="199" urx="308" ury="209" f="6"><![CDATA[Proc. of the ACM--SIAM Symp. ]]></tbox></line>
<line><tbox llx="66" lly="190" urx="152" ury="200" f="6"><![CDATA[on Discrete Algorithms, ]]></tbox><tbox llx="147" lly="190" urx="201" ury="200" f="5"><![CDATA[January 2000. ]]></tbox></line>
<line><tbox llx="52" lly="181" urx="307" ury="191" f="5"><![CDATA[[9] L. Cox, C. Murray, and B. Noble. Pastiche: Making backup cheap ]]></tbox></line>
<line><tbox llx="66" lly="172" urx="116" ury="182" f="5"><![CDATA[and easy. In ]]></tbox><tbox llx="111" lly="172" urx="308" ury="182" f="6"><![CDATA[Proc. of the 5th Symp. on Operating System Design and ]]></tbox></line>
<line><tbox llx="66" lly="163" urx="127" ury="173" f="6"><![CDATA[Implementation, ]]></tbox><tbox llx="121" lly="163" urx="183" ury="173" f="5"><![CDATA[December 2002. ]]></tbox></line>
<line><tbox llx="48" lly="154" urx="307" ury="164" f="5"><![CDATA[[10] A. Evfimievski. A probabilistic algorithm for updating files over a ]]></tbox></line>
<line><tbox llx="66" lly="145" urx="151" ury="155" f="5"><![CDATA[communication link. In ]]></tbox><tbox llx="145" lly="145" urx="308" ury="155" f="6"><![CDATA[Proc. of the 9th Annual ACM-SIAM Symposium ]]></tbox></line>
<line><tbox llx="66" lly="136" urx="152" ury="146" f="6"><![CDATA[on Discrete Algorithms, ]]></tbox><tbox llx="147" lly="136" urx="254" ury="146" f="5"><![CDATA[pages 300--305, January 1998. ]]></tbox></line>
<line><tbox llx="48" lly="127" urx="307" ury="137" f="5"><![CDATA[[11] J. Hunt, K.-P. Vo, and W. Tichy. Delta algorithms: An empirical analysis. ]]></tbox></line>
<line><tbox llx="66" lly="118" urx="279" ury="128" f="6"><![CDATA[ACM Transactions on Software Engineering and Methodology, ]]></tbox><tbox llx="273" lly="118" urx="308" ury="128" f="5"><![CDATA[7, 1998. ]]></tbox></line>
<line><tbox llx="48" lly="109" urx="307" ury="119" f="5"><![CDATA[[12] R. Karp and M. Rabin. Efficient randomized pattern-matching algo- ]]></tbox></line>
<line><tbox llx="66" lly="100" urx="97" ury="110" f="5"><![CDATA[rithms. ]]></tbox><tbox llx="96" lly="100" urx="254" ury="110" f="6"><![CDATA[IBM Journal of Research and Development, ]]></tbox><tbox llx="250" lly="100" urx="308" ury="110" f="5"><![CDATA[31(2):249--260, ]]></tbox></line>
<line><tbox llx="66" lly="91" urx="93" ury="101" f="5"><![CDATA[1987. ]]></tbox></line>
<line><tbox llx="311" lly="724" urx="571" ury="734" f="5"><![CDATA[[13] D. Korn and K.-P. Vo. Engineering a differencing and compression data ]]></tbox></line>
<line><tbox llx="329" lly="715" urx="374" ury="725" f="5"><![CDATA[format. In ]]></tbox><tbox llx="370" lly="715" urx="571" ury="725" f="6"><![CDATA[Proceedings of the Usenix Annual Technical Conference, ]]></tbox></line>
<line><tbox llx="329" lly="706" urx="427" ury="716" f="5"><![CDATA[pages 219--228, June 2002. ]]></tbox></line>
<line><tbox llx="311" lly="697" urx="433" ury="707" f="5"><![CDATA[[14] E. Kushilevitz and N. Nisan. ]]></tbox><tbox llx="430" lly="697" urx="530" ury="707" f="6"><![CDATA[Communication Complexity. ]]></tbox><tbox llx="527" lly="697" urx="571" ury="707" f="5"><![CDATA[Cambridge ]]></tbox></line>
<line><tbox llx="329" lly="688" urx="413" ury="698" f="5"><![CDATA[University Press, 1997. ]]></tbox></line>
<line><tbox llx="311" lly="679" urx="571" ury="689" f="5"><![CDATA[[15] J. Langford. Multiround rsync. January 2001. Unpublished manuscript. ]]></tbox></line>
<line><tbox llx="311" lly="670" urx="385" ury="680" f="5"><![CDATA[[16] J. MacDonald. ]]></tbox><tbox llx="381" lly="670" urx="570" ury="680" f="5"><![CDATA[File system support for delta compression. MS Thesis, ]]></tbox></line>
<line><tbox llx="329" lly="661" urx="420" ury="671" f="5"><![CDATA[UC Berkeley, May 2000. ]]></tbox></line>
<line><tbox llx="311" lly="652" urx="571" ury="662" f="5"><![CDATA[[17] T. Madej. An application of group testing to the file comparison problem. ]]></tbox></line>
<line><tbox llx="329" lly="643" urx="344" ury="653" f="5"><![CDATA[In ]]></tbox><tbox llx="339" lly="643" urx="550" ury="653" f="6"><![CDATA[Proc. of the 9th Int. Conf. on Distributed Computing Systems, ]]></tbox><tbox llx="544" lly="643" urx="571" ury="653" f="5"><![CDATA[pages ]]></tbox></line>
<line><tbox llx="329" lly="634" urx="406" ury="644" f="5"><![CDATA[237--243, June 1989. ]]></tbox></line>
<line><tbox llx="311" lly="625" urx="570" ury="635" f="5"><![CDATA[[18] J. Metzner. A parity structure for large remotely located replicated data ]]></tbox></line>
<line><tbox llx="329" lly="616" urx="353" ury="626" f="5"><![CDATA[files. ]]></tbox><tbox llx="348" lly="616" urx="468" ury="626" f="6"><![CDATA[IEEE Transactions on Computers, ]]></tbox><tbox llx="463" lly="616" urx="567" ury="626" f="5"><![CDATA[32(8):727--730, August 1983. ]]></tbox></line>
<line><tbox llx="311" lly="607" urx="519" ury="617" f="5"><![CDATA[[19] J. Metzner. Efficient replicated remote file comparison. ]]></tbox><tbox llx="514" lly="607" urx="571" ury="617" f="6"><![CDATA[IEEE Transac- ]]></tbox></line>
<line><tbox llx="329" lly="598" urx="404" ury="608" f="6"><![CDATA[tions on Computers, ]]></tbox><tbox llx="398" lly="598" urx="494" ury="608" f="5"><![CDATA[40(5):651--659, May 1991. ]]></tbox></line>
<line><tbox llx="311" lly="589" urx="571" ury="599" f="5"><![CDATA[[20] Y. Minsky, A. Trachtenberg, and R. Zippel. Set reconciliation with ]]></tbox></line>
<line><tbox llx="329" lly="580" urx="479" ury="590" f="5"><![CDATA[almost optimal communication complexity. ]]></tbox><tbox llx="475" lly="580" urx="571" ury="590" f="5"><![CDATA[Technical Report TR2000- ]]></tbox></line>
<line><tbox llx="329" lly="571" urx="441" ury="581" f="5"><![CDATA[1813, Cornell University, 2000. ]]></tbox></line>
<line><tbox llx="311" lly="562" urx="502" ury="572" f="5"><![CDATA[[21] A. Muthitacharoen, B. Chen, and D. Mazi` eres. ]]></tbox><tbox llx="504" lly="562" urx="571" ury="572" f="5"><![CDATA[A low-bandwidth ]]></tbox></line>
<line><tbox llx="329" lly="553" urx="418" ury="563" f="5"><![CDATA[network file system. In ]]></tbox><tbox llx="413" lly="553" urx="571" ury="563" f="6"><![CDATA[Proc. of the 18th ACM Symp. on Operating ]]></tbox></line>
<line><tbox llx="329" lly="544" urx="401" ury="554" f="6"><![CDATA[Systems Principles, ]]></tbox><tbox llx="395" lly="544" urx="503" ury="554" f="5"><![CDATA[pages 174--187, October 2001. ]]></tbox></line>
<line><tbox llx="311" lly="535" urx="571" ury="545" f="5"><![CDATA[[22] P. Noel. An efficient algorithm for file synchronization. Master's thesis, ]]></tbox></line>
<line><tbox llx="329" lly="526" urx="434" ury="536" f="5"><![CDATA[Polytechnic University, 2004. ]]></tbox></line>
<line><tbox llx="311" lly="518" urx="571" ury="527" f="5"><![CDATA[[23] A. Orlitsky. Worst-case interactive communication II: Two messages are ]]></tbox></line>
<line><tbox llx="329" lly="509" urx="376" ury="518" f="5"><![CDATA[not optimal. ]]></tbox><tbox llx="370" lly="509" urx="515" ury="518" f="6"><![CDATA[IEEE Transactions on Information Theory, ]]></tbox><tbox llx="509" lly="509" urx="571" ury="518" f="5"><![CDATA[37(4):995--1005, ]]></tbox></line>
<line><tbox llx="329" lly="500" urx="372" ury="509" f="5"><![CDATA[July 1991. ]]></tbox></line>
<line><tbox llx="311" lly="491" urx="570" ury="501" f="5"><![CDATA[[24] A. Orlitsky. Interactive communication of balanced distributions and of ]]></tbox></line>
<line><tbox llx="329" lly="482" urx="388" ury="492" f="5"><![CDATA[correlated files. ]]></tbox><tbox llx="383" lly="482" urx="497" ury="491" f="6"><![CDATA[SIAM Journal of Discrete Math, ]]></tbox><tbox llx="491" lly="482" urx="566" ury="492" f="5"><![CDATA[6(4):548--564, 1993. ]]></tbox></line>
<line><tbox llx="311" lly="473" urx="448" ury="483" f="5"><![CDATA[[25] A. Orlitsky and K. Viswanathan. ]]></tbox><tbox llx="447" lly="473" urx="570" ury="483" f="5"><![CDATA[Practical algorithms for interactive ]]></tbox></line>
<line><tbox llx="329" lly="464" urx="399" ury="474" f="5"><![CDATA[communication. In ]]></tbox><tbox llx="394" lly="464" urx="533" ury="473" f="6"><![CDATA[IEEE Int. Symp. on Information Theory, ]]></tbox><tbox llx="527" lly="464" urx="571" ury="474" f="5"><![CDATA[June 2001. ]]></tbox></line>
<line><tbox llx="311" lly="455" urx="571" ury="465" f="5"><![CDATA[[26] A. Orlitsky and K. Viswanathan. One-way communication and error- ]]></tbox></line>
<line><tbox llx="329" lly="446" urx="403" ury="456" f="5"><![CDATA[correcting codes. In ]]></tbox><tbox llx="398" lly="446" urx="571" ury="456" f="6"><![CDATA[Proc. of the 2002 IEEE Int. Symp. on Information ]]></tbox></line>
<line><tbox llx="329" lly="437" urx="362" ury="447" f="6"><![CDATA[Theory, ]]></tbox><tbox llx="357" lly="437" urx="435" ury="447" f="5"><![CDATA[page 394, June 2002. ]]></tbox></line>
<line><tbox llx="311" lly="428" urx="571" ury="438" f="5"><![CDATA[[27] C. Park and J. J. Metzner. Efficient location of discrepancies in multiple ]]></tbox></line>
<line><tbox llx="329" lly="419" urx="407" ury="429" f="5"><![CDATA[replicated large files. ]]></tbox><tbox llx="405" lly="419" urx="571" ury="429" f="6"><![CDATA[IEEE Transactions on Parallel and Distributed ]]></tbox></line>
<line><tbox llx="329" lly="410" urx="365" ury="420" f="6"><![CDATA[Systems, ]]></tbox><tbox llx="359" lly="410" urx="455" ury="420" f="5"><![CDATA[13(6):597--610, June 2002. ]]></tbox></line>
<line><tbox llx="311" lly="401" urx="345" ury="411" f="5"><![CDATA[[28] B. ]]></tbox><tbox llx="358" lly="401" urx="571" ury="411" f="5"><![CDATA[Pierce. Unison file synchronizer. ]]></tbox></line>
<line><tbox llx="331" lly="392" urx="539" ury="401" f="7"><![CDATA[http://www.cis.upenn.edu/#bcpierce/unison/. ]]></tbox></line>
<line><tbox llx="311" lly="383" urx="571" ury="393" f="5"><![CDATA[[29] N. Ramsey and E. Csirmaz. An algebraic approach to file synchroniza- ]]></tbox></line>
<line><tbox llx="329" lly="374" urx="364" ury="384" f="5"><![CDATA[tion. In ]]></tbox><tbox llx="359" lly="374" urx="571" ury="384" f="6"><![CDATA[Proc. of the 9th ACM Int. Symp. on Foundations of Software ]]></tbox></line>
<line><tbox llx="329" lly="365" urx="379" ury="375" f="6"><![CDATA[Engineering, ]]></tbox><tbox llx="374" lly="365" urx="453" ury="375" f="5"><![CDATA[pages 175--185, 2001. ]]></tbox></line>
<line><tbox llx="311" lly="356" urx="451" ury="366" f="5"><![CDATA[[30] S. Rhea, K. Liang, and E. Brewer. ]]></tbox><tbox llx="447" lly="356" urx="551" ury="366" f="5"><![CDATA[Value-based web caching. In ]]></tbox><tbox llx="545" lly="356" urx="571" ury="366" f="6"><![CDATA[Proc. ]]></tbox></line>
<line><tbox llx="329" lly="347" urx="485" ury="357" f="6"><![CDATA[of the 12th Int. World Wide Web Conference, ]]></tbox><tbox llx="480" lly="347" urx="523" ury="357" f="5"><![CDATA[May 2003. ]]></tbox></line>
<line><tbox llx="311" lly="338" urx="571" ury="348" f="5"><![CDATA[[31] L. Rizzo. Effective erasure codes for reliable computer communication ]]></tbox></line>
<line><tbox llx="329" lly="329" urx="369" ury="339" f="5"><![CDATA[protocols. ]]></tbox><tbox llx="365" lly="329" urx="486" ury="339" f="6"><![CDATA[Computer Communication Review, ]]></tbox><tbox llx="481" lly="329" urx="527" ury="339" f="5"><![CDATA[April 1997. ]]></tbox></line>
<line><tbox llx="311" lly="320" urx="571" ury="330" f="5"><![CDATA[[32] S. Schleimer, D. Wilkerson, and A. Aiken. Winnowing: Local algorithms ]]></tbox></line>
<line><tbox llx="329" lly="311" urx="430" ury="321" f="5"><![CDATA[for document fingerprinting. ]]></tbox><tbox llx="427" lly="311" urx="442" ury="321" f="5"><![CDATA[In ]]></tbox><tbox llx="437" lly="311" urx="571" ury="321" f="6"><![CDATA[Proc. of the 2003 ACM SIGMOD Int. ]]></tbox></line>
<line><tbox llx="329" lly="302" urx="440" ury="312" f="6"><![CDATA[Conf. on Management of Data, ]]></tbox><tbox llx="434" lly="302" urx="506" ury="312" f="5"><![CDATA[pages 76--85, 2003. ]]></tbox></line>
<line><tbox llx="311" lly="293" urx="486" ury="303" f="5"><![CDATA[[33] T. Schwarz, R. Bowdidge, and W. Burkhard. ]]></tbox><tbox llx="482" lly="293" urx="571" ury="303" f="5"><![CDATA[Low cost comparison of ]]></tbox></line>
<line><tbox llx="329" lly="284" urx="386" ury="294" f="5"><![CDATA[file copies. In ]]></tbox><tbox llx="381" lly="284" urx="571" ury="294" f="6"><![CDATA[Proc. of the 10th Int. Conf. on Distributed Computing ]]></tbox></line>
<line><tbox llx="329" lly="275" urx="365" ury="285" f="6"><![CDATA[Systems, ]]></tbox><tbox llx="359" lly="275" urx="439" ury="285" f="5"><![CDATA[pages 196--202, 1990. ]]></tbox></line>
<line><tbox llx="311" lly="266" urx="571" ury="276" f="5"><![CDATA[[34] N. Spring and D. Wetherall. A protocol independent technique for ]]></tbox></line>
<line><tbox llx="329" lly="258" urx="471" ury="267" f="5"><![CDATA[eliminating redundant network traffic. In ]]></tbox><tbox llx="465" lly="258" urx="571" ury="267" f="6"><![CDATA[Proc. of the ACM SIGCOMM ]]></tbox></line>
<line><tbox llx="329" lly="249" urx="376" ury="258" f="6"><![CDATA[Conference, ]]></tbox><tbox llx="371" lly="249" urx="397" ury="258" f="5"><![CDATA[2000. ]]></tbox></line>
<line><tbox llx="311" lly="240" urx="570" ury="249" f="5"><![CDATA[[35] D. Starobinski, A. Trachtenberg, and S. Agarwal. Efficient PDA ]]></tbox></line>
<line><tbox llx="329" lly="231" urx="391" ury="240" f="5"><![CDATA[synchronization. ]]></tbox><tbox llx="386" lly="231" urx="532" ury="240" f="6"><![CDATA[IEEE Transactions on Mobile Computing, ]]></tbox><tbox llx="526" lly="231" urx="571" ury="240" f="5"><![CDATA[2(1), 2003. ]]></tbox></line>
<line><tbox llx="311" lly="222" urx="571" ury="232" f="5"><![CDATA[[36] T. Suel and N. Memon. Algorithms for delta compression and remote ]]></tbox></line>
<line><tbox llx="329" lly="213" urx="495" ury="223" f="5"><![CDATA[file synchronization. In Khalid Sayood, editor, ]]></tbox><tbox llx="490" lly="213" urx="571" ury="222" f="6"><![CDATA[Lossless Compression ]]></tbox></line>
<line><tbox llx="329" lly="204" urx="373" ury="213" f="6"><![CDATA[Handbook. ]]></tbox><tbox llx="367" lly="204" urx="450" ury="214" f="5"><![CDATA[Academic Press, 2002. ]]></tbox></line>
<line><tbox llx="311" lly="195" urx="571" ury="205" f="5"><![CDATA[[37] T. Suel, P. Noel, and D. Trendafilov. Improved file synchronization tech- ]]></tbox></line>
<line><tbox llx="329" lly="186" urx="571" ury="196" f="5"><![CDATA[niques for maintaining large replicated collections over slow networks. ]]></tbox></line>
<line><tbox llx="329" lly="177" urx="344" ury="187" f="5"><![CDATA[In ]]></tbox><tbox llx="339" lly="177" urx="493" ury="187" f="6"><![CDATA[Proc. of the Int. Conf. on Data Engineering, ]]></tbox><tbox llx="488" lly="177" urx="538" ury="187" f="5"><![CDATA[March 2004. ]]></tbox></line>
<line><tbox llx="311" lly="168" urx="571" ury="178" f="5"><![CDATA[[38] D. Trendafilov, N. Memon, and T. Suel. zdelta: a simple delta compres- ]]></tbox></line>
<line><tbox llx="329" lly="159" urx="571" ury="169" f="5"><![CDATA[sion tool. Technical Report TR-CIS-2002-02, Polytechnic University, ]]></tbox></line>
<line><tbox llx="329" lly="150" urx="431" ury="160" f="5"><![CDATA[CIS Department, June 2002. ]]></tbox></line>
<line><tbox llx="311" lly="141" urx="376" ury="151" f="5"><![CDATA[[39] A. Tridgell. ]]></tbox><tbox llx="371" lly="141" urx="574" ury="151" f="6"><![CDATA[Efficient Algorithms for Sorting and Synchronization.PhD ]]></tbox></line>
<line><tbox llx="329" lly="132" urx="502" ury="142" f="5"><![CDATA[thesis, Australian National University, April 2000. ]]></tbox></line>
<line><tbox llx="311" lly="123" urx="531" ury="133" f="5"><![CDATA[[40] A. Tridgell, P. Barker, and P. MacKerras. rsync in http. In ]]></tbox><tbox llx="526" lly="123" urx="571" ury="133" f="6"><![CDATA[Conference ]]></tbox></line>
<line><tbox llx="329" lly="114" urx="424" ury="124" f="6"><![CDATA[of Australian Linux Users, ]]></tbox><tbox llx="419" lly="114" urx="445" ury="124" f="5"><![CDATA[1999. ]]></tbox></line>
<line><tbox llx="311" lly="105" urx="571" ury="115" f="5"><![CDATA[[41] A. Tridgell and P. MacKerras. The rsync algorithm. Technical Report ]]></tbox></line>
<line><tbox llx="329" lly="96" urx="525" ury="106" f="5"><![CDATA[TR-CS-96-05, Australian National University, June 1996.]]></tbox></line>
<pbox llx="48.00" lly="91.00" urx="574.00" ury="735.00"/></page>
<fonts>
<font name="FDKOAD+Times-Roman?" h="11.12" n="1"/>
<font name="FDKOCF+Times-Italic?" h="10.96" n="2"/>
<font name="FDKOAD+Times-Roman?" h="8.89" n="3"/>
<font name="FDKOAD+Times-Roman?" h="11.12" n="4"/>
<font name="FDKOAD+Times-Roman?" h="8.89" n="5"/>
<font name="FDKOCF+Times-Italic?" h="8.77" n="6"/>
<font name="FDKOBD+Courier?" h="8.38" n="7"/>
<font name="FDLBFK+CMSY8?" h="13.82" n="8"/>
<font name="FDKOAD+Times-Roman?" h="11.12" n="9"/>
<font name="FDKOAD+Times-Roman?" h="8.89" n="10"/>
<font name="FDKOAD+Times-Roman?" h="11.12" n="11"/>
<font name="FDKOAD+Times-Roman?" h="8.89" n="12"/>
<font name="FDKOAD+Times-Roman?" h="11.12" n="13"/>
<font name="FDKOAD+Times-Roman?" h="8.89" n="14"/>
<font name="FDKOAD+Times-Roman?" h="11.12" n="15"/>
<font name="FDKOFJ+CMR7?" h="6.97" n="16"/>
<font name="FDKOCF+Times-Italic?" h="10.96" n="17"/>
<font name="FDKOEF+CMSY7?" h="12.08" n="18"/>
<font name="FDKOAD+Times-Roman?" h="11.12" n="19"/>
<font name="FDKOAD+Times-Roman?" h="8.89" n="20"/>
<font name="FDKOAD+Times-Roman?" h="11.12" n="21"/>
<font name="FDKOAD+Times-Roman?" h="8.89" n="22"/>
<font name="FDKOAD+Times-Roman?" h="11.12" n="23"/>
<font name="FDKOAD+Times-Roman?" h="8.89" n="24"/>
<font name="FDKOAD+Times-Roman?" h="11.12" n="25"/>
<font name="FDKOAD+Times-Roman?" h="8.89" n="26"/>
<font name="FDKOAD+Times-Roman?" h="7.12" n="27"/>
<font name="FDKOAD+Times-Roman?" h="8.89" n="28"/>
<font name="FDKOAD+Times-Roman?" h="7.12" n="29"/>
<font name="FDKOAD+Times-Roman?" h="8.89" n="30"/>
<font name="FDKOAD+Times-Roman?" h="11.12" n="31"/>
<font name="FDKOCF+Times-Italic?" h="10.96" n="32"/>
<font name="FDKOBE+CMMI10?" h="9.96" n="33"/>
<font name="FDKOEI+CMR10?" h="12.14" n="34"/>
<font name="FDKOEG+CMMI7?" h="6.97" n="35"/>
<font name="FDKOAB+Times-Bold?" h="9.04" n="36"/>
<font name="FDKOBD+Courier?" h="10.31" n="37"/>
<font name="FDKOAB+Times-Bold?" h="9.19" n="38"/>
<font name="FDKOAD+Times-Roman?" h="8.89" n="39"/>
<font name="FDLBFK+CMSY8?" h="13.82" n="40"/>
<font name="FDKOAD+Times-Roman?" h="11.12" n="41"/>
<font name="FDKOEF+CMSY7?" h="12.08" n="42"/>
</fonts>
</document>