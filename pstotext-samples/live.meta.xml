<?xml version="1.0" encoding="UTF-8"?>
<document>
  <content>
    <headers headerID="p1x111.0y712.0">
      <title>Junta Distributions and the Average-Case Complexity of Manipulating Elections</title>
      <authors>
        <author>
          <author-first>Ariel</author-first>
          <author-middle>D.</author-middle>
          <author-last>Procaccia</author-last>
        </author>
        <author>
          <author-first>Jeffrey</author-first>
          <author-middle>S.</author-middle>
          <author-last>Rosenschein</author-last>
        </author>
      </authors>
      <institution>School of Engineering and Computer Science The Hebrew University of Jerusalem</institution>
      <address>91904 Jerusalem, Israel</address>
      <email>{arielpro, jeff}@cs.huji.ac.il</email>
      <abstract>Abstract Encouraging voters to truthfully reveal their preferences in an election has long been an important issue. Previous studies have shown that some voting protocols are hard to manipulate, but predictably used NPhardness as the complexity measure. Such a worst-case analysis may be an insufficient guarantee of resistance to manipulation. Indeed, we demonstrate that NP-hard manipulations may be tractable in the average-case. For this purpose, we augment the existing theory of average-case complexity with new concepts; we consider elections distributed with respect to junta distributions, which concentrate on hard instances, and introduce a notion of heuristic polynomial time. We use our techniques to prove that a family of important voting protocols is susceptible to manipulation by coalitions, when the number of candidates is constant.</abstract>
    </headers>
    <body>1 Introduction 
In multiagent environments, it may be the case that different agents have diverse preferences. Therefore, it is 
important to find a way to aggregate the agents' preferences. A general scheme for preference aggregation is 
voting: the agents reveal their preferences by ranking a set of candidates; a winner is determined according to 
a voting protocol. The candidates can be various entities such as beliefs or plans, and indeed may be potential 
real-life parliament members. 
Things are made complicated by the fact that in many settings (as in reality) the agents are self-interested. 
Such an agent may reveal its preferences untruthfully, if it believes this would make the final outcome of the 
elections more favorable for it. Consequently, the outcome may be one that does not maximize social welfare. 
This problem is provably acute: it is known [7, 8] that, for elections with three or more candidates, in any voting 
protocol that is non-dictatorial 1 , there are elections where an agent is better off by voting untruthfully. 
Fortunately, it is reasonable to make the assumption that the agents are computationally bounded. Therefore, 
although in principle an agent may be able to manipulate an election, the computation required may be infeasible. 
This has motivated researchers to study the computational complexity of manipulating voting protocols. It has 
long been known [2] that there are voting protocols that are NP-hard to manipulate by a single voter. Recent 
results by Conitzer and Sandholm [4, 3] show that some manipulations of common voting protocols are NP- 
hard, even for a small number of candidates. Moreover, in [5], it is shown that adding a preround to some voting 
protocols can make manipulations hard (even PSPACE-hard in some cases). Elkind and Lipmaa [6] show that 
the notion of preround, together with one-way functions, can be used to construct protocols that are hard to 
manipulate even by a large minority fraction of the voters. 
In Computer Science, the notion of hardness is usually considered in the sense of worst-case complexity. 
Not surprisingly, most results on the complexity of manipulation use NP-hardness as the complexity measure. 
However, it may still be the case that most instances of the problem are easy to manipulate. A relatively little- 
known theory of average case complexity exists [9]; this theory introduces the concept of distributional problems, 
and defines what a reduction between distributional problems is. It is also known that average-case complete 
1 In a dictatorial protocol, there is an agent that dictates the outcome regardless of the others' choices. 
1 
problems exist (albeit artificial ones, such as a distributional version of the halting problem). Sadly, it is very 
difficult to show that a certain problem is average-case complete, and such results are known only for a handful 
of problems. Additionally, the goal of the existing theory is to define when a problem is hard in the average-case; 
it does not provide criteria for deciding when a problem is easy. A step towards showing that a manipulation is 
easy on average was made in [6]. It involves an analysis of the plurality protocol with a preround, but focuses on 
a very specific distribution, which does not satisfy some basic desiderata as to what properties an "interesting" 
distribution should have. 
In this paper, we engage in a novel average-case analysis, based on criteria we propose. Coming up with an 
"interesting" distribution of problem instances with respect to which the average-case complexity is computed is 
a difficult task, and the solution may be controversial. We analyze problems whose instances are distributed with 
respect to a junta distribution. Such a distribution must satisfy several conditions, which (arguably) guarantee that 
it focuses on instances that are harder to manipulate. We consider a protocol to be susceptible to manipulation 
when there is a polynomial time algorithm that can usually manipulate it: the probability of failure (when the 
instances are distributed according to a junta distribution) must be inverse-polynomial. Such an algorithm is 
known as a heuristic polynomial time algorithm. 
We use these new methods to prove our main result: an important family of protocols, called scoring protocols, 
is susceptible to coalitional manipulation when the number of candidates is constant. Specifically, we contemplate 
sensitive scoring protocols, which include such well known protocols as Borda and STV. To accomplish this task, 
we define a natural distibution # over the instances of a well-defined coalitional manipulation problem, and show 
this is a junta distribution. Furthermore, we present the manipulation algorithm GREEDY, and show that it usually 
succeeds with respect to # . 
We also show that all protocols are susceptible to a certain setting of manipulation, where the manipulator is 
unsure about the others' votes. This result depends upon a basic conjecture regarding junta distribtions, but also 
has implications that transcend our specific definition of these distributions. 
In Section 2, we outline some important voting protocols, and properly define the manipulation problems we 
shall discuss. In Section 3, we formally introduce the tools for our average case analysis: junta distributions, 
heuristic polynomial time, and susceptibility to manipulations. In Section 4 we prove our main result: sensitive 
scoring protocols are susceptible to coalitional manipulation with few candidates. In Section 5, we discuss the case 
when a single manipulator is unsure about the other voters' votes. Finally, in Section 6, we present conclusions 
and future directions for research. 
2 Preliminaries 
We first describe some common voting protocols and formally define the manipulation problems with which we 
shall deal. Next, we introduce a useful lemma from probability theory. 
2.1 Elections and Manipulations 
An election consists of a set C of m candidates, and a set V of n voters, who provide a total order on the 
candidates. An election also includes a winner determination function from the set of all possible combinations 
of votes to C. We note that throughout this paper, m = O(1), so the complexity results are in terms of n. 
Different voting protocols are distinguished by their winner determination functions. The protocols we shall 
discuss are: 
. Scoring protocols: A scoring protocol is defined by vector ~ # = h# 1 , # 2 , . . . , #m i, such that # 1 # # 2 # 
. . . # #m and # i 2 N [ {0}. A candidate receives # i points for each voter which ranks it in the i'th place. 
Examples of scoring protocols are: 
-- Plurality: ~ 
# = h1, 0, . . . , 0, 0i. 
-- Veto: ~ 
# = h1, 1, . . . , 1, 0i. 
-- Borda: ~ # = hm - 1, m - 2, . . . , 1, 0i. 
. Copeland: For each possible pair of candidates, simulate an election; a candidate wins such a pairwise 
election if more voters prefer it over the opponent. A candidate gets 1 point for each pairwise election it 
wins, 
and- 1 for each pairwise election it loses. 
2 
. Maximin: A candidate's score in a pairwise election is the number of voters that prefer it over the opponent. 
The winner is the candidate whose minimum score over all pairwise elections is highest. 
. Single Transferable Vote: The election proceeds in rounds. In each round, the candidate's score is the 
number of voters that rank it highest among the remaining candidates; the candidate with the lowest score 
is eliminated. 
We assume that tie-breaking is always adversarial to the manipulator. Additionally, in the case of weighted 
votes, a voter with weight k is naturally considered to be k voters who vote unanimously. In this paper, we 
consider weights in [0, 1]. This is equivalent, since any set of integer weights in the range 1, . . . , polyn can be 
scaled down to weights in the segment [0, 1] with O(logn) bits of precision. 
The main results of the paper focus on scoring protocols. We shall require the following definition: 
Definition 1 (Sensitive Scoring Protocol). Let P be a scoring protocol with parameters ~ # = h# 1 , # 2 , . . . , #m i. 
We say that P is sensitive if # 1 # # 2 # . . . # 
#m- 1 } #m = 0 (notice the strict inequality on the right). 
In particular, observe that Borda and Veto are sensitive scoring protocols. Generally, from any scoring protocol 
with #m- 1 } #m , an equivalent sensitive scoring protocol can be obtained by subtracting #m on a coordinate-by- 
coordinate basis from the vector ~ #. Moreover, observe that if a protocol is a scoring protocol but is not sensitive, 
and #m = 0, then #m - 1 = 0. In this case, for three candidates it is equivalent to the plurality protocol, for 
which most manipulations are tractable even in the worst-case. Therefore, it is sufficient to restrict our results to 
sensitive scoring protocols. 
We next consider some types of manipulations, state the appropriate complexity results, and introduce some 
notations. We discuss the constructive cases, where the goal is trying to make a candidate win, as opposed to 
destructive manipulation, where the goal is to make a candidate lose. Constructive manipulations are always at 
least as hard (in the worst-case sense) as their destructive counterparts, and in some cases strictly harder (if one is 
able to determine whether p can be made to win, one can also ask whether any of the other m - 1 candidates can 
be made to win, thus making p lose). 
Definition 2 (INDIVIDUAL-MANIPULATION (IM)). We are given all the other votes, and a preferred 
candidate p. We are asked whether there is a way for the manipulator to cast its vote so that p wins. 
In [2] it is shown that IM is NP-complete in Single Transferable Vote, provided the number of candidates is 
unbounded. However, the problem is in P for most voting schemes, and hence will not be studied here. 
Definition 3 (COALITIONAL-WEIGHTED-MANIPULATION (CWM)). We are given a set of weighted votes 
S, the weights of a set of votes T which are still open, and a preferred candidate p. We are asked whether there is 
a way to cast the votes in T so that p wins the election. 
We know [4, 3] that CWM is NP-complete in Borda, Veto and Single Transferable Vote, even with 3 
candidates, and in Maximin and Copeland with at least 4 candidates. 
This problem will be studied in Section 4; the CWM version that we shall analyze, which is specifically 
tailored for scoring protocols, is a slightly modified version whose analysis is more straightforward: 
Definition 4 (SCORING-COALITIONAL-WEIGHTED-MANIPULATION (SCWM)). We are given an initial 
score S[c] for each candidate c, the weights of a set of votes T which are still open, and a preferred candidate p. 
We are asked whether there is a way to cast the votes in T so that p wins the election. 
S[c] can be interpreted as c's total score from the votes in S. However, we do not require that there exists a 
combination of votes that actually induces S[c] for all c. 
Definition 5 (UNCERTAIN-VOTES-WEIGHTED-EVALUATION (UVWE)). We are given a weight for each 
voter, a distribution over all the votes, a candidate p, and a number r 2 [0, 1]. We are asked whether the 
probability of p winning is greater than r. 
Definition 6 (UNCERTAIN-VOTES-WEIGHTED-MANIPULATION (UVWM)). We are given a single 
manipulative voter with a weight, weights for all other voters, a distribution over all the others' votes, a candidate p, 
and a number r, where r 2 [0, 1]. We are asked whether the manipulator can cast its vote so that p wins with 
probability greater than r. 
3 
If CWM is NP-hard in a protocol, then UVWE and UVWM are also NP-hard in it [4]. These problems 
will be studied in Section 5. We make the assumption that the given distributions over the others' votes can be 
sampled in polynomial time. 
2.2 Chernoff's bounds 
The following lemma will be of much use later on. Informally, it states that the average of independent identically 
distributed (i.i.d.) random variables is almost always close to the expectation. 
Lemma 1 (Chernoff's Bounds). Let X 1 , . . . , X t be i.i.d. random variables such that a # X i # b and E[X i ] = . 
Then for any # } 0, it holds that: 
. Pr[ 1 
t P t 
i=1 X i # + #] # 
e- 2t # 2 
(b- a) 2 
. Pr[ 1 
t P t 
i=1 X i # - #] # e - 2t # 2 
(b- a) 2 
3 Junta Distributions and Susceptible Mechanisms 
In this section we lay the mathematical foundations required for an average-case analysis of the complexity of 
manipulations. All of the definitions are as general as possible; they can be applied to the manipulation of any 
mechanism, not merely to the manipulation of voting protocols. 
We describe a distribution over the instances of a problem as a collection of distributions 1 , . . . , n , . . ., 
where n is a distribution over the instances x such that |x| = n. We wish to analyze problems whose instances 
are distributed with respect to a distribution which focuses on hard-to-manipulate instances. Ideally, we would 
like this distinguished distribution to be such that if one manages to produce an algorithm which can usually 
manipulate instances according to this "difficult" distribution, the algorithm would also usually succeed when the 
instances are distributed with respect to most other reasonable distributions. 
Definition 7 (Junta Distribution). Let = {n } n2N be a distribution over the possible instances of an NP-hard 
manipulation problem M . is a junta distribution if and only if has the following properties: 
1. Hardness: The restriction of M to is the manipulation problem whose possible instances are only: 
S n2N {x : |x| = n ^ n (x) } 0}. Deciding this restricted problem is still NP-hard. 
2. Balance: There exist a constant c } 0 and N 2 N such that for all n # N : 
1 
c # Pr x#n [M(x) = 1] # 
11 
c 
. 
3. Dichotomy: for all n and instances x such that |x| = n: 
n (x) # 2 - polyn 
_ n (x) = 0. 
If M is a manipulation problem, we also require the following property: 
4. Symmetry: Let v be a voter whose vote is given, let c 1 , c 2 6= p be two candidates, and let i 2 [m]. The 
probability that v ranks c 1 in the i'th place is the same as the probability that v ranks c 2 in the i'th place. 
If M is a coalitional manipulation problem, we also require the following property: 
5. Refinement: Let x be an instance such that |x| = n and n (x) } 0; if all colluders voted identically, then p 
would not be elected. 
The name "junta distribution" comes from the idea that in such a distribution, relatively few "powerful" and 
difficult instances represent all the other problem instances. Alternatively, our intent is to have a few problematic 
distributions (the family of junta distributions) convincingly represent all other distributions with respect to the 
average-case analysis. 
4 
The first three properties are basic, and are relevant to problems of manipulating any mechanism. The 
definition is modular, and relevant additional properties may be added on top of the basic three, in case one wishes to 
analyze a mechanism which is not a voting protocol. 
The exact choice of properties is of extreme importance (and may be arguable). We shall briefly explain our 
choices. Hardness is meant to insure that the junta distribution contains hard instances. Balance guarantees that 
a trivial algorithm which always accepts (or always rejects) has a significant chance of failure. The dichotomy 
property helps in preventing situations where the distribution gives a (positive but) neglible probability to all the 
hard instances, and a high probability to several easy instances. 
We now examine the properties that are specific to manipulation problems. The necessity of symmetry is best 
explained by an example. Consider CWM in STV with m # 3. One could design a distribution where p wins 
if and only if a distinguished candidate loses the first round. Such a distribution could be tailored to satisfy the 
other conditions, but misses many of the hard instances. In the context of SCWM, we interpret symmetry in the 
following way: for every two candidates c 1 , c 2 6= p and y 2 R, 
Pr 
x#n 
[S[c 1 ] = y] = Pr 
x#n 
[S[c 2 ] = y]. 
Refinement is less important than the other four properties, but seems to help in concentrating the probability 
on hard instances. Observe that refinement is only relevant to coalitional manipulation; we believe that in the 
analysis of individual voting manipulation problems, the first four properties are sufficient. 
Definition 8 (Distributional Problem [9]). A distributional problem is a pair hL, i where L is a decision problem 
and is a distribution over the set {0, 1} # of possible inputs. 
Informally, an algorithm is a heuristic polynomial time algorithm for a distributional problem if it runs in 
polynomial time, and fails only on a small fraction of the inputs. We now give a formal definition; this definition 
is inspired by [9] (there the same name is used for a somewhat different definition). 
Definition 9 (Heuristic Polynomial Time). Let hM,i be a distributional problem, where M is a manipulation 
problem. 
1. An algorithm A is a deterministic heuristic polynomial time algorithm for the distributional manipulation 
problem hM,i if A always runs in polynomial time, and there exists a polynomial p and N 2 N such that 
for all n # N : 
Pr 
x#n 
[A(x) 6= M(x)] &lt; 
1 
p(n) 
. (1) 
2. Let A be a probabilistic algorithm, which uses a random string s. A is a probabilistic heuristic polynomial 
time algorithm for the distributional manipulation problem hM,i if A always runs in polynomial time, and 
there exists a polynomial p and N 2 N such that for all n # N : 
Pr 
x#n ,s 
[A(x) 6= M(x)] &lt; 
1 
p(n) 
. (2) 
Probabilistic algorithms have two potential sources of failure: an unfortunate choice of input, or an unfortunate 
choice of random string s. The success or failure of deterministic algorithms depends only on the choice of input. 
We now combine all the definitions introduced in this section in an attempt to establish when a mechanism is 
susceptible to manipulation in the average case. The following definition abuses notation a bit: M is both used to 
refer to the manipulation itself, and the corresponding decision problem. 
Definition 10 (Susceptibility to Manipulation). We say that a mechanism is susceptible to a manipulation M if 
there exists a junta distribution , such that there exists a deterministic/probabilistic heuristic polynomial time 
algorithm for hM,i. 
5 
4 Susceptibility to SCWM 
Recall [4, 3] that in Borda and Veto, CWM is NP-hard, even with 3 candidates. Since Borda and Veto are 
examples of sensitive scoring protocols, we would like to study how resistant this family of protocols really is 
with respect to coalitional manipulation. In this section we use the methods from the previous section to prove 
our main result: 
Theorem 2. Let P be a sensitive scoring protocol. Then P , with candidates C = {p, c 1 , . . . , c m }, m = O(1), is 
susceptible to SCWM. 
Intuitively, the instances of CWM (or SCWM) which are hard are those that require a very specific partitioning 
of the voters in T to subsets, where each subset votes unanimously. These instances are rare in any reasonable 
distribution; this insight will ultimately yield the theorem. 
The following proposition generalizes Theorem 1 of [4] and Theorem 2 of [3], and justifies our focus on the 
family of sensitive scoring protocols. It will also be crucial in order to prove the hardness property of a junta 
distribution we shall design. 
Definition 11 (PARTITION). We are given a set of integers {k i } i2[t] , summing to 2K, and are asked whether a 
subset of these integers sum to K. 
It is well-known that PARTITION is NP-complete. 
Proposition 3. Let P be a sensitive scoring protocol. Then CWM in P is NP-hard, even with 3 candidates. 
Proof. We reduce an arbitrary PARTITION instance to the following CWM instance. There are 3 candidates, a, 
b, and p. In S, there are K(4# 1 - 2# 2 ) - 1 voters voting a # b # p, and K(4# 1 - 2# 2 ) - 1 voters voting 
b # a # p. In T , for every k i there is a vote of weight 2(# 1 + # 2 )k i . Observe that from S, both a and b get 
(K(4# 1 - 2# 2 ) - 1)(# 1 + # 2 ) points. 
Assume first that a partition exists. Let the voters in T in one half of the partition vote p # a # b, and let the 
other half vote p # b # a. By this vote, a and b each have 
(K(4# 1 - 2# 2 ) - 1)(# 1 + # 2 ) + 2K(# 1 + # 2 )# 2 = (# 1 + # 2 )(4K# 1 - 1) 
votes, while p has (# 1 + # 2 )4K# 1 points; thus there is a manipulation. 
Conversely, assume that there exists a manipulation. Clearly there must exist a manipulation where all the 
voters in T vote either p # a # b or p # b # a, because the colluders do not gain anything by not placing p 
at the top in a scoring protocol. In this manipulation, p has (# 1 + # 2 )4K# 1 points, while a and b already have 
(K(4# 1 - 2# 2 ) - 1)(# 1 +# 2 ) points from S. Therefore, a and b must gain less than (2# 2 K+1)(# 1 +# 2 ) points 
from the voters in T . Each voter corresponding to k i contributes 2(# 1 + # 2 )# 2 k i points; it follows that the sum 
of the k i corresponding to the voters voting p # a # b is less than K + 1 
2#2 
, and likewise for the voters voting 
p # b # a. Equivalently, the sum can be at most K, since all k i are integers and # 2 # 1. In both cases the sum 
must be at most K; hence, this is a partition. 
Since an instance of CWM can be translated to an instance of SCWM in the obvious way, we have: 
Corollary 4. Let P be a sensitive scoring protocol. Then SCWM in P is NP-hard, even with 3 candidates. 
4.1 A Junta Distribution 
Let w(v) denote the weight of voter v, and let W denote the total weight of the votes in T ; P is a sensitive scoring 
protocol. We denote |T | = n: the size of T is the size of the instance. 
Consider a distribution # = {# n } n2N over the instances of CWM in P , with m+1 candidates p, c 1 , . . . , c m , 
where each # n is induced by the following sampling algorithm: 
1. 8v 2 T : Randomly and independently choose w(v) 2 [0, 1] (up to O(logn) bits of precision). 
2. 8i 2 [m]: Randomly and independently choose S[c i ] 2 [(# 1 - # 2 )W, # 1 W ] (up to O(logn) bits of 
precision). 
6 
A few comments are in order. We assume that S[p] = 0, i.e., all voters in S rank p last. This assumption is not 
a restriction. If it holds for a candidate c that S[c] # S[p], then candidate c will surely lose, since the colluders all 
rank p first. Therefore, if S[p] } 0, we may simply normalize the scores by subtracting S[p] from the scores of 
all candidates. This is equivalent to our assumption. 
More importantly, we believe that # is the most natural distribution with repect to which coalitional 
manipulation in scoring protocols should be studied. Even if one disagrees with the exact definition of junta distribution, 
# should satisfy many reasonable conditions one could produce. We shall, of course, (presently) prove that the 
distribution posesses the properties of a junta distribution. 
Proposition 5. Let P be a sensitive scoring protocol. Then # is a kernel distribution for SCWM in P with 
C = {p, c 1 , . . . , c m }, and m = O(1). 
Proof. We first observe that the dichotomy and symmetry conditions are obviously satisfied. 
The proof of the hardness property relies on the reduction from PARTITION in Proposition 3. The reduction 
generates instances x of CWM in P with 3 candidates, where W = 4(# 1 + # 2 )K, and 
S[a] = S[b] = (K(4# 1 - 2# 2 ) - 1)(# 1 + # 2 ) = (# 1 - # 2 /2)W - (# 1 + # 2 ), 
for some K that originates in the PARTITION instance. These instances satisfy (# 1 - # 2 )W # S[a], S[b] # # 1 W . 
It follows that # (x) } 0 (after scaling down the weights). 2 
We now prove # has the balance property. If for all i, S[c i ] } (# 1 - # 2 /m)W , then clearly there is no 
manipulation, since at least # 2 W points are given by the voters in T to the undesirable candidates c 1 , . . . , c m . 
This happens with probability at least 1 
m m 
. 
On the other hand, consider the situation where for all i, 
S[c i ] &lt; (# 1 - 
m 2 
- 1 
m 2 # 2 )W ; (3) 
this occurs with probability at least 1 
(m 2 ) m 
. Intuitively, if the colluders could distribute the votes in T in such a 
way that each undesirable candidate is ranked last in exactly 1/m-fraction of the votes, this would be a successful 
manipulation: each undesirable candidate would gain at most an additional m- 1 
m # 2 W points. Unfortunately this 
is usually not the case, but the following condition is sufficient for a successful manipulation (assuming condition 
(3) holds). Partition the voters in T to m disjoint subsets p 1 , . . . , p i (w.l.o.g. of size n/m), and denote by W p i 
the 
total weight of the votes in p i . The condition is that for all i 2 [m]: 
(1- 1/m) 1/2 n/m # W p i # (1 + 1/m) 1/2 n/m. (4) 
This condition is sufficient, because if the voters in p i all rank c i last, the fraction of the votes in T which gives c i 
points is at most: 
(m - 1)(1 + 1/m) 
(m - 1)(1 + 1/m) + 1 - 1/m = m 2 - 1 
m 2 +m - 2 . 
Hence the number of points c i gains from the colluders is at most: 
m 2 - 1 
m 2 +m - 2 # 2 # m 2 - 1 
m 2 # 2 &lt; # 1 W - S[c i ]. 
Furthermore, by Lemma 1 and the fact that the expected total weight of n/m votes is 1/2 n/m, the probability 
that condition (4) holds is at least 1 - 2e - 2n 
m 3 . Since m is a constant, this probability is larger than 1/2 for a large 
enough n. 
Finally, it can easily be seen that # has the refinement property: if all colluders rank p first and candidate 
c second, then p gets # 1 W points, and c gets # 2 W + S[c] points. But S[c] # (# 1 - # 2 )W , and thus p surely 
loses. 
2 It seems the reduction can be generalized for a larger number of candidates. The hard instances are the ones where all undesirable 
candidates but two have approximately (# 
1- # 2 )W initial points, and two problematic candidates have approximately (# 1 - #m/2)W 
points. These instances have a positive probability under # . 
7 
4.2 A Heuristic Polynomial Time Algorithm 
We now present our algorithm for SCWM. ~ 
w denotes the vector of the weights of voters in T . 
GREEDY(C = {p, c 1 , . . . , c m },S[p], S[c 1 ], . . . , S[c m ],T = {t 1 , . . . , t n }, ~ 
w) 
1: for all c do 
2: S 0 [c] = S[c] 
3: end for 
4: for i = 1 to n do 
5: Let j 1 , j 2 , . . . , j m such that S 
i- 1 [c j 1 ] # S i- 1 [c j 2 ] # . . . # S i- 1 [c j m 
] 
6: Voter t i votes p # c j 1 # c j 2 # . . . # c j m 
7: for l = 1 to m : do 
8: S i [c j l 
] = S i- 1 [c j l 
] + w(t i )# l+1 
9: end for 
10: S i [p] = S i- 1 [p] + w(t i )# 1 
11: end for 
12: if argmax c2C {S n [c]} = {p} then 
13: return 1 
14: else 
15: return 0 
16: end if 
The voters in T , according to some order, each rank p first, and the rest of the candidates by their current 
score: the candidate with the lowest current score is ranked highest. GREEDY accepts if and only if p wins this 
election. 
This algorithm, designed specifically for scoring protocols, is a realization of an abstract greedy algorithm: 
at each stage, voter t i ranks the undesirable candidates in an order that minimizes the highest score that any 
undesirable candidate obtains after the current vote. If there is a tie between several permutations, the voter 
chooses the option such that the second highest score is as low as possible, etc. In any case, every colluder 
always ranks p first. This abstract scheme might also be appropriate for protocols such as Maximin and Copeland. 
Similarly to scoring protocols, in these two protocols the colluders are always better off by ranking p first. In 
addition, the abstract greedy algorithm can be applied to Maximin and Copeland since the result of an election is 
based on the score each candidate has (unlike STV, for example). 
In the following lemmas, a stage in the execution of the algorithm is an iteration of the for loop. 
Lemma 6. If there exists a stage i 0 during the execution of GREEDY, and two candidates a, b 6= p, such that 
|S i 0 [a] - S i 0 [b]| # # 2 , (5) 
then for all i # i 0 it holds that |S i [a] - S i [b]| # # 2 . 
Proof. The proof is by induction on i. The base of the induction is given by equation (5). Assume that |S i [a
]S i [b]| # # 2 , and without loss of generality: S i [a] # S i [b]. By the algorithm, voter t i+1 ranks b higher than a, and 
therefore: 
S i+1 [b] - S i+1 [a] # - # 2 . (6) 
Since p is always ranked first, and the weight of each vote is at most 1, b gains at most # 2 points. Therefore: 
S i+1 [b] - S i+1 [a] # # 2 . (7) 
Combining equations (6) and (7) completes the proof. 
Lemma 7. Let p 6= a, b 2 C, and suppose that there exists a stage i 0 such that S i 0 [a] # S i 0 [b], and a stage 
i 1 # i 0 such that S i 1 [b] # S i 1 [a]. Then for all i # i 1 it holds that |S i [a] - S i [b]| # # 2 . 
Proof. Assume the that there exists a stage i 0 such that S i 0 [a] # S i 0 [b], and a stage i 1 # i 0 such that S i 1 [b] # 
S i 1 [a]; w.l.o.g. i 1 } i 0 (otherwise at stage i 0 it holds that S i 0 [b] = S i 0 [a], and then we finish by Lemma 6). Then 
there must be a stage i 2 such that i 0 # i 2 &lt; i 1 and S i 2 [a] # S i 2 [b] but S i 2 +1 [b] # S i 2 +1 [a]. Since the weight of 
each vote is at most 1, b gains at most # 2 points by voter t i 2 +1 . Hence the conditions of Lemma 6 hold for stage 
i 2 , which implies that for all i # i 2 : |S i [a] - S i [b]| # # 2 . In particular, i 1 # i 2 . 
8 
Lemma 8. Let P be a sensitive scoring protocol, and assume GREEDY errs on an instance of SCWM in P which 
has a successful manipulation. Then there is d 2 {2, 3, . . . , m}, and a subset of candidates D = {c j 1 , . . . , c j d }, 
such that: 
d 
X i=1 
(# 1 W - S[c j i 
])- d- 1 
X i=1 
(i # 2 ) # W 
d 
X i=1 
#m+2- i # 
d 
X i=1 
(# 1 W - S[c j i 
]). (8) 
Proof. For the right inequality, observe that for any d candidates, even if all voters in T rank them last in every 
vote, the total points distributed among them is W P d 
i=1 
#m+2- i . If this inequality does not hold, there must 
be some candidate c i that gains at least # 1 W - S[c i ] points from the colluders, implying that this candidate 
has at least # 1 W points. However, p also has at most # 1 W points, and we assumed that there is a successful 
manipulation --- a contradiction. 
For the left inequality, assume the algorithm erred. Then at some stage i 0 , there is a candidate c j 0 
who 
has a total of at least # 1 W points (w.l.o.g. only one candidate passes this threshold simultaneously). Denote 
T 0 = {t 1 , t 2 , . . . , t i 0 }, and let W T0 be the total weight of the voters in T 0 . Voter t i 0 
did not rank c j 0 
last, since 
#m+1 = 0, and thus ranking a candidate last gives it no points. We have that there is another candidate c j 1 
, 
such that: S i 0 - 1 [c j 1 
] # S i 0 - 1 [c j 0 
]. By Lemma 7, S i 0 
[c j 0 
] - S i 0 
[c j 1 
] # # 2 , and thus S i 0 
[c j 1 
] # # 1 W - # 2 . 
If these canidates were not always ranked last by the voters of T 0 , there must be another candidate c j 2 
who was 
ranked strictly higher by some voter in T 0 , w.l.o.g. higher than c j 1 
. Therefore, we have from Lemma 7 that: 
S i 0 
[c j 1 
] - S i 0 
[c j 2 
] # # 2 , and so c j 2 
has a total of at least # 1 W - 2# 2 points. By inductively continuing this 
reasoning, we obtain a subset D of d candidates (possibly d = m), who were always ranked in the d last places 
by the voters in T 0 , and for the l'th candidate it holds that: S i 0 
[c j l 
] # # 1 W - (l - 1)# 2 . The total points gained 
by this l'th candidate until stage i 0 must be at least # 1 W - (l - 1)# 
2- S[c j l 
]. Since the total points distributed 
by the voters in T 0 to the d last candidates is W T0 P d 
i=1 
#m+2- i , we have: 
d 
X i=1 
(# 1 W - S[c j i 
]
)d- 1 
X i=1 
(i # 2 ) # W T0 
d 
X i=1 
#m+2- i # W 
d 
X i=1 
#m+2- i . 
Lemma 9. Let M be SCWM in a sensitive scoring protocol P with C = {p, c 1 , . . . , c m }, m=O(1). Then GREEDY 
is a deterministic heuristic polynomial time algorithm for hM,# i. 
Proof. It is obvious that if the given instance has no successful manipulation, then the greedy algorithm would 
indeed answer that there is no manipulation, since the algorithm is constructive (it actually selects specific votes 
for the colluders). 
We wish to bound the probability that there is a manipulation and the algorithm erred. By Lemma 8, a 
necessary condition for this to occur is as specified in equation (8), or equivalently: 
W 
d 
X i=1 
# 
1- W 
d 
X i=1 
#m+2- i - d(d - 1) 
2 # 2 # 
d 
X i=1 
S[c j i 
] # W 
d 
X i=1 
# 
1- W 
d 
X i=1 
#m+2- i . (9) 
In this case the algorithm may err; but what is the probability of equation (9) holding? Fix a subset D of size 
d 2 {2, . . . , m}. 
P d 
i=1 S[c j i 
] is a random variable that takes values in [d(# 
1- # 2 )W, d# 1 W ]. By fixing values 
for S[c j 1 ], . . . , S[c j 
d- 1 ], we have that the probability of 
P d 
i=1 S[c j i 
] taking values in some interval [a, b] is at most 
the chance of S[c j d 
] taking a value in an interval of size b - a, which is at most b- a 
#1W - (#1 - #2 )W 
, since S[c j d 
] 
is uniformly distributed. By Lemma 1, W &lt; n/4 with probability at most #(n) = e - n 
8 . On the other hand, if 
W # n/4, then (9) holds for D with probability at most 
d(d- 1) 
2 # 2 
# 1 W - (# 
1- # 2 )W = d(d - 1) 
2W # 
2d(d - 1) 
n 
= 1 
p D (n) , 
9 
for some polynomial p D . We complete the proof by showing that equation (1) holds: 
Pr 
x## n 
[GREEDY(x) 6= M(x)] # Pr[W # n/4 ^ (9D # C s.t. |D| # 2 ^ (9) holds)] + Pr[W &lt; n/4] 
# X 
D#C:|D|#2 
1 
p D (n) + #(n) 
# 
1 
poly n 
The last inequality holds by the assumption that m = O(1). 
Clearly, Theorem 2 directly follows. 
5 Susceptibility to UVWM 
In this section we shall prove: 
Theorem 10. Let P be a voting protocol such that there exists a junta distribution P over the instances of 
UVWM in P , with the following property: r is uniformly distributed in [0, 1]. Then P , with candidates C = 
{p, c 1 , . . . , c m }, m = O(1), is susceptible to UVWM. 
The existence of a junta distribution with r uniformly distributed is a very weak requirement (it is even quite 
natural to have r uniformly distributed). In fact, the following claim is very likely to be true: 
Conjecture 11. Let P be a voting protocol. Then there exists a junta distribution P over the instances of UVWM 
in P , with r uniformly distributed in [0, 1]. 
If this conjecture is indeed true, we have that all voting protocols are susceptible to UVWM. If for some reason 
the conjecture is not true with respect to our definition of junta distributions, then perhaps the definition is too 
restrictive and should be modified accordingly. We also remark that similar results can be derived for destructive 
manipulations by analogous proofs. 
To prove Theorem 10, we first present a helpful procedure, which decides UVWE. ~ 
w denotes the vector of 
given weights, and # is the given distribution over all the votes. 
SAMPLE(C = {p, c 1 , . . . , c m }, ~ 
w, #, r) 
1: count = 0 
2: for i = 1 to n 3 do 
3: Sample the distribution # over the votes 
4: Calculate the result of the election using the sampled votes 
5: if p won then 
6: count = count + 1 
7: end if 
8: end for 
9: if count/n 3 } r then 
10: return 1 
11: else 
12: return 0 
13: end if 
SAMPLE samples the given distribution on the votes n 3 times, and calculates the winner of the election each 
time. If p won more than an r-fraction of the elections then the procedure accepts, otherwise it rejects. 
Lemma 12. Let P be a voting protocol, and E be UVWE in P with C = {p, c 1 , . . . , c m }. Furthermore, let be 
a distribution over the instances of E, with r uniformly distributed in [0, 1]. Then there exists N such that for all 
n # N : 
Pr 
x#n 
[SAMPLE(x) 6= E(x)] # 
1 
polyn . 
10 
Proof. Let {X i } n 3 
i=1 
be random variables, such that X i = 1 if p won in the i'th iteration of the for loop, and 
X i = 0 otherwise. Let r 0 be the probability that p wins in the given instance. By Lemma 1 and the union bound: 
Pr 2 4 # # # # # # 
1 
n 3 
n 3 
X i=1 
X i - r 0 # # # # # # 
# 
1 
n 
3 5 # 2e - 2n 3 1 
n 2 = 2e - 2n . 
We deduce that if |r - r 0 | } 1 
n 
, SAMPLE will fail with an exponentially small probability. By the assumption that 
r is uniformly distributed, the probability that |r - r 0 | # 1 
n 
is at most 2/n. Thus, by the union bound it holds that: 
Pr 
x#n 
[SAMPLE(x) 6= E(x)] # Pr # |r - r 0 | # 
1 
n 
# + Pr # |r - r 0 | } 
1 
n ^ SAMPLE(x) 6= E(x) # 
# 2/n + 2e - 2n 
# 
1 
polyn . 
We now present an algorithm which decides UVCM. Here, ~ 
w denotes the weights of all voters including the 
manipulator, and # is the given distribution over the others' votes. 
SAMPLE-AND-MANIPULATE(C = {p, c 1 , . . . , c m }, ~ 
w, #, r) 
1: ans = 0 
2: for i = 1 to (m + 1)! do 
3: # = next permutation of the m+ 1 candidates 
4: # # = the manipulator always votes #, others' votes are distributed with respect to # 
5: if SAMPLE(C, ~ 
w, # # , r) = 1 then 
6: ans = 1 
7: end if 
8: end for 
9: return ans 
Given an instance of UVWM, SAMPLE-AND-MANIPULATE generates (m + 1)! instances of the UVWE 
problem, one for each of the manipulator's possible votes, and executes SAMPLE on each instance. SAMPLE- 
AND-MANIPULATE accepts if and only if SAMPLE accepts one of the instances. 
Lemma 13. Let P be a voting protocol, and M be UVWM in P with C = {p, c 1 , . . . , c m }, m = O(1). 
Furthermore, let be a distribution over the instances of UVWM, with r uniformly distributed in [0, 1]. Then SAMPLE- 
AND-MANIPULATE is a probabilistic heuristic polynomial time algorithm for hM,i. 
Proof. For each independent call to SAMPLE, the chance of failure is inverse-polynomial. By applying the union 
bound we have that the probability of SAMPLE failing on any of the (m+1)! invocations is at most (m+1)! 1 
polyn 
, 
which is still inverse-polynomial since m is constant. The lemma now follows from the fact that there is a 
manipulation if and only if there is a permutation of candidates, such that if the manipulator votes according to 
this permutation, the chance of p winning is greater than r. 
Notice that SAMPLE-AND-MANIPULATE is indeed polynomial by the fact that m = O(1), and we assumed 
that the given distribution over the votes can be sampled in polynomial time. 
6 Conclusions and Future Research 
The issue of resistance of mechanisms to manipulation is important, particularly in the context of voting protocols. 
Most results on this issue use NP-hardness as the complexity measure. One of this paper's main contributions 
has been in introducing tools that can be utilized in showing that manipulating mechanisms is easy in the average 
case. We were mostly concerned with the likely case of coalitional manipulation, and showed that sensitive scoring 
protocols are susceptible to such manipulation when the number of candidates is constant. We also described how 
a single manipulator can find a beneficial manipulation when it only has a distribution on the others' votes. 
11 
These results suggest that scoring protocols cannot be safely employed. More importantly, this paper should 
be seen as a starting point for studying the average case complexity of other types of manipulations, in other 
protocols. In addition, the definitions in Section 3 are deliberately general, and can be applied to manipulations of 
mechanisms which are not voting mechanisms. One such mechanism of which we are aware, whose manipulation 
is NP-hard, is presented in [1]. 
There is still room for debate as to the exact definition of a junta distribution, especially if Conjecture 11 turns 
out to be false. It may also be the case that there are "unconvincing" distributions that satisfy all of the (current) 
conditions of a junta distribution. 
An issue of great importance is coming up with natural criteria to decide when a manipulation problem is 
hard in the average-case. The traditional definition of average-case completeness is very difficult to work with 
in general; is there a satisfying definition that applies specifically to the case of manipulations? Once the subject 
is fully understood, this understanding can be used to design mechanisms that are hard to manipulate in the 
average-case.</body>
    <biblio>
      <reference refID="p12x82.0y556.0">
        <ref-marker>[1]</ref-marker>
        <authors>
          <author>
            <author-first>Y.</author-first>
            <author-last>Bachrach</author-last>
          </author>
          and
          <author>
            <author-first>J.</author-first>
            <author-middle>S.</author-middle>
            <author-last>Rosenschein.</author-last>
          </author>
        </authors>
        <title>Achieving allocatively-efficient and strongly budget-balanced mechanisms in the network flow domain for bounded-rational agents.</title>
        <conference>In The Nineteenth International Joint Conference on Artificial Intelligence,</conference>
        <address>Edinburgh, Scotland,</address>
        <date>August 2005.</date>
        <note>To appear (poster).</note>
      </reference>
      <reference refID="p12x82.0y513.0">
        <ref-marker>[2]</ref-marker>
        <authors>
          <author>
            <author-first>J.</author-first>
            <author-last>Bartholdi</author-last>
          </author>
          and
          <author>
            <author-first>J.</author-first>
            <author-last>Orlin.</author-last>
          </author>
        </authors>
        <title>Single transferable vote resists strategic voting.</title>
        <journal>Social Choice and Welfare,</journal>
        <volume>8</volume>
        <number>(4):</number>
        <pages>341--354,</pages>
        <date>1991.</date>
      </reference>
      <reference refID="p12x82.0y481.0">
        <ref-marker>[3]</ref-marker>
        <authors>
          <author>
            <author-first>V.</author-first>
            <author-last>Conitzer,</author-last>
          </author>
          <author>
            <author-first>J.</author-first>
            <author-last>Lang,</author-last>
          </author>
          and
          <author>
            <author-first>T.</author-first>
            <author-last>Sandholm.</author-last>
          </author>
        </authors>
        <title>How many candidates are needed to make elections hard to manipulate?</title>
        <conference>In Proceedings of the International Conference on Theoretical Aspects of Reasoning about Knowledge,</conference>
        <pages>pages 201--214,</pages>
        <address>Bloomington, Indiana,</address>
        <date>2003.</date>
      </reference>
      <reference refID="p12x82.0y437.0">
        <ref-marker>[4]</ref-marker>
        <authors>
          <author>
            <author-first>V.</author-first>
            <author-last>Conitzer</author-last>
          </author>
          and
          <author>
            <author-first>T.</author-first>
            <author-last>Sandholm.</author-last>
          </author>
        </authors>
        <title>Complexity of manipulating elections with few candidates.</title>
        <conference>In Proceedings of the National Conference on Artificial Intelligence,</conference>
        <pages>pages 314--319,</pages>
        <address>Edmonton, Canada,</address>
        <date>July 2002.</date>
      </reference>
      <reference refID="p12x82.0y405.0">
        <ref-marker>[5]</ref-marker>
        <authors>
          <author>
            <author-first>V.</author-first>
            <author-last>Conitzer</author-last>
          </author>
          and
          <author>
            <author-first>T.</author-first>
            <author-last>Sandholm.</author-last>
          </author>
        </authors>
        <title>Universal voting protocol tweaks to make manipulation hard.</title>
        <conference>In Proceedings of the International Joint Conference on Artificial Intelligence,</conference>
        <pages>pages 781--788,</pages>
        <address>Acapulco, Mexico,</address>
        <date>August 2003.</date>
      </reference>
      <reference refID="p12x82.0y361.0">
        <ref-marker>[6]</ref-marker>
        <authors>
          <author>
            <author-first>E.</author-first>
            <author-last>Elkind</author-last>
          </author>
          and
          <author>
            <author-first>H.</author-first>
            <author-last>Lipmaa.</author-last>
          </author>
        </authors>
        <title>Small coalitions cannot manipulate voting.</title>
        <conference>In International Conference on Financial Cryptography,</conference>
        <series>Lecture Notes in Computer Science.</series>
        <publisher>Springer-Verlag,</publisher>
        <address>Roseau, The Commonwealth of Dominica,</address>
        <date>2005.</date>
      </reference>
      <reference refID="p12x82.0y317.0">
        <ref-marker>[7]</ref-marker>
        <authors>
          <author>
            <author-first>A.</author-first>
            <author-last>Gibbard.</author-last>
          </author>
        </authors>
        <title>Manipulation of voting schemes.</title>
        <journal>Econometrica,</journal>
        <volume>41:</volume>
        <pages>587--602,</pages>
        <date>1973.</date>
      </reference>
      <reference refID="p12x82.0y297.0">
        <ref-marker>[8]</ref-marker>
        <authors>
          <author>
            <author-first>M.</author-first>
            <author-last>Satterthwaite.</author-last>
          </author>
        </authors>
        <title>Strategy-proofness and Arrow's conditions: Existence and correspondence theorems for voting procedures and social welfare functions.</title>
        <journal>Journal of Economic Theory,</journal>
        <volume>10:</volume>
        <pages>187--217,</pages>
        <date>1975.</date>
      </reference>
      <reference refID="p12x82.0y266.0">
        <ref-marker>[9]</ref-marker>
        <authors>
          <author>
            <author-first>L.</author-first>
            <author-last>Trevisan.</author-last>
          </author>
        </authors>
        <title>Lecture notes on computational complexity.</title>
        <note>Available from</note>
        <web>http://www.cs.berkeley.edu/~luca/notes/complexitynotes02.pdf,</web>
        <date>2002.</date>
        <note>Lecture 12.</note>
      </reference>
    </biblio>
  </content>
  <CitationContexts />
  <grants />
</document>

